// This file has been generated by Py++.

#include "boost/python.hpp"
#include "__call_policies.pypp.hpp"
#include "__convenience.pypp.hpp"
#include "opencv_converters.hpp"
#include "__ctypes_integration.pypp.hpp"
#include "cvaux_wrapper.hpp"
#include "cvaux_ext_classes_3.pypp.hpp"

namespace bp = boost::python;

static void Detect_d8fa7b620f024b1a2f20fc4afa978e15( ::CvObjectDetector & inst, ::cv::Mat & arg0, ::CvBlobSeq * arg1=0 ){
    inst.Detect(get_CvMat_ptr(arg0), arg1);
}

struct CvVSModule_wrapper : CvVSModule, bp::wrapper< CvVSModule > {

    CvVSModule_wrapper( )
    : CvVSModule( )
      , bp::wrapper< CvVSModule >(){
        // null constructor
    
    }

    virtual void LoadState( ::CvFileStorage * arg0, ::CvFileNode * arg1 ) {
        namespace bpl = boost::python;
        if( bpl::override func_LoadState = this->get_override( "LoadState" ) ){
            bpl::object py_result = bpl::call<bpl::object>( func_LoadState.ptr(), arg0, arg1 );
        }
        else{
            CvVSModule::LoadState( boost::python::ptr(arg0), boost::python::ptr(arg1) );
        }
    }
    
    static void default_LoadState( ::CvVSModule & inst, ::cv::FileStorage & arg0, ::cv::FileNode & arg1 ){
        if( dynamic_cast< CvVSModule_wrapper * >( boost::addressof( inst ) ) ){
            inst.::CvVSModule::LoadState(arg0.fs, *(arg1));
        }
        else{
            inst.LoadState(arg0.fs, *(arg1));
        }
    }

    virtual void ParamUpdate(  ) {
        if( bp::override func_ParamUpdate = this->get_override( "ParamUpdate" ) )
            func_ParamUpdate(  );
        else{
            this->CvVSModule::ParamUpdate(  );
        }
    }
    
    void default_ParamUpdate(  ) {
        CvVSModule::ParamUpdate( );
    }

    virtual void Release(  ){
        bp::override func_Release = this->get_override( "Release" );
        func_Release(  );
    }

    virtual void SaveState( ::CvFileStorage * arg0 ) {
        namespace bpl = boost::python;
        if( bpl::override func_SaveState = this->get_override( "SaveState" ) ){
            bpl::object py_result = bpl::call<bpl::object>( func_SaveState.ptr(), arg0 );
        }
        else{
            CvVSModule::SaveState( boost::python::ptr(arg0) );
        }
    }
    
    static void default_SaveState( ::CvVSModule & inst, ::cv::FileStorage & arg0 ){
        if( dynamic_cast< CvVSModule_wrapper * >( boost::addressof( inst ) ) ){
            inst.::CvVSModule::SaveState(arg0.fs);
        }
        else{
            inst.SaveState(arg0.fs);
        }
    }

};

inline bp::str CvVSModule_GetModuleName(CvVSModule &inst) {  return bp::str(inst.GetModuleName()); }

struct BackgroundSubtractor_wrapper : cv::BackgroundSubtractor, bp::wrapper< cv::BackgroundSubtractor > {

    BackgroundSubtractor_wrapper(cv::BackgroundSubtractor const & arg )
    : cv::BackgroundSubtractor( arg )
      , bp::wrapper< cv::BackgroundSubtractor >(){
        // copy constructor
        
    }

    BackgroundSubtractor_wrapper()
    : cv::BackgroundSubtractor()
      , bp::wrapper< cv::BackgroundSubtractor >(){
        // null constructor
        
    }

    virtual void operator()( ::cv::Mat const & image, ::cv::Mat & fgmask, double learningRate=0 ) {
        if( bp::override func___call__ = this->get_override( "__call__" ) )
            func___call__( boost::ref(image), boost::ref(fgmask), learningRate );
        else{
            this->cv::BackgroundSubtractor::operator()( boost::ref(image), boost::ref(fgmask), learningRate );
        }
    }
    
    void default___call__( ::cv::Mat const & image, ::cv::Mat & fgmask, double learningRate=0 ) {
        cv::BackgroundSubtractor::operator()( boost::ref(image), boost::ref(fgmask), learningRate );
    }

};

struct BackgroundSubtractorMOG_wrapper : cv::BackgroundSubtractorMOG, bp::wrapper< cv::BackgroundSubtractorMOG > {

    BackgroundSubtractorMOG_wrapper(cv::BackgroundSubtractorMOG const & arg )
    : cv::BackgroundSubtractorMOG( arg )
      , bp::wrapper< cv::BackgroundSubtractorMOG >(){
        // copy constructor
        
    }

    BackgroundSubtractorMOG_wrapper( )
    : cv::BackgroundSubtractorMOG( )
      , bp::wrapper< cv::BackgroundSubtractorMOG >(){
        // null constructor
    
    }

    BackgroundSubtractorMOG_wrapper(int history, int nmixtures, double backgroundRatio, double noiseSigma=0 )
    : cv::BackgroundSubtractorMOG( history, nmixtures, backgroundRatio, noiseSigma )
      , bp::wrapper< cv::BackgroundSubtractorMOG >(){
        // constructor
    
    }

    virtual void initialize( ::cv::Size frameSize, int frameType ) {
        if( bp::override func_initialize = this->get_override( "initialize" ) )
            func_initialize( frameSize, frameType );
        else{
            this->cv::BackgroundSubtractorMOG::initialize( frameSize, frameType );
        }
    }
    
    void default_initialize( ::cv::Size frameSize, int frameType ) {
        cv::BackgroundSubtractorMOG::initialize( frameSize, frameType );
    }

    virtual void operator()( ::cv::Mat const & image, ::cv::Mat & fgmask, double learningRate=0 ) {
        if( bp::override func___call__ = this->get_override( "__call__" ) )
            func___call__( boost::ref(image), boost::ref(fgmask), learningRate );
        else{
            this->cv::BackgroundSubtractorMOG::operator()( boost::ref(image), boost::ref(fgmask), learningRate );
        }
    }
    
    void default___call__( ::cv::Mat const & image, ::cv::Mat & fgmask, double learningRate=0 ) {
        cv::BackgroundSubtractorMOG::operator()( boost::ref(image), boost::ref(fgmask), learningRate );
    }

};

struct FernClassifier_wrapper : cv::FernClassifier, bp::wrapper< cv::FernClassifier > {

    FernClassifier_wrapper(cv::FernClassifier const & arg )
    : cv::FernClassifier( arg )
      , bp::wrapper< cv::FernClassifier >(){
        // copy constructor
        
    }

    FernClassifier_wrapper( )
    : cv::FernClassifier( )
      , bp::wrapper< cv::FernClassifier >(){
        // null constructor
    
    }

    FernClassifier_wrapper(::cv::FileNode const & node )
    : cv::FernClassifier( boost::ref(node) )
      , bp::wrapper< cv::FernClassifier >(){
        // constructor
    
    }

    FernClassifier_wrapper(::std::vector< cv::Point_<float> > const & points, ::std::vector< cv::Ptr<cv::Mat> > const & refimgs, ::std::vector< int > const & labels=std::vector<int>(), int _nclasses=0, int _patchSize=int(::cv::FernClassifier::PATCH_SIZE), int _signatureSize=int(::cv::FernClassifier::DEFAULT_SIGNATURE_SIZE), int _nstructs=int(::cv::FernClassifier::DEFAULT_STRUCTS), int _structSize=int(::cv::FernClassifier::DEFAULT_STRUCT_SIZE), int _nviews=int(::cv::FernClassifier::DEFAULT_VIEWS), int _compressionMethod=int(::cv::FernClassifier::COMPRESSION_NONE), ::cv::PatchGenerator const & patchGenerator=cv::PatchGenerator() )
    : cv::FernClassifier( boost::ref(points), boost::ref(refimgs), boost::ref(labels), _nclasses, _patchSize, _signatureSize, _nstructs, _structSize, _nviews, _compressionMethod, boost::ref(patchGenerator) )
      , bp::wrapper< cv::FernClassifier >(){
        // constructor
    
    }

    virtual void clear(  ) {
        if( bp::override func_clear = this->get_override( "clear" ) )
            func_clear(  );
        else{
            this->cv::FernClassifier::clear(  );
        }
    }
    
    void default_clear(  ) {
        cv::FernClassifier::clear( );
    }

    virtual int operator()( ::cv::Mat const & img, ::cv::Point2f kpt, ::std::vector< float > & signature ) const  {
        namespace bpl = boost::python;
        if( bpl::override func___call__ = this->get_override( "__call__" ) ){
            bpl::object py_result = bpl::call<bpl::object>( func___call__.ptr(), img, kpt, signature );
            return bpl::extract< int >( pyplus_conv::get_out_argument( py_result, 0 ) );
        }
        else{
            return cv::FernClassifier::operator()( boost::ref(img), kpt, boost::ref(signature) );
        }
    }
    
    static boost::python::tuple default___call___c4d2198033cf380377bb6f32571c2657( ::cv::FernClassifier const & inst, ::cv::Mat const & img, ::cv::Point2f kpt ){
        std::vector<float> signature2;
        int result;
        if( dynamic_cast< FernClassifier_wrapper const* >( boost::addressof( inst ) ) ){
            result = inst.::cv::FernClassifier::operator()(img, kpt, signature2);
        }
        else{
            result = inst.operator()(img, kpt, signature2);
        }
        return bp::make_tuple( result, signature2 );
    }

    virtual int operator()( ::cv::Mat const & patch, ::std::vector< float > & signature ) const  {
        namespace bpl = boost::python;
        if( bpl::override func___call__ = this->get_override( "__call__" ) ){
            bpl::object py_result = bpl::call<bpl::object>( func___call__.ptr(), patch, signature );
            return bpl::extract< int >( pyplus_conv::get_out_argument( py_result, 0 ) );
        }
        else{
            return cv::FernClassifier::operator()( boost::ref(patch), boost::ref(signature) );
        }
    }
    
    static boost::python::tuple default___call___ddcd7402f4cc50fa35ce4888642630c7( ::cv::FernClassifier const & inst, ::cv::Mat const & patch ){
        std::vector<float> signature2;
        int result;
        if( dynamic_cast< FernClassifier_wrapper const* >( boost::addressof( inst ) ) ){
            result = inst.::cv::FernClassifier::operator()(patch, signature2);
        }
        else{
            result = inst.operator()(patch, signature2);
        }
        return bp::make_tuple( result, signature2 );
    }

    virtual void read( ::cv::FileNode const & n ) {
        if( bp::override func_read = this->get_override( "read" ) )
            func_read( boost::ref(n) );
        else{
            this->cv::FernClassifier::read( boost::ref(n) );
        }
    }
    
    void default_read( ::cv::FileNode const & n ) {
        cv::FernClassifier::read( boost::ref(n) );
    }

    virtual void train( ::std::vector< cv::Point_<float> > const & points, ::std::vector< cv::Ptr<cv::Mat> > const & refimgs, ::std::vector< int > const & labels=std::vector<int>(), int _nclasses=0, int _patchSize=int(::cv::FernClassifier::PATCH_SIZE), int _signatureSize=int(::cv::FernClassifier::DEFAULT_SIGNATURE_SIZE), int _nstructs=int(::cv::FernClassifier::DEFAULT_STRUCTS), int _structSize=int(::cv::FernClassifier::DEFAULT_STRUCT_SIZE), int _nviews=int(::cv::FernClassifier::DEFAULT_VIEWS), int _compressionMethod=int(::cv::FernClassifier::COMPRESSION_NONE), ::cv::PatchGenerator const & patchGenerator=cv::PatchGenerator() ) {
        if( bp::override func_train = this->get_override( "train" ) )
            func_train( boost::ref(points), boost::ref(refimgs), boost::ref(labels), _nclasses, _patchSize, _signatureSize, _nstructs, _structSize, _nviews, _compressionMethod, boost::ref(patchGenerator) );
        else{
            this->cv::FernClassifier::train( boost::ref(points), boost::ref(refimgs), boost::ref(labels), _nclasses, _patchSize, _signatureSize, _nstructs, _structSize, _nviews, _compressionMethod, boost::ref(patchGenerator) );
        }
    }
    
    void default_train( ::std::vector< cv::Point_<float> > const & points, ::std::vector< cv::Ptr<cv::Mat> > const & refimgs, ::std::vector< int > const & labels=std::vector<int>(), int _nclasses=0, int _patchSize=int(::cv::FernClassifier::PATCH_SIZE), int _signatureSize=int(::cv::FernClassifier::DEFAULT_SIGNATURE_SIZE), int _nstructs=int(::cv::FernClassifier::DEFAULT_STRUCTS), int _structSize=int(::cv::FernClassifier::DEFAULT_STRUCT_SIZE), int _nviews=int(::cv::FernClassifier::DEFAULT_VIEWS), int _compressionMethod=int(::cv::FernClassifier::COMPRESSION_NONE), ::cv::PatchGenerator const & patchGenerator=cv::PatchGenerator() ) {
        cv::FernClassifier::train( boost::ref(points), boost::ref(refimgs), boost::ref(labels), _nclasses, _patchSize, _signatureSize, _nstructs, _structSize, _nviews, _compressionMethod, boost::ref(patchGenerator) );
    }

    virtual void trainFromSingleView( ::cv::Mat const & image, ::std::vector< cv::KeyPoint > const & keypoints, int _patchSize=int(::cv::FernClassifier::PATCH_SIZE), int _signatureSize=int(::cv::FernClassifier::DEFAULT_SIGNATURE_SIZE), int _nstructs=int(::cv::FernClassifier::DEFAULT_STRUCTS), int _structSize=int(::cv::FernClassifier::DEFAULT_STRUCT_SIZE), int _nviews=int(::cv::FernClassifier::DEFAULT_VIEWS), int _compressionMethod=int(::cv::FernClassifier::COMPRESSION_NONE), ::cv::PatchGenerator const & patchGenerator=cv::PatchGenerator() ) {
        if( bp::override func_trainFromSingleView = this->get_override( "trainFromSingleView" ) )
            func_trainFromSingleView( boost::ref(image), boost::ref(keypoints), _patchSize, _signatureSize, _nstructs, _structSize, _nviews, _compressionMethod, boost::ref(patchGenerator) );
        else{
            this->cv::FernClassifier::trainFromSingleView( boost::ref(image), boost::ref(keypoints), _patchSize, _signatureSize, _nstructs, _structSize, _nviews, _compressionMethod, boost::ref(patchGenerator) );
        }
    }
    
    void default_trainFromSingleView( ::cv::Mat const & image, ::std::vector< cv::KeyPoint > const & keypoints, int _patchSize=int(::cv::FernClassifier::PATCH_SIZE), int _signatureSize=int(::cv::FernClassifier::DEFAULT_SIGNATURE_SIZE), int _nstructs=int(::cv::FernClassifier::DEFAULT_STRUCTS), int _structSize=int(::cv::FernClassifier::DEFAULT_STRUCT_SIZE), int _nviews=int(::cv::FernClassifier::DEFAULT_VIEWS), int _compressionMethod=int(::cv::FernClassifier::COMPRESSION_NONE), ::cv::PatchGenerator const & patchGenerator=cv::PatchGenerator() ) {
        cv::FernClassifier::trainFromSingleView( boost::ref(image), boost::ref(keypoints), _patchSize, _signatureSize, _nstructs, _structSize, _nviews, _compressionMethod, boost::ref(patchGenerator) );
    }

    virtual void write( ::cv::FileStorage & fs, ::cv::String const & name=std::string() ) const  {
        if( bp::override func_write = this->get_override( "write" ) )
            func_write( boost::ref(fs), boost::ref(name) );
        else{
            this->cv::FernClassifier::write( boost::ref(fs), boost::ref(name) );
        }
    }
    
    void default_write( ::cv::FileStorage & fs, ::cv::String const & name=std::string() ) const  {
        cv::FernClassifier::write( boost::ref(fs), boost::ref(name) );
    }

};

void register_classes_3(){

    bp::class_< CvFuzzyRule >( "CvFuzzyRule" )    
        .add_property( "this", pyplus_conv::make_addressof_inst_getter< CvFuzzyRule >() );

    { //::CvObjectDetector
        typedef bp::class_< CvObjectDetector > CvObjectDetector_exposer_t;
        CvObjectDetector_exposer_t CvObjectDetector_exposer = CvObjectDetector_exposer_t( "CvObjectDetector", bp::init< bp::optional< char const * > >(( bp::arg("arg0")=bp::object() )) );
        bp::scope CvObjectDetector_scope( CvObjectDetector_exposer );
        CvObjectDetector_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< CvObjectDetector >() );
        bp::implicitly_convertible< char const *, CvObjectDetector >();
        { //::CvObjectDetector::Detect
        
            typedef void ( *Detect_function_type )( CvObjectDetector &,::cv::Mat &,CvBlobSeq * );
            
            CvObjectDetector_exposer.def( 
                "Detect"
                , Detect_function_type( &Detect_d8fa7b620f024b1a2f20fc4afa978e15 )
                , ( bp::arg("inst"), bp::arg("arg0"), bp::arg("arg1")=bp::object() )
                , "\nArgument 'arg0':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat." );
        
        }
        { //::CvObjectDetector::GetMaxBorderSize
        
            typedef int ( ::CvObjectDetector::*GetMaxBorderSize_function_type )(  ) const;
            
            CvObjectDetector_exposer.def( 
                "GetMaxBorderSize"
                , GetMaxBorderSize_function_type( &::CvObjectDetector::GetMaxBorderSize ) );
        
        }
        { //::CvObjectDetector::GetMinWindowSize
        
            typedef ::CvSize ( ::CvObjectDetector::*GetMinWindowSize_function_type )(  ) const;
            
            CvObjectDetector_exposer.def( 
                "GetMinWindowSize"
                , GetMinWindowSize_function_type( &::CvObjectDetector::GetMinWindowSize ) );
        
        }
        { //::CvObjectDetector::Load
        
            typedef bool ( ::CvObjectDetector::*Load_function_type )( char const * ) ;
            
            CvObjectDetector_exposer.def( 
                "Load"
                , Load_function_type( &::CvObjectDetector::Load )
                , ( bp::arg("arg0")=bp::object() ) );
        
        }
    }

    bp::class_< CvVSModule_wrapper, boost::noncopyable >( "CvVSModule", bp::init< >() )    
        .add_property( "this", pyplus_conv::make_addressof_inst_getter< CvVSModule >() )    
        .def( 
            "GetNickName"
            , (char const * ( CvVSModule::* )(  ) )( &::CvVSModule::GetNickName ) )    
        .def( 
            "GetParam"
            , (double ( CvVSModule::* )( char const * ) )( &::CvVSModule::GetParam )
            , ( bp::arg("name") ) )    
        .def( 
            "GetParamComment"
            , (char const * ( CvVSModule::* )( char const * ) )( &::CvVSModule::GetParamComment )
            , ( bp::arg("name") ) )    
        .def( 
            "GetParamName"
            , (char const * ( CvVSModule::* )( int ) )( &::CvVSModule::GetParamName )
            , ( bp::arg("index") ) )    
        .def( 
            "GetParamStr"
            , (char const * ( CvVSModule::* )( char const * ) )( &::CvVSModule::GetParamStr )
            , ( bp::arg("name") ) )    
        .def( 
            "GetTypeName"
            , (char const * ( CvVSModule::* )(  ) )( &::CvVSModule::GetTypeName ) )    
        .def( 
            "IsModuleName"
            , (int ( CvVSModule::* )( char const * ) )( &::CvVSModule::IsModuleName )
            , ( bp::arg("name") ) )    
        .def( 
            "IsModuleTypeName"
            , (int ( CvVSModule::* )( char const * ) )( &::CvVSModule::IsModuleTypeName )
            , ( bp::arg("name") ) )    
        .def( 
            "LoadState"
            , (void (*)( CvVSModule &,::cv::FileStorage &,::cv::FileNode & ))( &CvVSModule_wrapper::default_LoadState )
            , ( bp::arg("inst"), bp::arg("arg0"), bp::arg("arg1") )
            , "\nArgument 'arg0':"\
    "\n    C++ type: ::CvFileStorage *."\
    "\n    Python type: FileStorage."\
    "\nArgument 'arg1':"\
    "\n    C++ type: ::CvFileNode *."\
    "\n    Python type: FileNode." )    
        .def( 
            "ParamUpdate"
            , (void ( CvVSModule::* )(  ) )(&::CvVSModule::ParamUpdate)
            , (void ( CvVSModule_wrapper::* )(  ) )(&CvVSModule_wrapper::default_ParamUpdate) )    
        .def( 
            "Release"
            , bp::pure_virtual( (void ( CvVSModule::* )(  ) )(&::CvVSModule::Release) ) )    
        .def( 
            "SaveState"
            , (void (*)( CvVSModule &,::cv::FileStorage & ))( &CvVSModule_wrapper::default_SaveState )
            , ( bp::arg("inst"), bp::arg("arg0") )
            , "\nArgument 'arg0':"\
    "\n    C++ type: ::CvFileStorage *."\
    "\n    Python type: FileStorage." )    
        .def( 
            "SetNickName"
            , (void ( CvVSModule::* )( char const * ) )( &::CvVSModule::SetNickName )
            , ( bp::arg("pStr") ) )    
        .def( 
            "SetParam"
            , (void ( CvVSModule::* )( char const *,double ) )( &::CvVSModule::SetParam )
            , ( bp::arg("name"), bp::arg("val") ) )    
        .def( 
            "SetParamStr"
            , (void ( CvVSModule::* )( char const *,char const * ) )( &::CvVSModule::SetParamStr )
            , ( bp::arg("name"), bp::arg("str") ) )    
        .def( 
            "TransferParamsFromChild"
            , (void ( CvVSModule::* )( ::CvVSModule *,char const * ) )( &::CvVSModule::TransferParamsFromChild )
            , ( bp::arg("pM"), bp::arg("prefix")=bp::object() ) )    
        .def( 
            "TransferParamsToChild"
            , (void ( CvVSModule::* )( ::CvVSModule *,char * ) )( &::CvVSModule::TransferParamsToChild )
            , ( bp::arg("pM"), bp::arg("prefix")=bp::object() ) )    
        .def("GetModuleName", &::CvVSModule_GetModuleName);

    bp::class_< BackgroundSubtractor_wrapper >( "BackgroundSubtractor" )    
        .add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::BackgroundSubtractor >() )    
        .def( 
            "__call__"
            , (void ( cv::BackgroundSubtractor::* )( ::cv::Mat const &,::cv::Mat &,double ) )(&::cv::BackgroundSubtractor::operator())
            , (void ( BackgroundSubtractor_wrapper::* )( ::cv::Mat const &,::cv::Mat &,double ) )(&BackgroundSubtractor_wrapper::default___call__)
            , ( bp::arg("image"), bp::arg("fgmask"), bp::arg("learningRate")=0 ) );

    bp::class_< BackgroundSubtractorMOG_wrapper, bp::bases< cv::BackgroundSubtractor > >( "BackgroundSubtractorMOG", bp::init< >() )    
        .add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::BackgroundSubtractorMOG >() )    
        .def( bp::init< int, int, double, bp::optional< double > >(( bp::arg("history"), bp::arg("nmixtures"), bp::arg("backgroundRatio"), bp::arg("noiseSigma")=0 )) )    
        .def( 
            "initialize"
            , (void ( cv::BackgroundSubtractorMOG::* )( ::cv::Size,int ) )(&::cv::BackgroundSubtractorMOG::initialize)
            , (void ( BackgroundSubtractorMOG_wrapper::* )( ::cv::Size,int ) )(&BackgroundSubtractorMOG_wrapper::default_initialize)
            , ( bp::arg("frameSize"), bp::arg("frameType") ) )    
        .def( 
            "__call__"
            , (void ( cv::BackgroundSubtractorMOG::* )( ::cv::Mat const &,::cv::Mat &,double ) )(&::cv::BackgroundSubtractorMOG::operator())
            , (void ( BackgroundSubtractorMOG_wrapper::* )( ::cv::Mat const &,::cv::Mat &,double ) )(&BackgroundSubtractorMOG_wrapper::default___call__)
            , ( bp::arg("image"), bp::arg("fgmask"), bp::arg("learningRate")=0 ) )    
        .def_readwrite( "backgroundRatio", &cv::BackgroundSubtractorMOG::backgroundRatio )    
        .def_readwrite( "bgmodel", &cv::BackgroundSubtractorMOG::bgmodel )    
        .def_readwrite( "frameSize", &cv::BackgroundSubtractorMOG::frameSize )    
        .def_readwrite( "frameType", &cv::BackgroundSubtractorMOG::frameType )    
        .def_readwrite( "history", &cv::BackgroundSubtractorMOG::history )    
        .def_readwrite( "nframes", &cv::BackgroundSubtractorMOG::nframes )    
        .def_readwrite( "nmixtures", &cv::BackgroundSubtractorMOG::nmixtures )    
        .def_readwrite( "noiseSigma", &cv::BackgroundSubtractorMOG::noiseSigma )    
        .def_readwrite( "varThreshold", &cv::BackgroundSubtractorMOG::varThreshold );

    bp::class_< cv::CvAffinePose >( "CvAffinePose" )    
        .add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::CvAffinePose >() )    
        .def_readwrite( "lambda1", &cv::CvAffinePose::lambda1 )    
        .def_readwrite( "lambda2", &cv::CvAffinePose::lambda2 )    
        .def_readwrite( "phi", &cv::CvAffinePose::phi )    
        .def_readwrite( "theta", &cv::CvAffinePose::theta );

    { //::cv::DefaultRngAuto
        typedef bp::class_< cv::DefaultRngAuto, boost::noncopyable > DefaultRngAuto_exposer_t;
        DefaultRngAuto_exposer_t DefaultRngAuto_exposer = DefaultRngAuto_exposer_t( "DefaultRngAuto", bp::no_init );
        bp::scope DefaultRngAuto_scope( DefaultRngAuto_exposer );
        DefaultRngAuto_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::DefaultRngAuto >() );
    }

    bp::class_< cv::PatchGenerator >( "PatchGenerator", bp::init< >() )    
        .add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::PatchGenerator >() )    
        .def( bp::init< double, double, double, bp::optional< bool, double, double, double, double, double, double > >(( bp::arg("_backgroundMin"), bp::arg("_backgroundMax"), bp::arg("_noiseRange"), bp::arg("_randomBlur")=(bool)(true), bp::arg("_lambdaMin")=5.99999999999999977795539507496869191527366638184e-1, bp::arg("_lambdaMax")=1.5e+0, bp::arg("_thetaMin")=-3.14159265358979311599796346854418516159057617188e+0, bp::arg("_thetaMax")=3.14159265358979311599796346854418516159057617188e+0, bp::arg("_phiMin")=-3.14159265358979311599796346854418516159057617188e+0, bp::arg("_phiMax")=3.14159265358979311599796346854418516159057617188e+0 )) )    
        .def( 
            "generateRandomTransform"
            , (void ( cv::PatchGenerator::* )( ::cv::Point2f,::cv::Point2f,::cv::Mat &,::cv::RNG &,bool ) const)( &::cv::PatchGenerator::generateRandomTransform )
            , ( bp::arg("srcCenter"), bp::arg("dstCenter"), bp::arg("transform"), bp::arg("rng"), bp::arg("inverse")=(bool)(false) ) )    
        .def( 
            "__call__"
            , (void ( cv::PatchGenerator::* )( ::cv::Mat const &,::cv::Point2f,::cv::Mat &,::cv::Size,::cv::RNG & ) const)( &::cv::PatchGenerator::operator() )
            , ( bp::arg("image"), bp::arg("pt"), bp::arg("patch"), bp::arg("patchSize"), bp::arg("rng") ) )    
        .def( 
            "__call__"
            , (void ( cv::PatchGenerator::* )( ::cv::Mat const &,::cv::Mat const &,::cv::Mat &,::cv::Size,::cv::RNG & ) const)( &::cv::PatchGenerator::operator() )
            , ( bp::arg("image"), bp::arg("transform"), bp::arg("patch"), bp::arg("patchSize"), bp::arg("rng") ) )    
        .def( 
            "warpWholeImage"
            , (void ( cv::PatchGenerator::* )( ::cv::Mat const &,::cv::Mat &,::cv::Mat &,::cv::Mat &,int,::cv::RNG & ) const)( &::cv::PatchGenerator::warpWholeImage )
            , ( bp::arg("image"), bp::arg("matT"), bp::arg("buf"), bp::arg("warped"), bp::arg("border"), bp::arg("rng") ) )    
        .def_readwrite( "backgroundMax", &cv::PatchGenerator::backgroundMax )    
        .def_readwrite( "backgroundMin", &cv::PatchGenerator::backgroundMin )    
        .def_readwrite( "lambdaMax", &cv::PatchGenerator::lambdaMax )    
        .def_readwrite( "lambdaMin", &cv::PatchGenerator::lambdaMin )    
        .def_readwrite( "noiseRange", &cv::PatchGenerator::noiseRange )    
        .def_readwrite( "phiMax", &cv::PatchGenerator::phiMax )    
        .def_readwrite( "phiMin", &cv::PatchGenerator::phiMin )    
        .def_readwrite( "randomBlur", &cv::PatchGenerator::randomBlur )    
        .def_readwrite( "thetaMax", &cv::PatchGenerator::thetaMax )    
        .def_readwrite( "thetaMin", &cv::PatchGenerator::thetaMin );

    { //::cv::FernClassifier
        typedef bp::class_< FernClassifier_wrapper > FernClassifier_exposer_t;
        FernClassifier_exposer_t FernClassifier_exposer = FernClassifier_exposer_t( "FernClassifier", bp::init< >() );
        bp::scope FernClassifier_scope( FernClassifier_exposer );
        FernClassifier_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::FernClassifier >() );
        bp::scope().attr("PATCH_SIZE") = (int)cv::FernClassifier::PATCH_SIZE;
        bp::scope().attr("DEFAULT_STRUCTS") = (int)cv::FernClassifier::DEFAULT_STRUCTS;
        bp::scope().attr("DEFAULT_STRUCT_SIZE") = (int)cv::FernClassifier::DEFAULT_STRUCT_SIZE;
        bp::scope().attr("DEFAULT_VIEWS") = (int)cv::FernClassifier::DEFAULT_VIEWS;
        bp::scope().attr("DEFAULT_SIGNATURE_SIZE") = (int)cv::FernClassifier::DEFAULT_SIGNATURE_SIZE;
        bp::scope().attr("COMPRESSION_NONE") = (int)cv::FernClassifier::COMPRESSION_NONE;
        bp::scope().attr("COMPRESSION_RANDOM_PROJ") = (int)cv::FernClassifier::COMPRESSION_RANDOM_PROJ;
        bp::scope().attr("COMPRESSION_PCA") = (int)cv::FernClassifier::COMPRESSION_PCA;
        bp::scope().attr("DEFAULT_COMPRESSION_METHOD") = (int)cv::FernClassifier::DEFAULT_COMPRESSION_METHOD;
        bp::class_< cv::FernClassifier::Feature >( "Feature", bp::init< >() )    
            .add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::FernClassifier::Feature >() )    
            .def( bp::init< int, int, int, int >(( bp::arg("_x1"), bp::arg("_y1"), bp::arg("_x2"), bp::arg("_y2") )) )    
            .def_readwrite( "x1", &cv::FernClassifier::Feature::x1 )    
            .def_readwrite( "x2", &cv::FernClassifier::Feature::x2 )    
            .def_readwrite( "y1", &cv::FernClassifier::Feature::y1 )    
            .def_readwrite( "y2", &cv::FernClassifier::Feature::y2 );
        FernClassifier_exposer.def( bp::init< cv::FileNode const & >(( bp::arg("node") )) );
        bp::implicitly_convertible< cv::FileNode const &, cv::FernClassifier >();
        FernClassifier_exposer.def( bp::init< std::vector< cv::Point_<float> > const &, std::vector< cv::Ptr<cv::Mat> > const &, bp::optional< std::vector< int > const &, int, int, int, int, int, int, int, cv::PatchGenerator const & > >(( bp::arg("points"), bp::arg("refimgs"), bp::arg("labels")=std::vector<int>(), bp::arg("_nclasses")=(int)(0), bp::arg("_patchSize")=int(::cv::FernClassifier::PATCH_SIZE), bp::arg("_signatureSize")=int(::cv::FernClassifier::DEFAULT_SIGNATURE_SIZE), bp::arg("_nstructs")=int(::cv::FernClassifier::DEFAULT_STRUCTS), bp::arg("_structSize")=int(::cv::FernClassifier::DEFAULT_STRUCT_SIZE), bp::arg("_nviews")=int(::cv::FernClassifier::DEFAULT_VIEWS), bp::arg("_compressionMethod")=int(::cv::FernClassifier::COMPRESSION_NONE), bp::arg("patchGenerator")=cv::PatchGenerator() )) );
        { //::cv::FernClassifier::clear
        
            typedef void ( ::cv::FernClassifier::*clear_function_type )(  ) ;
            typedef void ( FernClassifier_wrapper::*default_clear_function_type )(  ) ;
            
            FernClassifier_exposer.def( 
                "clear"
                , clear_function_type(&::cv::FernClassifier::clear)
                , default_clear_function_type(&FernClassifier_wrapper::default_clear) );
        
        }
        { //::cv::FernClassifier::getClassCount
        
            typedef int ( ::cv::FernClassifier::*getClassCount_function_type )(  ) const;
            
            FernClassifier_exposer.def( 
                "getClassCount"
                , getClassCount_function_type( &::cv::FernClassifier::getClassCount ) );
        
        }
        { //::cv::FernClassifier::getCompressionMethod
        
            typedef int ( ::cv::FernClassifier::*getCompressionMethod_function_type )(  ) const;
            
            FernClassifier_exposer.def( 
                "getCompressionMethod"
                , getCompressionMethod_function_type( &::cv::FernClassifier::getCompressionMethod ) );
        
        }
        { //::cv::FernClassifier::getPatchSize
        
            typedef ::cv::Size ( ::cv::FernClassifier::*getPatchSize_function_type )(  ) const;
            
            FernClassifier_exposer.def( 
                "getPatchSize"
                , getPatchSize_function_type( &::cv::FernClassifier::getPatchSize ) );
        
        }
        { //::cv::FernClassifier::getSignatureSize
        
            typedef int ( ::cv::FernClassifier::*getSignatureSize_function_type )(  ) const;
            
            FernClassifier_exposer.def( 
                "getSignatureSize"
                , getSignatureSize_function_type( &::cv::FernClassifier::getSignatureSize ) );
        
        }
        { //::cv::FernClassifier::getStructCount
        
            typedef int ( ::cv::FernClassifier::*getStructCount_function_type )(  ) const;
            
            FernClassifier_exposer.def( 
                "getStructCount"
                , getStructCount_function_type( &::cv::FernClassifier::getStructCount ) );
        
        }
        { //::cv::FernClassifier::getStructSize
        
            typedef int ( ::cv::FernClassifier::*getStructSize_function_type )(  ) const;
            
            FernClassifier_exposer.def( 
                "getStructSize"
                , getStructSize_function_type( &::cv::FernClassifier::getStructSize ) );
        
        }
        { //::cv::FernClassifier::operator()
        
            typedef boost::python::tuple ( *default___call___function_type )( cv::FernClassifier const &,cv::Mat const &,::cv::Point2f );
            
            FernClassifier_exposer.def( 
                "__call__"
                , default___call___function_type( &FernClassifier_wrapper::default___call___c4d2198033cf380377bb6f32571c2657 )
                , ( bp::arg("inst"), bp::arg("img"), bp::arg("kpt") )
                , "\nWrapped function:"
    "\n    operator()"
    "\nArgument 'signature':"\
    "\n    C++ type: ::std::vector< float > &."\
    "\n    Python type: vector_float32."\
    "\n    Output argument: omitted from input and returned as output."\
    "\nReturns:"\
    "\n    ((int), signature)" );
        
        }
        { //::cv::FernClassifier::operator()
        
            typedef boost::python::tuple ( *default___call___function_type )( cv::FernClassifier const &,cv::Mat const & );
            
            FernClassifier_exposer.def( 
                "__call__"
                , default___call___function_type( &FernClassifier_wrapper::default___call___ddcd7402f4cc50fa35ce4888642630c7 )
                , ( bp::arg("inst"), bp::arg("patch") )
                , "\nWrapped function:"
    "\n    operator()"
    "\nArgument 'signature':"\
    "\n    C++ type: ::std::vector< float > &."\
    "\n    Python type: vector_float32."\
    "\n    Output argument: omitted from input and returned as output."\
    "\nReturns:"\
    "\n    ((int), signature)" );
        
        }
        { //::cv::FernClassifier::read
        
            typedef void ( ::cv::FernClassifier::*read_function_type )( ::cv::FileNode const & ) ;
            typedef void ( FernClassifier_wrapper::*default_read_function_type )( ::cv::FileNode const & ) ;
            
            FernClassifier_exposer.def( 
                "read"
                , read_function_type(&::cv::FernClassifier::read)
                , default_read_function_type(&FernClassifier_wrapper::default_read)
                , ( bp::arg("n") ) );
        
        }
        { //::cv::FernClassifier::setVerbose
        
            typedef void ( ::cv::FernClassifier::*setVerbose_function_type )( bool ) ;
            
            FernClassifier_exposer.def( 
                "setVerbose"
                , setVerbose_function_type( &::cv::FernClassifier::setVerbose )
                , ( bp::arg("verbose") ) );
        
        }
        { //::cv::FernClassifier::train
        
            typedef void ( ::cv::FernClassifier::*train_function_type )( ::std::vector< cv::Point_<float> > const &,::std::vector< cv::Ptr<cv::Mat> > const &,::std::vector< int > const &,int,int,int,int,int,int,int,::cv::PatchGenerator const & ) ;
            typedef void ( FernClassifier_wrapper::*default_train_function_type )( ::std::vector< cv::Point_<float> > const &,::std::vector< cv::Ptr<cv::Mat> > const &,::std::vector< int > const &,int,int,int,int,int,int,int,::cv::PatchGenerator const & ) ;
            
            FernClassifier_exposer.def( 
                "train"
                , train_function_type(&::cv::FernClassifier::train)
                , default_train_function_type(&FernClassifier_wrapper::default_train)
                , ( bp::arg("points"), bp::arg("refimgs"), bp::arg("labels")=std::vector<int>(), bp::arg("_nclasses")=(int)(0), bp::arg("_patchSize")=int(::cv::FernClassifier::PATCH_SIZE), bp::arg("_signatureSize")=int(::cv::FernClassifier::DEFAULT_SIGNATURE_SIZE), bp::arg("_nstructs")=int(::cv::FernClassifier::DEFAULT_STRUCTS), bp::arg("_structSize")=int(::cv::FernClassifier::DEFAULT_STRUCT_SIZE), bp::arg("_nviews")=int(::cv::FernClassifier::DEFAULT_VIEWS), bp::arg("_compressionMethod")=int(::cv::FernClassifier::COMPRESSION_NONE), bp::arg("patchGenerator")=cv::PatchGenerator() ) );
        
        }
        { //::cv::FernClassifier::trainFromSingleView
        
            typedef void ( ::cv::FernClassifier::*trainFromSingleView_function_type )( ::cv::Mat const &,::std::vector< cv::KeyPoint > const &,int,int,int,int,int,int,::cv::PatchGenerator const & ) ;
            typedef void ( FernClassifier_wrapper::*default_trainFromSingleView_function_type )( ::cv::Mat const &,::std::vector< cv::KeyPoint > const &,int,int,int,int,int,int,::cv::PatchGenerator const & ) ;
            
            FernClassifier_exposer.def( 
                "trainFromSingleView"
                , trainFromSingleView_function_type(&::cv::FernClassifier::trainFromSingleView)
                , default_trainFromSingleView_function_type(&FernClassifier_wrapper::default_trainFromSingleView)
                , ( bp::arg("image"), bp::arg("keypoints"), bp::arg("_patchSize")=int(::cv::FernClassifier::PATCH_SIZE), bp::arg("_signatureSize")=int(::cv::FernClassifier::DEFAULT_SIGNATURE_SIZE), bp::arg("_nstructs")=int(::cv::FernClassifier::DEFAULT_STRUCTS), bp::arg("_structSize")=int(::cv::FernClassifier::DEFAULT_STRUCT_SIZE), bp::arg("_nviews")=int(::cv::FernClassifier::DEFAULT_VIEWS), bp::arg("_compressionMethod")=int(::cv::FernClassifier::COMPRESSION_NONE), bp::arg("patchGenerator")=cv::PatchGenerator() ) );
        
        }
        { //::cv::FernClassifier::write
        
            typedef void ( ::cv::FernClassifier::*write_function_type )( ::cv::FileStorage &,::cv::String const & ) const;
            typedef void ( FernClassifier_wrapper::*default_write_function_type )( ::cv::FileStorage &,::cv::String const & ) const;
            
            FernClassifier_exposer.def( 
                "write"
                , write_function_type(&::cv::FernClassifier::write)
                , default_write_function_type(&FernClassifier_wrapper::default_write)
                , ( bp::arg("fs"), bp::arg("name")=std::string() ) );
        
        }
    }

}
