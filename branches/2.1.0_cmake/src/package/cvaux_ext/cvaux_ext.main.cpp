// This file has been generated by Py++.

#include "boost/python.hpp"

#include "__call_policies.pypp.hpp"

#include "__convenience.pypp.hpp"

#include "opencv_converters.hpp"

#include "__array_1.pypp.hpp"

#include "ndarray.hpp"

#include "boost/python/suite/indexing/vector_indexing_suite.hpp"

#include "__ctypes_integration.pypp.hpp"

#include "with_ownershiplevel_postcall.hpp"

#include "cvaux_wrapper.hpp"

#include "cvaux_ext/cvaux_ext_classes_1.pypp.hpp"

#include "cvaux_ext/cvaux_ext_classes_2.pypp.hpp"

#include "cvaux_ext/cvaux_ext_classes_3.pypp.hpp"

#include "cvaux_ext/cvaux_ext_classes_4.pypp.hpp"

#include "cvaux_ext/cvaux_ext_enumerations.pypp.hpp"

#include "cvaux_ext/cvaux_ext_free_functions.pypp.hpp"

namespace bp = boost::python;

static boost::python::object FAST_23d17220884e2f371691b185394322ec( ::cv::Mat const & image, int threshold, bool nonmax_supression=true ){
    std::vector<cv::KeyPoint> keypoints2;
    ::cv::FAST(image, keypoints2, threshold, nonmax_supression);
    return bp::object( keypoints2 );
}

static boost::python::object cvCalcImageHomography_a814cf819bbf03a0c8d0b4fd1b700335( boost::python::object line, ::CvPoint3D32f * center, boost::python::object intrinsic ){
    float native_line[3];
    float native_intrinsic[9];
    float native_homography[9];
    boost::python::list py_homography;
    pyplus_conv::ensure_uniform_sequence< float >( line, 3 );
    pyplus_conv::copy_sequence( line, pyplus_conv::array_inserter( native_line, 3 ) );
    pyplus_conv::ensure_uniform_sequence< float >( intrinsic, 9 );
    pyplus_conv::copy_sequence( intrinsic, pyplus_conv::array_inserter( native_intrinsic, 9 ) );
    ::cvCalcImageHomography(native_line, center, native_intrinsic, native_homography);
    pyplus_conv::copy_container( native_homography, native_homography + 9, pyplus_conv::list_inserter( py_homography ) );
    return bp::object( py_homography );
}

static void cvConDensInitSampleSet_2b2c9d04e9f57fb36a248c795590341d( ::CvConDensation * condens, ::cv::Mat & lower_bound, ::cv::Mat & upper_bound ){
    ::cvConDensInitSampleSet(condens, get_CvMat_ptr(lower_bound), get_CvMat_ptr(upper_bound));
}

static boost::python::object cvFindDominantPoints_919f8d7f6be0d997aa8fe46c4a3bc34b( ::CvSeq * contour, ::cv::MemStorage & storage, int method=1, double parameter1=0, double parameter2=0, double parameter3=0, double parameter4=0 ){
    ::CvSeq * result = ::cvFindDominantPoints(contour, (CvMemStorage *)storage, method, parameter1, parameter2, parameter3, parameter4);
    typedef bp::with_custodian_and_ward_postcall< 0, 2, bp::return_value_policy< bp::reference_existing_object > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvSeq * >( result ) );
}

static void cvFindStereoCorrespondence_7b07c127d562a5149232dd8cc1bc470d( ::cv::Mat & leftImage, ::cv::Mat & rightImage, int mode, ::cv::Mat & dispImage, int maxDisparity, double param1=12345, double param2=12345, double param3=12345, double param4=12345, double param5=12345 ){
    ::cvFindStereoCorrespondence(get_CvMat_ptr(leftImage), get_CvMat_ptr(rightImage), mode, get_CvMat_ptr(dispImage), maxDisparity, param1, param2, param3, param4, param5);
}

static void cvReleaseBlobDetector_6236e43a6c59f60e3b3bdb05e8a157ca( ::CvBlobDetector & ppBD ){
    CvBlobDetector * ppBD2=(::CvBlobDetector *)&ppBD;
    ::cvReleaseBlobDetector((::CvBlobDetector * *)&ppBD2);
}

static void cvReleaseConDensation_f998e5f5422410bd74b2ba960fd05e2c( ::CvConDensation & condens ){
    CvConDensation * condens2=(::CvConDensation *)&condens;
    ::cvReleaseConDensation((::CvConDensation * *)&condens2);
}

static boost::python::object cvSegmentImage_7b95313fd97ffe28d678124b5aa0a301( ::cv::Mat & srcarr, ::cv::Mat & dstarr, double canny_threshold, double ffill_threshold, ::cv::MemStorage & storage ){
    ::CvSeq * result = ::cvSegmentImage(get_CvMat_ptr(srcarr), get_CvMat_ptr(dstarr), canny_threshold, ffill_threshold, (CvMemStorage *)storage);
    typedef bp::with_custodian_and_ward_postcall< 0, 5, bp::return_value_policy< bp::reference_existing_object > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvSeq * >( result ) );
}

BOOST_PYTHON_MODULE(cvaux_ext){
    register_enumerations();

    { //::cv::FAST
    
        typedef boost::python::object ( *FAST_function_type )( cv::Mat const &,int,bool );
        
        bp::def( 
            "FAST"
            , FAST_function_type( &FAST_23d17220884e2f371691b185394322ec )
            , ( bp::arg("image"), bp::arg("threshold"), bp::arg("nonmax_supression")=(bool)(true) )
            , "\nArgument 'keypoints':"\
    "\n    C++ type: ::std::vector< cv::KeyPoint > &."\
    "\n    Python type: vector_KeyPoint."\
    "\n    Output argument: omitted from input and returned as output."\
    "\nReturns:"\
    "\n    keypoints" );
    
    }

    { //::cvCalcImageHomography
    
        typedef boost::python::object ( *calcImageHomography_function_type )( boost::python::object,::CvPoint3D32f *,boost::python::object );
        
        bp::def( 
            "calcImageHomography"
            , calcImageHomography_function_type( &cvCalcImageHomography_a814cf819bbf03a0c8d0b4fd1b700335 )
            , ( bp::arg("line"), bp::arg("center"), bp::arg("intrinsic") )
            , "\nWrapped function:"
    "\n    cvCalcImageHomography" );
    
    }

    { //::cvConDensInitSampleSet
    
        typedef void ( *conDensInitSampleSet_function_type )( ::CvConDensation *,::cv::Mat &,::cv::Mat & );
        
        bp::def( 
            "conDensInitSampleSet"
            , conDensInitSampleSet_function_type( &cvConDensInitSampleSet_2b2c9d04e9f57fb36a248c795590341d )
            , ( bp::arg("condens"), bp::arg("lower_bound"), bp::arg("upper_bound") )
            , "\nWrapped function:"
    "\n    cvConDensInitSampleSet"
    "\nArgument 'lower_bound':"\
    "\n    C++ type: ::CvMat *."\
    "\n    Python type: Mat."\
    "\nArgument 'upper_bound':"\
    "\n    C++ type: ::CvMat *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvFindDominantPoints
    
        typedef boost::python::object ( *findDominantPoints_function_type )( ::CvSeq *,::cv::MemStorage &,int,double,double,double,double );
        
        bp::def( 
            "findDominantPoints"
            , findDominantPoints_function_type( &cvFindDominantPoints_919f8d7f6be0d997aa8fe46c4a3bc34b )
            , ( bp::arg("contour"), bp::arg("storage"), bp::arg("method")=(int)(1), bp::arg("parameter1")=0, bp::arg("parameter2")=0, bp::arg("parameter3")=0, bp::arg("parameter4")=0 )
            , "\nWrapped function:"
    "\n    cvFindDominantPoints"
    "\nArgument 'storage':"\
    "\n    C++ type: ::CvMemStorage *."\
    "\n    Python type: MemStorage." );
    
    }

    { //::cvFindStereoCorrespondence
    
        typedef void ( *findStereoCorrespondence_function_type )( ::cv::Mat &,::cv::Mat &,int,::cv::Mat &,int,double,double,double,double,double );
        
        bp::def( 
            "findStereoCorrespondence"
            , findStereoCorrespondence_function_type( &cvFindStereoCorrespondence_7b07c127d562a5149232dd8cc1bc470d )
            , ( bp::arg("leftImage"), bp::arg("rightImage"), bp::arg("mode"), bp::arg("dispImage"), bp::arg("maxDisparity"), bp::arg("param1")=12345, bp::arg("param2")=12345, bp::arg("param3")=12345, bp::arg("param4")=12345, bp::arg("param5")=12345 )
            , "\nWrapped function:"
    "\n    cvFindStereoCorrespondence"
    "\nArgument 'leftImage':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'rightImage':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'dispImage':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvReleaseBlobDetector
    
        typedef void ( *_cvReleaseBlobDetector_function_type )( CvBlobDetector & );
        
        bp::def( 
            "_cvReleaseBlobDetector"
            , _cvReleaseBlobDetector_function_type( &cvReleaseBlobDetector_6236e43a6c59f60e3b3bdb05e8a157ca )
            , ( bp::arg("ppBD") )
            , "\nWrapped function:"
    "\n    cvReleaseBlobDetector"
    "\nArgument 'ppBD':"\
    "\n    C++ type: ::CvBlobDetector * *."\
    "\n    Python type: CvBlobDetector." );
    
    }

    { //::cvReleaseConDensation
    
        typedef void ( *_cvReleaseConDensation_function_type )( CvConDensation & );
        
        bp::def( 
            "_cvReleaseConDensation"
            , _cvReleaseConDensation_function_type( &cvReleaseConDensation_f998e5f5422410bd74b2ba960fd05e2c )
            , ( bp::arg("condens") )
            , "\nWrapped function:"
    "\n    cvReleaseConDensation"
    "\nArgument 'condens':"\
    "\n    C++ type: ::CvConDensation * *."\
    "\n    Python type: CvConDensation." );
    
    }

    { //::cvSegmentImage
    
        typedef boost::python::object ( *segmentImage_function_type )( ::cv::Mat &,::cv::Mat &,double,double,::cv::MemStorage & );
        
        bp::def( 
            "segmentImage"
            , segmentImage_function_type( &cvSegmentImage_7b95313fd97ffe28d678124b5aa0a301 )
            , ( bp::arg("srcarr"), bp::arg("dstarr"), bp::arg("canny_threshold"), bp::arg("ffill_threshold"), bp::arg("storage") )
            , "\nWrapped function:"
    "\n    cvSegmentImage"
    "\nArgument 'srcarr':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'dstarr':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'storage':"\
    "\n    C++ type: ::CvMemStorage *."\
    "\n    Python type: MemStorage." );
    
    }

    register_classes_1();

    register_classes_2();

    register_classes_3();

    register_classes_4();

    register_free_functions();
}

