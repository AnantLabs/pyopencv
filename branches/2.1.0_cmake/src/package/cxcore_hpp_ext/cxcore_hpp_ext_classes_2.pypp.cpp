// This file has been generated by Py++.

#include "boost/python.hpp"
#include "opencv_converters.hpp"
#include "__call_policies.pypp.hpp"
#include "__convenience.pypp.hpp"
#include "ndarray.hpp"
#include "__ctypes_integration.pypp.hpp"
#include "cxcore_hpp_wrapper.hpp"
#include "boost/python/object/life_support.hpp"
#include "arrayobject.h"
#include "ndarray.hpp"
#include "cxcore_hpp_ext_classes_2.pypp.hpp"

namespace bp = boost::python;

struct FileStorage_wrapper : cv::FileStorage, bp::wrapper< cv::FileStorage > {

    FileStorage_wrapper(cv::FileStorage const & arg )
    : cv::FileStorage( arg )
      , bp::wrapper< cv::FileStorage >(){
        // copy constructor
        
    }

    FileStorage_wrapper( )
    : cv::FileStorage( )
      , bp::wrapper< cv::FileStorage >(){
        // null constructor
    
    }

    FileStorage_wrapper(::std::string const & filename, int flags )
    : cv::FileStorage( boost::ref(filename), flags )
      , bp::wrapper< cv::FileStorage >(){
        // constructor
    
    }

    virtual bool isOpened(  ) const  {
        if( bp::override func_isOpened = this->get_override( "isOpened" ) )
            return func_isOpened(  );
        else{
            return this->cv::FileStorage::isOpened(  );
        }
    }
    
    bool default_isOpened(  ) const  {
        return cv::FileStorage::isOpened( );
    }

    virtual bool open( ::std::string const & filename, int flags ) {
        if( bp::override func_open = this->get_override( "open" ) )
            return func_open( boost::ref(filename), flags );
        else{
            return this->cv::FileStorage::open( boost::ref(filename), flags );
        }
    }
    
    bool default_open( ::std::string const & filename, int flags ) {
        return cv::FileStorage::open( boost::ref(filename), flags );
    }

    virtual void release(  ) {
        if( bp::override func_release = this->get_override( "release" ) )
            func_release(  );
        else{
            this->cv::FileStorage::release(  );
        }
    }
    
    void default_release(  ) {
        cv::FileStorage::release( );
    }

    static void writeRaw( ::cv::FileStorage & inst, ::std::string const & fmt, std::vector<unsigned char> const & vec ){
        inst.writeRaw(fmt, (::uchar const *)(&vec[0]), (int)(vec.size()));
    }

};

static boost::python::tuple findNearest_ea97c6aa84c5363d34b3e91951773ead( ::cv::KDTree const & inst, std::vector<float> const & vec, int K, int Emax ){
    std::vector<int> neighborsIdx2;
    cv::Mat neighbors2;
    std::vector<float> dist2;
    int result = inst.findNearest((float const *)(&vec[0]), K, Emax, &neighborsIdx2, &neighbors2, &dist2);
    return bp::make_tuple( result, neighborsIdx2, neighbors2, dist2 );
}

static boost::python::tuple findOrthoRange_8f5141c7ea87ab587a033ff4e81c09d9( ::cv::KDTree const & inst, std::vector<float> const & minBounds, std::vector<float> const & maxBounds ){
    std::vector<int> neighborsIdx2;
    cv::Mat neighbors2;
    inst.findOrthoRange((float const *)(&minBounds[0]), (float const *)(&maxBounds[0]), &neighborsIdx2, &neighbors2);
    return bp::make_tuple( neighborsIdx2, neighbors2 );
}

static boost::python::object getPoints_cb19ade779f56a2e3d487759ce0fd7ea( ::cv::KDTree const & inst, std::vector<int> const & idx ){
    cv::Mat pts2;
    inst.getPoints((int const *)(&idx[0]), (int)(idx.size()), pts2);
    return bp::object( pts2 );
}

static boost::python::object getPoints_dfa4c20a74f0aaa501985d64a11da238( ::cv::KDTree const & inst, ::cv::Mat const & idxs ){
    cv::Mat pts2;
    inst.getPoints(idxs, pts2);
    return bp::object( pts2 );
}

inline int cv::KDTree::dims() const { return points.cols; }

sdcpp::ndarray KDTree_getPoint(bp::object const &bpinst, int i) {
    cv::KDTree const &inst = bp::extract<cv::KDTree const &>(bpinst);
    sdcpp::ndarray result = sdcpp::new_ndarray1d(inst.points.cols, NPY_FLOAT, 
        (void *)inst.getPoint(i));
    bp::objects::make_nurse_and_patient(result.get_obj().ptr(), bpinst.ptr());
    return result;
}

struct LineIterator_wrapper : cv::LineIterator, bp::wrapper< cv::LineIterator > {

    LineIterator_wrapper(cv::LineIterator const & arg )
    : cv::LineIterator( arg )
      , bp::wrapper< cv::LineIterator >(){
        // copy constructor
        
    }

    private:
    int iteration;
    int ws, es;
    uchar *ptr0;

public:
    LineIterator_wrapper(const cv::Mat& img, cv::Point const &pt1, cv::Point const &pt2,
        int connectivity=8, bool leftToRight=false)
        : cv::LineIterator(img, pt1, pt2, connectivity, leftToRight),
        iteration(0), ptr0(img.data), ws(img.step), es(img.elemSize()) {}
        
    LineIterator_wrapper const &iter() { return *this; }
    
    cv::Point next()
    {
        int ofs = (int)(ptr-ptr0);
        
        if(iteration < count)
        {
            ++(*this);
            ++iteration;
        }
        else
        {
            PyErr_SetString(PyExc_StopIteration, "No more pixel.");
            throw bp::error_already_set(); 
        }
        
        return cv::Point((ofs%ws)/es, ofs/ws);
    }

};

struct NAryMatNDIterator_wrapper : cv::NAryMatNDIterator, bp::wrapper< cv::NAryMatNDIterator > {

    NAryMatNDIterator_wrapper(cv::NAryMatNDIterator const & arg )
    : cv::NAryMatNDIterator( arg )
      , bp::wrapper< cv::NAryMatNDIterator >(){
        // copy constructor
        
    }

    NAryMatNDIterator_wrapper(::cv::MatND const & m1 )
    : cv::NAryMatNDIterator( boost::ref(m1) )
      , bp::wrapper< cv::NAryMatNDIterator >(){
        // constructor
    
    }

    NAryMatNDIterator_wrapper(::cv::MatND const & m1, ::cv::MatND const & m2 )
    : cv::NAryMatNDIterator( boost::ref(m1), boost::ref(m2) )
      , bp::wrapper< cv::NAryMatNDIterator >(){
        // constructor
    
    }

    NAryMatNDIterator_wrapper(::cv::MatND const & m1, ::cv::MatND const & m2, ::cv::MatND const & m3 )
    : cv::NAryMatNDIterator( boost::ref(m1), boost::ref(m2), boost::ref(m3) )
      , bp::wrapper< cv::NAryMatNDIterator >(){
        // constructor
    
    }

    NAryMatNDIterator_wrapper(::cv::MatND const & m1, ::cv::MatND const & m2, ::cv::MatND const & m3, ::cv::MatND const & m4 )
    : cv::NAryMatNDIterator( boost::ref(m1), boost::ref(m2), boost::ref(m3), boost::ref(m4) )
      , bp::wrapper< cv::NAryMatNDIterator >(){
        // constructor
    
    }

    NAryMatNDIterator_wrapper(::cv::MatND const & m1, ::cv::MatND const & m2, ::cv::MatND const & m3, ::cv::MatND const & m4, ::cv::MatND const & m5 )
    : cv::NAryMatNDIterator( boost::ref(m1), boost::ref(m2), boost::ref(m3), boost::ref(m4), boost::ref(m5) )
      , bp::wrapper< cv::NAryMatNDIterator >(){
        // constructor
    
    }

    NAryMatNDIterator_wrapper(::cv::MatND const & m1, ::cv::MatND const & m2, ::cv::MatND const & m3, ::cv::MatND const & m4, ::cv::MatND const & m5, ::cv::MatND const & m6 )
    : cv::NAryMatNDIterator( boost::ref(m1), boost::ref(m2), boost::ref(m3), boost::ref(m4), boost::ref(m5), boost::ref(m6) )
      , bp::wrapper< cv::NAryMatNDIterator >(){
        // constructor
    
    }

    NAryMatNDIterator_wrapper( )
    : cv::NAryMatNDIterator( )
      , bp::wrapper< cv::NAryMatNDIterator >(){
        // null constructor
    
    }

    static void init( ::cv::NAryMatNDIterator & inst, std::vector<cv::MatND> const & arrays ){
        
    std::vector<cv::MatND const *> buf_arrays(arrays.size());
    for(size_t i_arrays = 0; i_arrays<arrays.size(); ++i_arrays)
        buf_arrays[i_arrays] = (cv::MatND const *)&(arrays[i_arrays]);
        
        inst.init((cv::MatND const * *)(&buf_arrays[0]), arrays.size());
    }

    NAryMatNDIterator_wrapper const &iter() { return *this; }
    
    bp::object next()
    {
        if(idx >= nplanes)
        {
            PyErr_SetString(PyExc_StopIteration, "No more plane.");
            throw bp::error_already_set(); 
        }
        bp::object result(planes);
        if(idx >= nplanes-1) ++idx;
        else ++(*this);
        return result;
    }

};

static boost::shared_ptr<cv::NAryMatNDIterator> NAryMatNDIterator__init1__(std::vector<cv::MatND> const &arrays)
{
    std::vector<cv::MatND const *> buf_arrays(arrays.size());
    for(size_t i_arrays = 0; i_arrays<arrays.size(); ++i_arrays)
        buf_arrays[i_arrays] = (cv::MatND const *)&(arrays[i_arrays]);
        
    return boost::shared_ptr<cv::NAryMatNDIterator>(new cv::NAryMatNDIterator((cv::MatND const * *)(&buf_arrays[0]), arrays.size()));
}

void register_classes_2(){

    { //::cv::FileStorage
        typedef bp::class_< FileStorage_wrapper > FileStorage_exposer_t;
        FileStorage_exposer_t FileStorage_exposer = FileStorage_exposer_t( "FileStorage", "\nThe XML/YAML file storage class."
    "\n"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/xml_yaml_persistence.html#filestorage", bp::init< >("\nConstructor."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/xml_yaml_persistence.html#filestorage") );
        bp::scope FileStorage_scope( FileStorage_exposer );
        FileStorage_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::FileStorage >(), "\nThe XML/YAML file storage class."
    "\n"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/xml_yaml_persistence.html#filestorage" );
        bp::scope().attr("READ") = (int)cv::FileStorage::READ;
        bp::scope().attr("WRITE") = (int)cv::FileStorage::WRITE;
        bp::scope().attr("APPEND") = (int)cv::FileStorage::APPEND;
        bp::scope().attr("UNDEFINED") = (int)cv::FileStorage::UNDEFINED;
        bp::scope().attr("VALUE_EXPECTED") = (int)cv::FileStorage::VALUE_EXPECTED;
        bp::scope().attr("NAME_EXPECTED") = (int)cv::FileStorage::NAME_EXPECTED;
        bp::scope().attr("INSIDE_MAP") = (int)cv::FileStorage::INSIDE_MAP;
        FileStorage_exposer.def( bp::init< std::string const &, int >(( bp::arg("filename"), bp::arg("flags") ), "\nConstructor."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/xml_yaml_persistence.html#filestorage") );
        { //::cv::FileStorage::getDefaultObjectName
        
            typedef ::std::string ( *getDefaultObjectName_function_type )( ::std::string const & );
            
            FileStorage_exposer.def( 
                "getDefaultObjectName"
                , getDefaultObjectName_function_type( &::cv::FileStorage::getDefaultObjectName )
                , ( bp::arg("filename") )
                , "\nReturns the default object name from the filename (used by cvSave() "
    "\nwith the default object name etc.)."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/xml_yaml_persistence.html#filestorage" );
        
        }
        { //::cv::FileStorage::getFirstTopLevelNode
        
            typedef ::cv::FileNode ( ::cv::FileStorage::*getFirstTopLevelNode_function_type )(  ) const;
            
            FileStorage_exposer.def( 
                "getFirstTopLevelNode"
                , getFirstTopLevelNode_function_type( &::cv::FileStorage::getFirstTopLevelNode )
                , "\nReturns the first top-level node."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/xml_yaml_persistence.html#filestorage" );
        
        }
        { //::cv::FileStorage::isOpened
        
            typedef bool ( ::cv::FileStorage::*isOpened_function_type )(  ) const;
            typedef bool ( FileStorage_wrapper::*default_isOpened_function_type )(  ) const;
            
            FileStorage_exposer.def( 
                "isOpened"
                , isOpened_function_type(&::cv::FileStorage::isOpened)
                , default_isOpened_function_type(&FileStorage_wrapper::default_isOpened) );
        
        }
        { //::cv::FileStorage::open
        
            typedef bool ( ::cv::FileStorage::*open_function_type )( ::std::string const &,int ) ;
            typedef bool ( FileStorage_wrapper::*default_open_function_type )( ::std::string const &,int ) ;
            
            FileStorage_exposer.def( 
                "open"
                , open_function_type(&::cv::FileStorage::open)
                , default_open_function_type(&FileStorage_wrapper::default_open)
                , ( bp::arg("filename"), bp::arg("flags") ) );
        
        }
        { //::cv::FileStorage::operator[]
        
            typedef ::cv::FileNode ( ::cv::FileStorage::*__getitem___function_type )( ::std::string const & ) const;
            
            FileStorage_exposer.def( 
                "__getitem__"
                , __getitem___function_type( &::cv::FileStorage::operator[] )
                , ( bp::arg("nodename") )
                , "\nReturns the top-level node by name."
    "\nWrapped function:"
    "\n    operator[]"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/xml_yaml_persistence.html#filestorage" );
        
        }
        { //::cv::FileStorage::release
        
            typedef void ( ::cv::FileStorage::*release_function_type )(  ) ;
            typedef void ( FileStorage_wrapper::*default_release_function_type )(  ) ;
            
            FileStorage_exposer.def( 
                "release"
                , release_function_type(&::cv::FileStorage::release)
                , default_release_function_type(&FileStorage_wrapper::default_release) );
        
        }
        { //::cv::FileStorage::root
        
            typedef ::cv::FileNode ( ::cv::FileStorage::*root_function_type )( int ) const;
            
            FileStorage_exposer.def( 
                "root"
                , root_function_type( &::cv::FileStorage::root )
                , ( bp::arg("streamidx")=(int)(0) )
                , "\nReturns the root file node (it's the parent of the first top-level "
    "\nnode)."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/xml_yaml_persistence.html#filestorage" );
        
        }
        { //::cv::FileStorage::writeRaw
        
            typedef void ( *writeRaw_function_type )( cv::FileStorage &,::std::string const &,std::vector<unsigned char> const & );
            
            FileStorage_exposer.def( 
                "writeRaw"
                , writeRaw_function_type( &FileStorage_wrapper::writeRaw )
                , ( bp::arg("inst"), bp::arg("fmt"), bp::arg("vec") )
                , "\nWrites the certain number of elements of the specified format."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/xml_yaml_persistence.html#filestorage"
    "\nArgument 'vec':"\
    "\n    C++ type: ::uchar const *."\
    "\n    Python type: (C++)std::vector<unsigned char>."\
    "\nArgument 'len':"\
    "\n    Dependent argument: omitted from input. Its value is derived from "\
    "\n    argument 'vec'." );
        
        }
        FileStorage_exposer.def_readwrite( "elname", &cv::FileStorage::elname );
        FileStorage_exposer.def_readwrite( "state", &cv::FileStorage::state );
        FileStorage_exposer.staticmethod( "getDefaultObjectName" );
    }

    { //::cv::KDTree
        typedef bp::class_< cv::KDTree > KDTree_exposer_t;
        KDTree_exposer_t KDTree_exposer = KDTree_exposer_t( "KDTree", bp::init< >() );
        bp::scope KDTree_scope( KDTree_exposer );
        KDTree_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::KDTree >() );
        bp::class_< cv::KDTree::Node >( "Node", bp::init< >() )    
            .add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::KDTree::Node >() )    
            .def( bp::init< int, int, int, float >(( bp::arg("_idx"), bp::arg("_left"), bp::arg("_right"), bp::arg("_boundary") )) )    
            .def_readwrite( "boundary", &cv::KDTree::Node::boundary )    
            .def_readwrite( "idx", &cv::KDTree::Node::idx )    
            .def_readwrite( "left", &cv::KDTree::Node::left )    
            .def_readwrite( "right", &cv::KDTree::Node::right );
        KDTree_exposer.def( bp::init< cv::Mat const &, bp::optional< bool > >(( bp::arg("_points"), bp::arg("copyAndReorderPoints")=(bool)(false) )) );
        bp::implicitly_convertible< cv::Mat const &, cv::KDTree >();
        { //::cv::KDTree::build
        
            typedef void ( ::cv::KDTree::*build_function_type )( ::cv::Mat const &,bool ) ;
            
            KDTree_exposer.def( 
                "build"
                , build_function_type( &::cv::KDTree::build )
                , ( bp::arg("_points"), bp::arg("copyAndReorderPoints")=(bool)(false) ) );
        
        }
        { //::cv::KDTree::dims
        
            typedef int ( ::cv::KDTree::*dims_function_type )(  ) const;
            
            KDTree_exposer.def( 
                "dims"
                , dims_function_type( &::cv::KDTree::dims ) );
        
        }
        { //::cv::KDTree::findNearest
        
            typedef boost::python::tuple ( *findNearest_function_type )( cv::KDTree const &,std::vector<float> const &,int,int );
            
            KDTree_exposer.def( 
                "findNearest"
                , findNearest_function_type( &findNearest_ea97c6aa84c5363d34b3e91951773ead )
                , ( bp::arg("inst"), bp::arg("vec"), bp::arg("K"), bp::arg("Emax") )
                , "\nArgument 'vec':"\
    "\n    C++ type: float const *."\
    "\n    Python type: (C++)std::vector<float>."\
    "\nArgument 'neighborsIdx':"\
    "\n    C++ type: ::std::vector< int > *."\
    "\n    Python type: (C++)std::vector<int>."\
    "\n    Output argument: omitted from input and returned as output."\
    "\nArgument 'neighbors':"\
    "\n    C++ type: ::cv::Mat *."\
    "\n    Python type: Mat."\
    "\n    Output argument: omitted from input and returned as output."\
    "\nArgument 'dist':"\
    "\n    C++ type: ::std::vector< float > *."\
    "\n    Python type: (C++)std::vector<float>."\
    "\n    Output argument: omitted from input and returned as output."\
    "\nReturns:"\
    "\n    ((int), neighborsIdx, neighbors, dist)" );
        
        }
        { //::cv::KDTree::findOrthoRange
        
            typedef boost::python::tuple ( *findOrthoRange_function_type )( cv::KDTree const &,std::vector<float> const &,std::vector<float> const & );
            
            KDTree_exposer.def( 
                "findOrthoRange"
                , findOrthoRange_function_type( &findOrthoRange_8f5141c7ea87ab587a033ff4e81c09d9 )
                , ( bp::arg("inst"), bp::arg("minBounds"), bp::arg("maxBounds") )
                , "\nArgument 'minBounds':"\
    "\n    C++ type: float const *."\
    "\n    Python type: (C++)std::vector<float>."\
    "\nArgument 'maxBounds':"\
    "\n    C++ type: float const *."\
    "\n    Python type: (C++)std::vector<float>."\
    "\nArgument 'neighborsIdx':"\
    "\n    C++ type: ::std::vector< int > *."\
    "\n    Python type: (C++)std::vector<int>."\
    "\n    Output argument: omitted from input and returned as output."\
    "\nArgument 'neighbors':"\
    "\n    C++ type: ::cv::Mat *."\
    "\n    Python type: Mat."\
    "\n    Output argument: omitted from input and returned as output."\
    "\nReturns:"\
    "\n    (neighborsIdx, neighbors)" );
        
        }
        { //::cv::KDTree::getPoints
        
            typedef boost::python::object ( *getPoints_function_type )( cv::KDTree const &,std::vector<int> const & );
            
            KDTree_exposer.def( 
                "getPoints"
                , getPoints_function_type( &getPoints_cb19ade779f56a2e3d487759ce0fd7ea )
                , ( bp::arg("inst"), bp::arg("idx") )
                , "\nArgument 'idx':"\
    "\n    C++ type: int const *."\
    "\n    Python type: (C++)std::vector<int>."\
    "\nArgument 'nidx':"\
    "\n    Dependent argument: omitted from input. Its value is derived from "\
    "\n    argument 'idx'."\
    "\nArgument 'pts':"\
    "\n    C++ type: ::cv::Mat &."\
    "\n    Python type: Mat."\
    "\n    Output argument: omitted from input and returned as output."\
    "\nReturns:"\
    "\n    pts" );
        
        }
        { //::cv::KDTree::getPoints
        
            typedef boost::python::object ( *getPoints_function_type )( cv::KDTree const &,cv::Mat const & );
            
            KDTree_exposer.def( 
                "getPoints"
                , getPoints_function_type( &getPoints_dfa4c20a74f0aaa501985d64a11da238 )
                , ( bp::arg("inst"), bp::arg("idxs") )
                , "\nArgument 'pts':"\
    "\n    C++ type: ::cv::Mat &."\
    "\n    Python type: Mat."\
    "\n    Output argument: omitted from input and returned as output."\
    "\nReturns:"\
    "\n    pts" );
        
        }
        KDTree_exposer.def_readwrite( "maxDepth", &cv::KDTree::maxDepth );
        KDTree_exposer.def_readwrite( "nodes", &cv::KDTree::nodes );
        KDTree_exposer.def_readwrite( "normType", &cv::KDTree::normType );
        KDTree_exposer.def_readwrite( "points", &cv::KDTree::points );
        KDTree_exposer.def( "getPoint", &KDTree_getPoint, (bp::arg("ptidx")) );
    }

    bp::class_< LineIterator_wrapper >( "LineIterator", bp::no_init )    
        .add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::LineIterator >() )    
        .def_readwrite( "count", &cv::LineIterator::count )    
        .def_readwrite( "err", &cv::LineIterator::err )    
        .def_readwrite( "minusDelta", &cv::LineIterator::minusDelta )    
        .def_readwrite( "minusStep", &cv::LineIterator::minusStep )    
        .def_readwrite( "plusDelta", &cv::LineIterator::plusDelta )    
        .def_readwrite( "plusStep", &cv::LineIterator::plusStep )    
        .def(bp::init<cv::Mat const &, cv::Point const &, cv::Point const &, int, bool>(( bp::arg("img"), bp::arg("pt1"), bp::arg("pt2"), bp::arg("connectivity")=8, bp::arg("leftToRight")=false)))    
        .def("__iter__", &::LineIterator_wrapper::iter, bp::return_self<>())    
        .def("next", &::LineIterator_wrapper::next);

    { //::cv::NAryMatNDIterator
        typedef bp::class_< NAryMatNDIterator_wrapper > NAryMatNDIterator_exposer_t;
        NAryMatNDIterator_exposer_t NAryMatNDIterator_exposer = NAryMatNDIterator_exposer_t( "NAryMatNDIterator", bp::init< cv::MatND const & >(( bp::arg("m1") )) );
        bp::scope NAryMatNDIterator_scope( NAryMatNDIterator_exposer );
        NAryMatNDIterator_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::NAryMatNDIterator >() );
        bp::implicitly_convertible< cv::MatND const &, cv::NAryMatNDIterator >();
        NAryMatNDIterator_exposer.def( bp::init< cv::MatND const &, cv::MatND const & >(( bp::arg("m1"), bp::arg("m2") )) );
        NAryMatNDIterator_exposer.def( bp::init< cv::MatND const &, cv::MatND const &, cv::MatND const & >(( bp::arg("m1"), bp::arg("m2"), bp::arg("m3") )) );
        NAryMatNDIterator_exposer.def( bp::init< cv::MatND const &, cv::MatND const &, cv::MatND const &, cv::MatND const & >(( bp::arg("m1"), bp::arg("m2"), bp::arg("m3"), bp::arg("m4") )) );
        NAryMatNDIterator_exposer.def( bp::init< cv::MatND const &, cv::MatND const &, cv::MatND const &, cv::MatND const &, cv::MatND const & >(( bp::arg("m1"), bp::arg("m2"), bp::arg("m3"), bp::arg("m4"), bp::arg("m5") )) );
        NAryMatNDIterator_exposer.def( bp::init< cv::MatND const &, cv::MatND const &, cv::MatND const &, cv::MatND const &, cv::MatND const &, cv::MatND const & >(( bp::arg("m1"), bp::arg("m2"), bp::arg("m3"), bp::arg("m4"), bp::arg("m5"), bp::arg("m6") )) );
        NAryMatNDIterator_exposer.def( bp::init< >() );
        { //::cv::NAryMatNDIterator::init
        
            typedef void ( *init_function_type )( cv::NAryMatNDIterator &,std::vector<cv::MatND> const & );
            
            NAryMatNDIterator_exposer.def( 
                "init"
                , init_function_type( &NAryMatNDIterator_wrapper::init )
                , ( bp::arg("inst"), bp::arg("arrays") )
                , "\nArgument 'arrays':"\
    "\n    C++ type: ::cv::MatND const * *."\
    "\n    Python type: (C++)std::vector<cv::MatND>."\
    "\nArgument 'count':"\
    "\n    Dependent argument: omitted from input. Its value is derived from "\
    "\n    argument 'arrays'." );
        
        }
        NAryMatNDIterator_exposer.def_readwrite( "arrays", &cv::NAryMatNDIterator::arrays );
        NAryMatNDIterator_exposer.def_readwrite( "nplanes", &cv::NAryMatNDIterator::nplanes );
        NAryMatNDIterator_exposer.def_readwrite( "planes", &cv::NAryMatNDIterator::planes );
        NAryMatNDIterator_exposer.def("__init__", bp::make_constructor(&NAryMatNDIterator__init1__, bp::default_call_policies(), (bp::arg("arrays"))));
        NAryMatNDIterator_exposer.def("__iter__", &NAryMatNDIterator_wrapper::iter, bp::return_self<>());
        NAryMatNDIterator_exposer.def("next", &NAryMatNDIterator_wrapper::next);
    }

    bp::class_< cv::PCA >( "PCA", "\nClass for Principal Component Analysis."
    "\n"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#pca", bp::init< >("\nPCA constructors."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-pca-pca") )    
        .add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::PCA >(), "\nClass for Principal Component Analysis."
    "\n"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#pca" )    
        .def( bp::init< cv::Mat const &, cv::Mat const &, int, bp::optional< int > >(( bp::arg("data"), bp::arg("mean"), bp::arg("flags"), bp::arg("maxComponents")=(int)(0) ), "\nPCA constructors."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-pca-pca") )    
        .def( 
            "backProject"
            , (::cv::Mat ( cv::PCA::* )( ::cv::Mat const & ) const)( &::cv::PCA::backProject )
            , ( bp::arg("vec") )
            , "\nReconstruct vectors from their PC projections."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-pca-backproject" )    
        .def( 
            "backProject"
            , (void ( cv::PCA::* )( ::cv::Mat const &,::cv::Mat & ) const)( &::cv::PCA::backProject )
            , ( bp::arg("vec"), bp::arg("result") )
            , "\nReconstruct vectors from their PC projections."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-pca-backproject" )    
        .def( 
            "__call__"
            , (::cv::PCA & ( cv::PCA::* )( ::cv::Mat const &,::cv::Mat const &,int,int ) )( &::cv::PCA::operator() )
            , ( bp::arg("data"), bp::arg("mean"), bp::arg("flags"), bp::arg("maxComponents")=(int)(0) )
            , bp::return_self< >()
            , "\nPerforms Principal Component Analysis of the supplied dataset."
    "\nWrapped function:"
    "\n    operator()"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-pca-operator" )    
        .def( 
            "project"
            , (::cv::Mat ( cv::PCA::* )( ::cv::Mat const & ) const)( &::cv::PCA::project )
            , ( bp::arg("vec") )
            , "\nProject vector(s) to the principal component subspace."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-pca-project" )    
        .def( 
            "project"
            , (void ( cv::PCA::* )( ::cv::Mat const &,::cv::Mat & ) const)( &::cv::PCA::project )
            , ( bp::arg("vec"), bp::arg("result") )
            , "\nProject vector(s) to the principal component subspace."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-pca-project" )    
        .def_readwrite( "eigenvalues", &cv::PCA::eigenvalues )    
        .def_readwrite( "eigenvectors", &cv::PCA::eigenvectors )    
        .def_readwrite( "mean", &cv::PCA::mean );

}
