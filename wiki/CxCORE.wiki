= Vector =

Instantiations of class cv::Vec<> included in PyOpenCV: Vec2b, Vec3b, Vec4b, Vec2s, Vec3s, Vec4s, Vec2w, Vec3w, Vec4w, Vec2i, Vec3i, Vec4i, Vec2f, Vec3f, Vec4f, Vec6f, Vec2d, Vec3d, Vec4d, Vec6d.

|| *OpenCV* || *PyOpenCV* ||
|| cv::Vec || Vec ||
|| cv::Vec::all || Vec.all ||
|| cv::Vec::dot || Vec.dot ||
|| cv::Vec::ddot || Vec.ddot ||
|| cvCrossProduct, cv::Vec::cross || Vec.cross ||
|| cv::Vec::operator CvScalar || Vec.as_CvScalar ||

= Complex =

Instantiations of class cv::Vec<> included in PyOpenCV: Complexf, Complexd.

|| *OpenCV* || *PyOpenCV* ||
|| cv::Complex || Complex ||
|| cv::Complex::conj || Complex.conj ||

= Point =

Instantiations of class cv::Point_<> included in PyOpenCV: Point, Point2i, Point2f.

|| *OpenCV* || *PyOpenCV* ||
|| cv::Point_ || Point ||
|| cv::Point::dot || Point.dot ||
|| cv::Point::ddot || Point.ddot ||
|| cv::Point::inside || Point.inside ||
|| cv::Point::operator CvPoint || Point.as_CvPoint ||
|| cv::Point::operator CvPoint2D32f || Point.as_CvPoint2D32f ||

---- 

|| *OpenCV* || *PyOpenCV* ||
|| cv::Scalar, cv::Vec-like || numpy.ndarray ||


= Image, Matrix, and Higher-order Array =

|| *OpenCV* || *PyOpenCV* ||
|| IplImage, CvMat, cv::Mat, CvMatND, cv::MatND || numpy.ndarray ||

==Multi-channel array==

OpenCV supports multi-channel arrays. When converting an ndarray into an OpenCV's array, PyOpenCV always tries to convert the ndarray into a multi-channel OpenCV array. This happens only when *2 <= the size of the last dimension <= 4* and *the ndarray is contiguous up to the second last dimension*. If you would like to explicitly avoid the ndarray to be converted into a multi-channel OpenCV array, simply add an extra dimension to your ndarray, e.g. by using reshape():
    arr.reshape(arr.shape+(1,))
where 'arr' is your ndarray.


= Free Functions =

|| *OpenCV* || *PyOpenCV* ||
|| cv::fromUtf16 || fromUtf16 ||
|| cv::toUtf16 || toUtf16 ||
|| cv::setNumThreads || setNumThreads ||
|| cv::getThreadNum || getThreadNum ||
|| cv::getTickCount || getTickCount ||
|| cv::getTickFrequency || getTickFrequency ||
|| cv::setUseOptimized || setUseOptimized ||
|| cv::useOptimized || useOptimized ||
|| cv::getElemSize || getElemSize ||
|| cv::add || add ||
|| cv::subtract || subtract ||
|| cv::multiply(a,b,c,scale) || c = scale*a*b ||
|| cv::divide(a,b,c,scale) || c = scale*a/b ||
|| cv::divide(scale,b,c) || c = scale/b ||
|| cv::scaleAdd(a,alpha,b,c) || c = a*alpha+b ||
|| cv::addWeighted(a,alpha,b,beta,gamma,c) || c = a*alpha+b*beta+gamma ||
|| cv::LUT || LUT ||
|| cv::sum || numpy.sum ||
|| cv::countNonZero || numpy.nonzero ||
|| cv::mean || mean ||
|| cv::meanStdDev || meanStdDev ||
|| cv::norm || norm ||
|| cv::normalize || normalize ||
|| cv::minMaxLoc || minMaxLoc ||
|| cv::reduce || reduce ||
|| cv::split(a) || use slices of a ||
|| cv::merge(a1,a2,...) || numpy.array((a1,a2,...)) ||
|| cv::mixChannels || similarly to 'split' and 'merge' ||
|| cv::repeat || repeat ||