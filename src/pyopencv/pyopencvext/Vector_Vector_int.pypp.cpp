// This file has been generated by Py++.

#include "boost/python.hpp"
#include "__ctypes_integration.pypp.hpp"
#include "opencv_headers.hpp"
#include "Vector_Vector_int.pypp.hpp"

namespace bp = boost::python;

static bp::list iter(::cv::SdVector< cv::SdVector< int > > const &inst)
{
    bp::list l;
    for(int i = 0; i < inst.size(); ++i) l.append(bp::object(inst[i]));
    return l;
}

void register_Vector_Vector_int_class(){

    { //::cv::SdVector< cv::SdVector< int > >
        typedef bp::class_< cv::SdVector< cv::SdVector< int > > > Vector_Vector_int_exposer_t;
        Vector_Vector_int_exposer_t Vector_Vector_int_exposer = Vector_Vector_int_exposer_t( "Vector_Vector_int", bp::init< >() );
        bp::scope Vector_Vector_int_scope( Vector_Vector_int_exposer );
        Vector_Vector_int_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::SdVector< cv::SdVector< int > > >() );
        Vector_Vector_int_exposer.def( bp::init< size_t >(( bp::arg("_size") )) );
        bp::implicitly_convertible< size_t, cv::SdVector< cv::SdVector< int > > >();
        Vector_Vector_int_exposer.def( bp::init< size_t, cv::SdVector< int > const & >(( bp::arg("_size"), bp::arg("val") )) );
        Vector_Vector_int_exposer.def( bp::init< cv::SdVector< cv::SdVector< int > > const & >(( bp::arg("d") )) );
        Vector_Vector_int_exposer.def( bp::init< cv::SdVector< cv::SdVector< int > > const &, cv::Range >(( bp::arg("d"), bp::arg("r") )) );
        { //::cv::SdVector< cv::SdVector< int > >::addref
        
            typedef cv::SdVector< cv::SdVector< int > > exported_class_t;
            typedef void ( exported_class_t::*addref_function_type )(  ) ;
            
            Vector_Vector_int_exposer.def( 
                "addref"
                , addref_function_type( &::cv::SdVector< cv::SdVector< int > >::addref ) );
        
        }
        { //::cv::SdVector< cv::SdVector< int > >::capacity
        
            typedef cv::SdVector< cv::SdVector< int > > exported_class_t;
            typedef ::size_t ( exported_class_t::*capacity_function_type )(  ) const;
            
            Vector_Vector_int_exposer.def( 
                "capacity"
                , capacity_function_type( &::cv::SdVector< cv::SdVector< int > >::capacity ) );
        
        }
        { //::cv::SdVector< cv::SdVector< int > >::clear
        
            typedef cv::SdVector< cv::SdVector< int > > exported_class_t;
            typedef void ( exported_class_t::*clear_function_type )(  ) ;
            
            Vector_Vector_int_exposer.def( 
                "clear"
                , clear_function_type( &::cv::SdVector< cv::SdVector< int > >::clear ) );
        
        }
        { //::cv::SdVector< cv::SdVector< int > >::clone
        
            typedef cv::SdVector< cv::SdVector< int > > exported_class_t;
            typedef ::cv::SdVector< cv::SdVector< int > > ( exported_class_t::*clone_function_type )(  ) const;
            
            Vector_Vector_int_exposer.def( 
                "clone"
                , clone_function_type( &::cv::SdVector< cv::SdVector< int > >::clone ) );
        
        }
        { //::cv::SdVector< cv::SdVector< int > >::copyTo
        
            typedef cv::SdVector< cv::SdVector< int > > exported_class_t;
            typedef void ( exported_class_t::*copyTo_function_type )( ::cv::SdVector< cv::SdVector< int > > & ) const;
            
            Vector_Vector_int_exposer.def( 
                "copyTo"
                , copyTo_function_type( &::cv::SdVector< cv::SdVector< int > >::copyTo )
                , ( bp::arg("vec") ) );
        
        }
        { //::cv::SdVector< cv::SdVector< int > >::empty
        
            typedef cv::SdVector< cv::SdVector< int > > exported_class_t;
            typedef bool ( exported_class_t::*empty_function_type )(  ) const;
            
            Vector_Vector_int_exposer.def( 
                "empty"
                , empty_function_type( &::cv::SdVector< cv::SdVector< int > >::empty ) );
        
        }
        Vector_Vector_int_exposer.def( "__temp_func", &cv::SdVector< cv::SdVector< int > >::operator ::cv::Mat , "\nWrapped function:"
    "\n    operator ::cv::Mat" );
        { //::cv::SdVector< cv::SdVector< int > >::operator()
        
            typedef cv::SdVector< cv::SdVector< int > > exported_class_t;
            typedef ::cv::SdVector< cv::SdVector< int > > ( exported_class_t::*__call___function_type )( ::cv::Range const & ) const;
            
            Vector_Vector_int_exposer.def( 
                "__call__"
                , __call___function_type( &::cv::SdVector< cv::SdVector< int > >::operator() )
                , ( bp::arg("r") )
                , "\nWrapped function:"
    "\n    operator()" );
        
        }
        { //::cv::SdVector< cv::SdVector< int > >::operator=
        
            typedef cv::SdVector< cv::SdVector< int > > exported_class_t;
            typedef ::cv::SdVector< cv::SdVector< int > > & ( exported_class_t::*assign_function_type )( ::cv::SdVector< cv::SdVector< int > > const & ) ;
            
            Vector_Vector_int_exposer.def( 
                "assign"
                , assign_function_type( &::cv::SdVector< cv::SdVector< int > >::operator= )
                , ( bp::arg("d") )
                , bp::return_self< >()
                , "\nWrapped function:"
    "\n    operator=" );
        
        }
        { //::cv::SdVector< cv::SdVector< int > >::operator[]
        
            typedef cv::SdVector< cv::SdVector< int > > exported_class_t;
            typedef ::cv::SdVector< int > & ( exported_class_t::*__getitem___function_type )( ::size_t ) ;
            
            Vector_Vector_int_exposer.def( 
                "__getitem__"
                , __getitem___function_type( &::cv::SdVector< cv::SdVector< int > >::operator[] )
                , ( bp::arg("i") )
                , bp::return_internal_reference< >()
                , "\nWrapped function:"
    "\n    operator[]" );
        
        }
        { //::cv::SdVector< cv::SdVector< int > >::operator[]
        
            typedef cv::SdVector< cv::SdVector< int > > exported_class_t;
            typedef ::cv::SdVector< int > const & ( exported_class_t::*__getitem___function_type )( ::size_t ) const;
            
            Vector_Vector_int_exposer.def( 
                "__getitem__"
                , __getitem___function_type( &::cv::SdVector< cv::SdVector< int > >::operator[] )
                , ( bp::arg("i") )
                , bp::return_value_policy< bp::copy_const_reference >()
                , "\nWrapped function:"
    "\n    operator[]" );
        
        }
        { //::cv::SdVector< cv::SdVector< int > >::release
        
            typedef cv::SdVector< cv::SdVector< int > > exported_class_t;
            typedef void ( exported_class_t::*release_function_type )(  ) ;
            
            Vector_Vector_int_exposer.def( 
                "release"
                , release_function_type( &::cv::SdVector< cv::SdVector< int > >::release ) );
        
        }
        { //::cv::SdVector< cv::SdVector< int > >::reserve
        
            typedef cv::SdVector< cv::SdVector< int > > exported_class_t;
            typedef void ( exported_class_t::*reserve_function_type )( ::size_t ) ;
            
            Vector_Vector_int_exposer.def( 
                "reserve"
                , reserve_function_type( &::cv::SdVector< cv::SdVector< int > >::reserve )
                , ( bp::arg("newCapacity") ) );
        
        }
        { //::cv::SdVector< cv::SdVector< int > >::resize
        
            typedef cv::SdVector< cv::SdVector< int > > exported_class_t;
            typedef void ( exported_class_t::*resize_function_type )( ::size_t ) ;
            
            Vector_Vector_int_exposer.def( 
                "resize"
                , resize_function_type( &::cv::SdVector< cv::SdVector< int > >::resize )
                , ( bp::arg("newSize") ) );
        
        }
        { //::cv::SdVector< cv::SdVector< int > >::setitem
        
            typedef cv::SdVector< cv::SdVector< int > > exported_class_t;
            typedef void ( exported_class_t::*setitem_function_type )( int,::cv::SdVector< int > & ) ;
            
            Vector_Vector_int_exposer.def( 
                "setitem"
                , setitem_function_type( &::cv::SdVector< cv::SdVector< int > >::setitem )
                , ( bp::arg("i"), bp::arg("value") ) );
        
        }
        { //::cv::SdVector< cv::SdVector< int > >::size
        
            typedef cv::SdVector< cv::SdVector< int > > exported_class_t;
            typedef ::size_t ( exported_class_t::*size_function_type )(  ) const;
            
            Vector_Vector_int_exposer.def( 
                "size"
                , size_function_type( &::cv::SdVector< cv::SdVector< int > >::size ) );
        
        }
        { //::cv::SdVector< cv::SdVector< int > >::type
        
            typedef cv::SdVector< cv::SdVector< int > > exported_class_t;
            typedef int ( exported_class_t::*type_function_type )(  ) const;
            
            Vector_Vector_int_exposer.def( 
                "type"
                , type_function_type( &::cv::SdVector< cv::SdVector< int > >::type ) );
        
        }
        Vector_Vector_int_exposer.def("__iter__", &::iter);
        Vector_Vector_int_exposer.def("__len__", &::cv::SdVector< cv::SdVector< int > >::size);
        Vector_Vector_int_exposer.def("__setitem__", &::cv::SdVector< cv::SdVector< int > >::setitem);
    }

}
