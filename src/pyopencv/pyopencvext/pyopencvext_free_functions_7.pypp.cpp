// This file has been generated by Py++.

#include "boost/python.hpp"
#include "opencv_headers.hpp"
#include "pyopencvext_free_functions_7.pypp.hpp"

namespace bp = boost::python;

void register_free_functions_7(){

    { //::cv::cvtColor
    
        typedef void ( *cvtColor_function_type )( ::cv::Mat const &,::cv::Mat &,int,int );
        
        bp::def( 
            "cvtColor"
            , cvtColor_function_type( &::cv::cvtColor )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("code"), bp::arg("dstCn")=(int)(0) ) );
    
    }

    { //::cv::dct
    
        typedef void ( *dct_function_type )( ::cv::Mat const &,::cv::Mat &,int );
        
        bp::def( 
            "dct"
            , dct_function_type( &::cv::dct )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("flags")=(int)(0) )
            , "\nPerforms a forward or inverse discrete cosine transform of 1D or 2D "
    "\narray."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-dct" );
    
    }

    { //::cv::decomposeProjectionMatrix
    
        typedef void ( *decomposeProjectionMatrix_function_type )( ::cv::Mat const &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Vec3d & );
        
        bp::def( 
            "decomposeProjectionMatrix"
            , decomposeProjectionMatrix_function_type( &::cv::decomposeProjectionMatrix )
            , ( bp::arg("projMatrix"), bp::arg("cameraMatrix"), bp::arg("rotMatrix"), bp::arg("transVect"), bp::arg("rotMatrixX"), bp::arg("rotMatrixY"), bp::arg("rotMatrixZ"), bp::arg("eulerAngles") ) );
    
    }

    { //::cv::decomposeProjectionMatrix
    
        typedef void ( *decomposeProjectionMatrix_function_type )( ::cv::Mat const &,::cv::Mat &,::cv::Mat &,::cv::Mat & );
        
        bp::def( 
            "decomposeProjectionMatrix"
            , decomposeProjectionMatrix_function_type( &::cv::decomposeProjectionMatrix )
            , ( bp::arg("projMatrix"), bp::arg("cameraMatrix"), bp::arg("rotMatrix"), bp::arg("transVect") ) );
    
    }

    { //::cv::determinant
    
        typedef double ( *determinant_function_type )( ::cv::Mat const & );
        
        bp::def( 
            "determinant"
            , determinant_function_type( &::cv::determinant )
            , ( bp::arg("m") )
            , "\nReturns determinant of a square floating-point matrix."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-determinant" );
    
    }

    { //::cv::dft
    
        typedef void ( *dft_function_type )( ::cv::Mat const &,::cv::Mat &,int,int );
        
        bp::def( 
            "dft"
            , dft_function_type( &::cv::dft )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("flags")=(int)(0), bp::arg("nonzeroRows")=(int)(0) )
            , "\nPerforms a forward or inverse Discrete Fourier transform of 1D or 2D "
    "\nfloating-point array."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-dft" );
    
    }

    { //::cv::dilate
    
        typedef void ( *dilate_function_type )( ::cv::Mat const &,::cv::Mat &,::cv::Mat const &,::cv::Point,int,int,::cv::Scalar const & );
        
        bp::def( 
            "dilate"
            , dilate_function_type( &::cv::dilate )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("kernel"), bp::arg("anchor")=cv::Point_<int>(-0x000000001, -0x000000001), bp::arg("iterations")=(int)(1), bp::arg("borderType")=int(::cv::BORDER_CONSTANT), bp::arg("borderValue")=cv::morphologyDefaultBorderValue( ) ) );
    
    }

    { //::cv::distanceTransform
    
        typedef void ( *distanceTransform_function_type )( ::cv::Mat const &,::cv::Mat &,int,int );
        
        bp::def( 
            "distanceTransform"
            , distanceTransform_function_type( &::cv::distanceTransform )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("distanceType"), bp::arg("maskSize") ) );
    
    }

    { //::cv::distanceTransform
    
        typedef void ( *distanceTransform_function_type )( ::cv::Mat const &,::cv::Mat &,::cv::Mat &,int,int );
        
        bp::def( 
            "distanceTransform"
            , distanceTransform_function_type( &::cv::distanceTransform )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("labels"), bp::arg("distanceType"), bp::arg("maskSize") ) );
    
    }

    { //::cv::divide
    
        typedef void ( *divide_function_type )( double,::cv::MatND const &,::cv::MatND & );
        
        bp::def( 
            "divide"
            , divide_function_type( &::cv::divide )
            , ( bp::arg("scale"), bp::arg("b"), bp::arg("c") )
            , "\nPerforms per-element division of two arrays or a scalar by an array."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-divide" );
    
    }

    { //::cv::divide
    
        typedef void ( *divide_function_type )( ::cv::MatND const &,::cv::MatND const &,::cv::MatND &,double );
        
        bp::def( 
            "divide"
            , divide_function_type( &::cv::divide )
            , ( bp::arg("a"), bp::arg("b"), bp::arg("c"), bp::arg("scale")=1 )
            , "\nPerforms per-element division of two arrays or a scalar by an array."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-divide" );
    
    }

    { //::cv::divide
    
        typedef void ( *divide_function_type )( double,::cv::Mat const &,::cv::Mat & );
        
        bp::def( 
            "divide"
            , divide_function_type( &::cv::divide )
            , ( bp::arg("scale"), bp::arg("b"), bp::arg("c") )
            , "\nPerforms per-element division of two arrays or a scalar by an array."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-divide" );
    
    }

    { //::cv::divide
    
        typedef void ( *divide_function_type )( ::cv::Mat const &,::cv::Mat const &,::cv::Mat &,double );
        
        bp::def( 
            "divide"
            , divide_function_type( &::cv::divide )
            , ( bp::arg("a"), bp::arg("b"), bp::arg("c"), bp::arg("scale")=1 )
            , "\nPerforms per-element division of two arrays or a scalar by an array."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-divide" );
    
    }

    { //::cv::drawChessboardCorners
    
        typedef void ( *drawChessboardCorners_function_type )( ::cv::Mat &,::cv::Size,::cv::Mat const &,bool );
        
        bp::def( 
            "drawChessboardCorners"
            , drawChessboardCorners_function_type( &::cv::drawChessboardCorners )
            , ( bp::arg("image"), bp::arg("patternSize"), bp::arg("corners"), bp::arg("patternWasFound") ) );
    
    }

    { //::cv::eigen
    
        typedef bool ( *eigen_function_type )( ::cv::Mat const &,::cv::Mat &,::cv::Mat &,int,int );
        
        bp::def( 
            "eigen"
            , eigen_function_type( &::cv::eigen )
            , ( bp::arg("a"), bp::arg("eigenvalues"), bp::arg("eigenvectors"), bp::arg("lowindex")=(int)(-0x000000001), bp::arg("highindex")=(int)(-0x000000001) )
            , "\nComputes eigenvalues and eigenvectors of a symmetric matrix."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-eigen" );
    
    }

    { //::cv::eigen
    
        typedef bool ( *eigen_function_type )( ::cv::Mat const &,::cv::Mat &,int,int );
        
        bp::def( 
            "eigen"
            , eigen_function_type( &::cv::eigen )
            , ( bp::arg("a"), bp::arg("eigenvalues"), bp::arg("lowindex")=(int)(-0x000000001), bp::arg("highindex")=(int)(-0x000000001) )
            , "\nComputes eigenvalues and eigenvectors of a symmetric matrix."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-eigen" );
    
    }

    { //::cv::ellipse
    
        typedef void ( *ellipse_function_type )( ::cv::Mat &,::cv::RotatedRect const &,::cv::Scalar const &,int,int );
        
        bp::def( 
            "ellipse"
            , ellipse_function_type( &::cv::ellipse )
            , ( bp::arg("img"), bp::arg("box"), bp::arg("color"), bp::arg("thickness")=(int)(1), bp::arg("lineType")=(int)(8) ) );
    
    }

    { //::cv::ellipse
    
        typedef void ( *ellipse_function_type )( ::cv::Mat &,::cv::Point,::cv::Size,double,double,double,::cv::Scalar const &,int,int,int );
        
        bp::def( 
            "ellipse"
            , ellipse_function_type( &::cv::ellipse )
            , ( bp::arg("img"), bp::arg("center"), bp::arg("axes"), bp::arg("angle"), bp::arg("startAngle"), bp::arg("endAngle"), bp::arg("color"), bp::arg("thickness")=(int)(1), bp::arg("lineType")=(int)(8), bp::arg("shift")=(int)(0) ) );
    
    }

    { //::cv::equalizeHist
    
        typedef void ( *equalizeHist_function_type )( ::cv::Mat const &,::cv::Mat & );
        
        bp::def( 
            "equalizeHist"
            , equalizeHist_function_type( &::cv::equalizeHist )
            , ( bp::arg("src"), bp::arg("dst") ) );
    
    }

    { //::cv::erode
    
        typedef void ( *erode_function_type )( ::cv::Mat const &,::cv::Mat &,::cv::Mat const &,::cv::Point,int,int,::cv::Scalar const & );
        
        bp::def( 
            "erode"
            , erode_function_type( &::cv::erode )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("kernel"), bp::arg("anchor")=cv::Point_<int>(-0x000000001, -0x000000001), bp::arg("iterations")=(int)(1), bp::arg("borderType")=int(::cv::BORDER_CONSTANT), bp::arg("borderValue")=cv::morphologyDefaultBorderValue( ) ) );
    
    }

    { //::cv::exp
    
        typedef void ( *exp_function_type )( ::cv::MatND const &,::cv::MatND & );
        
        bp::def( 
            "exp"
            , exp_function_type( &::cv::exp )
            , ( bp::arg("a"), bp::arg("b") )
            , "\nCalculates the exponent of every array element."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-exp" );
    
    }

    { //::cv::exp
    
        typedef void ( *exp_function_type )( ::cv::Mat const &,::cv::Mat & );
        
        bp::def( 
            "exp"
            , exp_function_type( &::cv::exp )
            , ( bp::arg("a"), bp::arg("b") )
            , "\nCalculates the exponent of every array element."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-exp" );
    
    }

    { //::cv::fastAtan2
    
        typedef float ( *fastAtan2_function_type )( float,float );
        
        bp::def( 
            "fastAtan2"
            , fastAtan2_function_type( &::cv::fastAtan2 )
            , ( bp::arg("y"), bp::arg("x") )
            , "\nCalculates the angle of a 2D vector in degrees."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-fastatan2" );
    
    }

    { //::cv::filter2D
    
        typedef void ( *filter2D_function_type )( ::cv::Mat const &,::cv::Mat &,int,::cv::Mat const &,::cv::Point,double,int );
        
        bp::def( 
            "filter2D"
            , filter2D_function_type( &::cv::filter2D )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("ddepth"), bp::arg("kernel"), bp::arg("anchor")=cv::Point_<int>(-0x000000001, -0x000000001), bp::arg("delta")=0, bp::arg("borderType")=int(::cv::BORDER_REFLECT_101) ) );
    
    }

    { //::cv::filterSpeckles
    
        typedef void ( *filterSpeckles_function_type )( ::cv::Mat &,double,int,double,::cv::Mat & );
        
        bp::def( 
            "filterSpeckles"
            , filterSpeckles_function_type( &::cv::filterSpeckles )
            , ( bp::arg("img"), bp::arg("newVal"), bp::arg("maxSpeckleSize"), bp::arg("maxDiff"), bp::arg("buf") ) );
    
    }

    { //::cv::findFundamentalMat
    
        typedef ::cv::Mat ( *findFundamentalMat_function_type )( ::cv::Mat const &,::cv::Mat const &,int,double,double );
        
        bp::def( 
            "findFundamentalMat"
            , findFundamentalMat_function_type( &::cv::findFundamentalMat )
            , ( bp::arg("points1"), bp::arg("points2"), bp::arg("method")=int(::cv::FM_RANSAC), bp::arg("param1")=3.0e+0, bp::arg("param2")=9.89999999999999991118215802998747676610946655273e-1 ) );
    
    }

    { //::cv::findHomography
    
        typedef ::cv::Mat ( *findHomography_function_type )( ::cv::Mat const &,::cv::Mat const &,int,double );
        
        bp::def( 
            "findHomography"
            , findHomography_function_type( &::cv::findHomography )
            , ( bp::arg("srcPoints"), bp::arg("dstPoints"), bp::arg("method")=(int)(0), bp::arg("ransacReprojThreshold")=0 ) );
    
    }

    { //::cv::fitEllipse
    
        typedef ::cv::RotatedRect ( *fitEllipse_function_type )( ::cv::Mat const & );
        
        bp::def( 
            "fitEllipse"
            , fitEllipse_function_type( &::cv::fitEllipse )
            , ( bp::arg("points") ) );
    
    }

    { //::cv::fitLine
    
        typedef void ( *fitLine_function_type )( ::cv::Mat const &,::cv::Vec6f &,int,double,double,double );
        
        bp::def( 
            "fitLine"
            , fitLine_function_type( &::cv::fitLine )
            , ( bp::arg("points"), bp::arg("line"), bp::arg("distType"), bp::arg("param"), bp::arg("reps"), bp::arg("aeps") ) );
    
    }

    { //::cv::fitLine
    
        typedef void ( *fitLine_function_type )( ::cv::Mat const &,::cv::Vec4f &,int,double,double,double );
        
        bp::def( 
            "fitLine"
            , fitLine_function_type( &::cv::fitLine )
            , ( bp::arg("points"), bp::arg("line"), bp::arg("distType"), bp::arg("param"), bp::arg("reps"), bp::arg("aeps") ) );
    
    }

}
