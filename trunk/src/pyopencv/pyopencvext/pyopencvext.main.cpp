// This file has been generated by Py++.

#include "boost/python.hpp"

#include "__call_policies.pypp.hpp"

#include "__convenience.pypp.hpp"

#include "ndarray.hpp"

#include "__array_1.pypp.hpp"

#include "opencv_converters.hpp"

#include "boost/python/object.hpp"

#include "boost/python/tuple.hpp"

#include "opencv_extra.hpp"

#include "with_ownershiplevel_postcall.hpp"

#include "boost/python/str.hpp"

#include "boost/python/extract.hpp"

#include "__ctypes_integration.pypp.hpp"

#include "opencv_headers.hpp"

#include "pyopencvext/AutotunedIndexParams.pypp.hpp"

#include "pyopencvext/BackgroundSubtractor.pypp.hpp"

#include "pyopencvext/BackgroundSubtractorMOG.pypp.hpp"

#include "pyopencvext/CascadeClassifier.pypp.hpp"

#include "pyopencvext/Complexd.pypp.hpp"

#include "pyopencvext/Complexf.pypp.hpp"

#include "pyopencvext/CompositeIndexParams.pypp.hpp"

#include "pyopencvext/CvANN_MLP.pypp.hpp"

#include "pyopencvext/CvANN_MLP_TrainParams.pypp.hpp"

#include "pyopencvext/CvAdaptiveSkinDetector.pypp.hpp"

#include "pyopencvext/CvAffinePose.pypp.hpp"

#include "pyopencvext/CvAttrList.pypp.hpp"

#include "pyopencvext/CvAvgComp.pypp.hpp"

#include "pyopencvext/CvBlob.pypp.hpp"

#include "pyopencvext/CvBlobSeq.pypp.hpp"

#include "pyopencvext/CvBlobTrack.pypp.hpp"

#include "pyopencvext/CvBlobTrackSeq.pypp.hpp"

#include "pyopencvext/CvBoost.pypp.hpp"

#include "pyopencvext/CvBoostParams.pypp.hpp"

#include "pyopencvext/CvBoostTree.pypp.hpp"

#include "pyopencvext/CvBox2D.pypp.hpp"

#include "pyopencvext/CvCamShiftTracker.pypp.hpp"

#include "pyopencvext/CvChain.pypp.hpp"

#include "pyopencvext/CvChainPtReader.pypp.hpp"

#include "pyopencvext/CvConDensation.pypp.hpp"

#include "pyopencvext/CvConnectedComp.pypp.hpp"

#include "pyopencvext/CvContour.pypp.hpp"

#include "pyopencvext/CvContourScanner.pypp.hpp"

#include "pyopencvext/CvContourTree.pypp.hpp"

#include "pyopencvext/CvConvexityDefect.pypp.hpp"

#include "pyopencvext/CvDTree.pypp.hpp"

#include "pyopencvext/CvDTreeParams.pypp.hpp"

#include "pyopencvext/CvDTreeSplit.pypp.hpp"

#include "pyopencvext/CvDTreeTrainData.pypp.hpp"

#include "pyopencvext/CvDefParam.pypp.hpp"

#include "pyopencvext/CvDetectedBlob.pypp.hpp"

#include "pyopencvext/CvEM.pypp.hpp"

#include "pyopencvext/CvEMParams.pypp.hpp"

#include "pyopencvext/CvERTrees.pypp.hpp"

#include "pyopencvext/CvFeatureTree.pypp.hpp"

#include "pyopencvext/CvForestERTree.pypp.hpp"

#include "pyopencvext/CvForestTree.pypp.hpp"

#include "pyopencvext/CvFuzzyController.pypp.hpp"

#include "pyopencvext/CvFuzzyCurve.pypp.hpp"

#include "pyopencvext/CvFuzzyFunction.pypp.hpp"

#include "pyopencvext/CvFuzzyMeanShiftTracker.pypp.hpp"

#include "pyopencvext/CvFuzzyPoint.pypp.hpp"

#include "pyopencvext/CvFuzzyRule.pypp.hpp"

#include "pyopencvext/CvGenericHash.pypp.hpp"

#include "pyopencvext/CvGraph.pypp.hpp"

#include "pyopencvext/CvGraphEdge.pypp.hpp"

#include "pyopencvext/CvGraphScanner.pypp.hpp"

#include "pyopencvext/CvGraphVtx.pypp.hpp"

#include "pyopencvext/CvGraphVtx2D.pypp.hpp"

#include "pyopencvext/CvHaarClassifier.pypp.hpp"

#include "pyopencvext/CvHaarClassifierCascade.pypp.hpp"

#include "pyopencvext/CvHaarFeature.pypp.hpp"

#include "pyopencvext/CvHaarStageClassifier.pypp.hpp"

#include "pyopencvext/CvHidHaarClassifierCascade.pypp.hpp"

#include "pyopencvext/CvKNearest.pypp.hpp"

#include "pyopencvext/CvLSH.pypp.hpp"

#include "pyopencvext/CvLSHOperations.pypp.hpp"

#include "pyopencvext/CvLevMarq.pypp.hpp"

#include "pyopencvext/CvMLData.pypp.hpp"

#include "pyopencvext/CvMSERParams.pypp.hpp"

#include "pyopencvext/CvMemBlock.pypp.hpp"

#include "pyopencvext/CvMemStorage.pypp.hpp"

#include "pyopencvext/CvMemStoragePos.pypp.hpp"

#include "pyopencvext/CvModule.pypp.hpp"

#include "pyopencvext/CvModuleInfo.pypp.hpp"

#include "pyopencvext/CvNArrayIterator.pypp.hpp"

#include "pyopencvext/CvNormalBayesClassifier.pypp.hpp"

#include "pyopencvext/CvObjectDetector.pypp.hpp"

#include "pyopencvext/CvPOSITObject.pypp.hpp"

#include "pyopencvext/CvParamGrid.pypp.hpp"

#include "pyopencvext/CvPluginFuncInfo.pypp.hpp"

#include "pyopencvext/CvPoint.pypp.hpp"

#include "pyopencvext/CvPoint2D32f.pypp.hpp"

#include "pyopencvext/CvPoint2D64f.pypp.hpp"

#include "pyopencvext/CvPoint3D32f.pypp.hpp"

#include "pyopencvext/CvPoint3D64f.pypp.hpp"

#include "pyopencvext/CvQuadEdge2D.pypp.hpp"

#include "pyopencvext/CvRTParams.pypp.hpp"

#include "pyopencvext/CvRTrees.pypp.hpp"

#include "pyopencvext/CvRect.pypp.hpp"

#include "pyopencvext/CvSURFParams.pypp.hpp"

#include "pyopencvext/CvSURFPoint.pypp.hpp"

#include "pyopencvext/CvSVM.pypp.hpp"

#include "pyopencvext/CvSVMParams.pypp.hpp"

#include "pyopencvext/CvScalar.pypp.hpp"

#include "pyopencvext/CvSeq.pypp.hpp"

#include "pyopencvext/CvSeqBlock.pypp.hpp"

#include "pyopencvext/CvSeqReader.pypp.hpp"

#include "pyopencvext/CvSeqWriter.pypp.hpp"

#include "pyopencvext/CvSet.pypp.hpp"

#include "pyopencvext/CvSetElem.pypp.hpp"

#include "pyopencvext/CvSize.pypp.hpp"

#include "pyopencvext/CvSize2D32f.pypp.hpp"

#include "pyopencvext/CvSlice.pypp.hpp"

#include "pyopencvext/CvStarDetectorParams.pypp.hpp"

#include "pyopencvext/CvStarKeypoint.pypp.hpp"

#include "pyopencvext/CvStatModel.pypp.hpp"

#include "pyopencvext/CvStereoGCState.pypp.hpp"

#include "pyopencvext/CvString.pypp.hpp"

#include "pyopencvext/CvStringHashNode.pypp.hpp"

#include "pyopencvext/CvSubdiv2D.pypp.hpp"

#include "pyopencvext/CvSubdiv2DPoint.pypp.hpp"

#include "pyopencvext/CvTermCriteria.pypp.hpp"

#include "pyopencvext/CvTreeNodeIterator.pypp.hpp"

#include "pyopencvext/CvType.pypp.hpp"

#include "pyopencvext/CvTypeInfo.pypp.hpp"

#include "pyopencvext/CvVSModule.pypp.hpp"

#include "pyopencvext/CvVectors.pypp.hpp"

#include "pyopencvext/DefaultRngAuto.pypp.hpp"

#include "pyopencvext/DifferentialImage.pypp.hpp"

#include "pyopencvext/FeatureEvaluator.pypp.hpp"

#include "pyopencvext/FernClassifier.pypp.hpp"

#include "pyopencvext/FileNode.pypp.hpp"

#include "pyopencvext/FileStorage.pypp.hpp"

#include "pyopencvext/FilterEngine.pypp.hpp"

#include "pyopencvext/HOGDescriptor.pypp.hpp"

#include "pyopencvext/Index.pypp.hpp"

#include "pyopencvext/IndexFactory.pypp.hpp"

#include "pyopencvext/IndexParams.pypp.hpp"

#include "pyopencvext/IntegralHistogram.pypp.hpp"

#include "pyopencvext/IntegralImage.pypp.hpp"

#include "pyopencvext/KDTree.pypp.hpp"

#include "pyopencvext/KDTreeIndexParams.pypp.hpp"

#include "pyopencvext/KMeansIndexParams.pypp.hpp"

#include "pyopencvext/KalmanFilter.pypp.hpp"

#include "pyopencvext/KeyPoint.pypp.hpp"

#include "pyopencvext/LDetector.pypp.hpp"

#include "pyopencvext/LevMarqSparse.pypp.hpp"

#include "pyopencvext/LineIterator.pypp.hpp"

#include "pyopencvext/LinearIndexParams.pypp.hpp"

#include "pyopencvext/MSER.pypp.hpp"

#include "pyopencvext/Mat.pypp.hpp"

#include "pyopencvext/MatND.pypp.hpp"

#include "pyopencvext/Mesh3D.pypp.hpp"

#include "pyopencvext/Moments.pypp.hpp"

#include "pyopencvext/NAryMatNDIterator.pypp.hpp"

#include "pyopencvext/Octree.pypp.hpp"

#include "pyopencvext/OneWayDescriptor.pypp.hpp"

#include "pyopencvext/OneWayDescriptorBase.pypp.hpp"

#include "pyopencvext/PCA.pypp.hpp"

#include "pyopencvext/PatchGenerator.pypp.hpp"

#include "pyopencvext/PlanarObjectDetector.pypp.hpp"

#include "pyopencvext/Point2d.pypp.hpp"

#include "pyopencvext/Point2f.pypp.hpp"

#include "pyopencvext/Point2i.pypp.hpp"

#include "pyopencvext/Point3d.pypp.hpp"

#include "pyopencvext/Point3f.pypp.hpp"

#include "pyopencvext/Point3i.pypp.hpp"

#include "pyopencvext/Ptr_BaseColumnFilter.pypp.hpp"

#include "pyopencvext/Ptr_BaseFilter.pypp.hpp"

#include "pyopencvext/Ptr_BaseRowFilter.pypp.hpp"

#include "pyopencvext/Ptr_CvHaarClassifierCascade.pypp.hpp"

#include "pyopencvext/Ptr_CvStereoBMState.pypp.hpp"

#include "pyopencvext/Ptr_FeatureEvaluator.pypp.hpp"

#include "pyopencvext/Ptr_FilterEngine.pypp.hpp"

#include "pyopencvext/RNG.pypp.hpp"

#include "pyopencvext/Range.pypp.hpp"

#include "pyopencvext/Rect.pypp.hpp"

#include "pyopencvext/Rectd.pypp.hpp"

#include "pyopencvext/Rectf.pypp.hpp"

#include "pyopencvext/RotatedRect.pypp.hpp"

#include "pyopencvext/SURF.pypp.hpp"

#include "pyopencvext/SVD.pypp.hpp"

#include "pyopencvext/SavedIndexParams.pypp.hpp"

#include "pyopencvext/Scalar.pypp.hpp"

#include "pyopencvext/SearchParams.pypp.hpp"

#include "pyopencvext/SelfSimDescriptor.pypp.hpp"

#include "pyopencvext/Size2d.pypp.hpp"

#include "pyopencvext/Size2f.pypp.hpp"

#include "pyopencvext/Size2i.pypp.hpp"

#include "pyopencvext/SparseMat.pypp.hpp"

#include "pyopencvext/SparseMatConstIterator.pypp.hpp"

#include "pyopencvext/SparseMatIterator.pypp.hpp"

#include "pyopencvext/SpinImageModel.pypp.hpp"

#include "pyopencvext/StarDetector.pypp.hpp"

#include "pyopencvext/StereoBM.pypp.hpp"

#include "pyopencvext/StereoSGBM.pypp.hpp"

#include "pyopencvext/TermCriteria.pypp.hpp"

#include "pyopencvext/TickMeter.pypp.hpp"

#include "pyopencvext/Vec2b.pypp.hpp"

#include "pyopencvext/Vec2d.pypp.hpp"

#include "pyopencvext/Vec2f.pypp.hpp"

#include "pyopencvext/Vec2i.pypp.hpp"

#include "pyopencvext/Vec2s.pypp.hpp"

#include "pyopencvext/Vec2w.pypp.hpp"

#include "pyopencvext/Vec3b.pypp.hpp"

#include "pyopencvext/Vec3d.pypp.hpp"

#include "pyopencvext/Vec3f.pypp.hpp"

#include "pyopencvext/Vec3i.pypp.hpp"

#include "pyopencvext/Vec3s.pypp.hpp"

#include "pyopencvext/Vec3w.pypp.hpp"

#include "pyopencvext/Vec4b.pypp.hpp"

#include "pyopencvext/Vec4d.pypp.hpp"

#include "pyopencvext/Vec4f.pypp.hpp"

#include "pyopencvext/Vec4i.pypp.hpp"

#include "pyopencvext/Vec4s.pypp.hpp"

#include "pyopencvext/Vec4w.pypp.hpp"

#include "pyopencvext/Vec6d.pypp.hpp"

#include "pyopencvext/Vec6f.pypp.hpp"

#include "pyopencvext/VideoCapture.pypp.hpp"

#include "pyopencvext/VideoWriter.pypp.hpp"

#include "pyopencvext/__dummy_struct.pypp.hpp"

#include "pyopencvext/flann_Index.pypp.hpp"

#include "pyopencvext/lsh_hash.pypp.hpp"

#include "pyopencvext/pyopencvext_enumerations.pypp.hpp"

#include "pyopencvext/pyopencvext_free_functions.pypp.hpp"

#include "pyopencvext/pyopencvext_global_variables.pypp.hpp"

namespace bp = boost::python;

static boost::python::object FAST_23d17220884e2f371691b185394322ec( ::cv::Mat const & image, int threshold, bool nonmax_supression=true ){
    ::std::vector< cv::KeyPoint > keypoints2;
    bp::list keypoints3;
    ::cv::FAST(image, keypoints2, threshold, nonmax_supression);
    convert_from_T_to_object(keypoints2, keypoints3);
    return bp::object( keypoints3 );
}

static boost::python::object HoughCircles_ea2999473356200d9d2fc8b7258555b0( ::cv::Mat const & image, int method, double dp, double minDist, double param1=100, double param2=100, int minRadius=0, int maxRadius=0 ){
    ::std::vector< cv::Vec<float, 3> > circles2;
    cv::Mat circles3;
    ::cv::HoughCircles(image, circles2, method, dp, minDist, param1, param2, minRadius, maxRadius);
    convert_from_vector_of_T_to_Mat(circles2, circles3);
    return bp::object( circles3 );
}

static boost::python::object HoughLines_deaa796a20e753a0b781de4a4d81ba3d( ::cv::Mat const & image, double rho, double theta, int threshold, double srn=0, double stn=0 ){
    ::std::vector< cv::Vec<float, 2> > lines2;
    cv::Mat lines3;
    ::cv::HoughLines(image, lines2, rho, theta, threshold, srn, stn);
    convert_from_vector_of_T_to_Mat(lines2, lines3);
    return bp::object( lines3 );
}

static boost::python::object HoughLinesP_7e83e90590dfee49ad9ee8d704d1cfcb( ::cv::Mat & image, double rho, double theta, int threshold, double minLineLength=0, double maxLineGap=0 ){
    ::std::vector< cv::Vec<int, 4> > lines2;
    cv::Mat lines3;
    ::cv::HoughLinesP(image, lines2, rho, theta, threshold, minLineLength, maxLineGap);
    convert_from_vector_of_T_to_Mat(lines2, lines3);
    return bp::object( lines3 );
}

static boost::python::object HuMoments_646f4ee3824db566d9124eee2bb204ab( ::cv::Moments const & moments ){
    double native_hu[7];
    boost::python::list py_hu;
    ::cv::HuMoments(moments, native_hu);
    pyplus_conv::copy_container( native_hu, native_hu + 7, pyplus_conv::list_inserter( py_hu ) );
    return bp::object( py_hu );
}

static boost::python::object approxPolyDP_6246fabc9452f087130300d2a52e2a7d( ::cv::Mat const & curve, double epsilon, bool closed ){
    ::std::vector< cv::Point_<float> > approxCurve2;
    cv::Mat approxCurve3;
    ::cv::approxPolyDP(curve, approxCurve2, epsilon, closed);
    convert_from_vector_of_T_to_Mat(approxCurve2, approxCurve3);
    return bp::object( approxCurve3 );
}

static boost::python::object approxPolyDP_d6c85380d14cce99fc92c414781ada55( ::cv::Mat const & curve, double epsilon, bool closed ){
    ::std::vector< cv::Point_<int> > approxCurve2;
    cv::Mat approxCurve3;
    ::cv::approxPolyDP(curve, approxCurve2, epsilon, closed);
    convert_from_vector_of_T_to_Mat(approxCurve2, approxCurve3);
    return bp::object( approxCurve3 );
}

static void buildPyramid_84cd4ffd24fbd4dbaeccf86ceb1007ac( ::cv::Mat const & src, bp::list & dst, int maxlevel ){
    ::std::vector< cv::Mat > dst2;
    convert_from_object_to_T(dst, dst2);
    ::cv::buildPyramid(src, dst2, maxlevel);
    convert_from_T_to_object(dst2, dst);
}

static void calcBackProject_fe6cdc6fffc26e8d864a094a2b14971b( sdcpp::sequence images, cv::Mat const & channels, ::cv::SparseMat const & hist, ::cv::Mat & backProject, bp::object const & ranges, double scale=1, bool uniform=true ){
    std::vector< ::cv::Mat > images2;
    int channels2;
    int * channels3;
    convert_from_seq_of_Mat_to_vector_of_T(images, images2);
    convert_from_Mat_to_array_of_T(channels, channels3, channels2);
    bool b_ranges = (ranges.ptr() != Py_None);
    std::vector<std::vector< float > > arr_ranges;
    if(b_ranges) convert_from_object_to_T(ranges, arr_ranges);
    int n0_ranges = b_ranges? arr_ranges.size(): 0;
    
    std::vector< float * > buf_ranges;
    std::vector<int> n1_ranges;
    if(b_ranges)
    {
        buf_ranges.resize(n0_ranges);
        n1_ranges.resize(n0_ranges);
        for(int i_ranges = 0; i_ranges < n0_ranges; ++i_ranges)
        {
            buf_ranges[i_ranges] = &arr_ranges[i_ranges][0];
            n1_ranges[i_ranges] = arr_ranges[i_ranges].size();
        }
    }
        
    ::cv::calcBackProject((::cv::Mat const *)&images2[0], images2.size(), channels3, hist, backProject, (float const * *) &buf_ranges[0], scale, uniform);
}

static void calcBackProject_84908d355b9d9fa6b6e1e0115efb65f8( sdcpp::sequence images, cv::Mat const & channels, ::cv::MatND const & hist, ::cv::Mat & backProject, bp::object const & ranges, double scale=1, bool uniform=true ){
    std::vector< ::cv::Mat > images2;
    int channels2;
    int * channels3;
    convert_from_seq_of_Mat_to_vector_of_T(images, images2);
    convert_from_Mat_to_array_of_T(channels, channels3, channels2);
    bool b_ranges = (ranges.ptr() != Py_None);
    std::vector<std::vector< float > > arr_ranges;
    if(b_ranges) convert_from_object_to_T(ranges, arr_ranges);
    int n0_ranges = b_ranges? arr_ranges.size(): 0;
    
    std::vector< float * > buf_ranges;
    std::vector<int> n1_ranges;
    if(b_ranges)
    {
        buf_ranges.resize(n0_ranges);
        n1_ranges.resize(n0_ranges);
        for(int i_ranges = 0; i_ranges < n0_ranges; ++i_ranges)
        {
            buf_ranges[i_ranges] = &arr_ranges[i_ranges][0];
            n1_ranges[i_ranges] = arr_ranges[i_ranges].size();
        }
    }
        
    ::cv::calcBackProject((::cv::Mat const *)&images2[0], images2.size(), channels3, hist, backProject, (float const * *) &buf_ranges[0], scale, uniform);
}

static void calcCovarMatrix_e8cf288956f6478b98045989198e81f5( bp::list const & samples, ::cv::Mat & covar, ::cv::Mat & mean, int flags, int ctype=6 ){
    int samples2=bp::len(samples);
    std::vector< ::cv::Mat > samples3(samples2);
    convert_from_object_to_T(samples, samples3);
    ::cv::calcCovarMatrix(&samples3[0], samples2, covar, mean, flags, ctype);
}

static void calcHist_8e436c4da97e1e09468541e1bed60274( sdcpp::sequence images, cv::Mat const & channels, ::cv::Mat const & mask, ::cv::SparseMat & hist, cv::Mat const & histSize, bp::object const & ranges, bool uniform=true, bool accumulate=false ){
    std::vector< ::cv::Mat > images2;
    int channels2;
    int * channels3;
    int histSize2;
    int * histSize3;
    convert_from_seq_of_Mat_to_vector_of_T(images, images2);
    convert_from_Mat_to_array_of_T(channels, channels3, channels2);
    convert_from_Mat_to_array_of_T(histSize, histSize3, histSize2);
    bool b_ranges = (ranges.ptr() != Py_None);
    std::vector<std::vector< float > > arr_ranges;
    if(b_ranges) convert_from_object_to_T(ranges, arr_ranges);
    int n0_ranges = b_ranges? arr_ranges.size(): 0;
    
    std::vector< float * > buf_ranges;
    std::vector<int> n1_ranges;
    if(b_ranges)
    {
        buf_ranges.resize(n0_ranges);
        n1_ranges.resize(n0_ranges);
        for(int i_ranges = 0; i_ranges < n0_ranges; ++i_ranges)
        {
            buf_ranges[i_ranges] = &arr_ranges[i_ranges][0];
            n1_ranges[i_ranges] = arr_ranges[i_ranges].size();
        }
    }
        
    ::cv::calcHist((::cv::Mat const *)&images2[0], images2.size(), channels3, mask, hist, histSize2, histSize3, (float const * *) &buf_ranges[0], uniform, accumulate);
}

static void calcHist_a4cce9bdd9689d0fb0adf901f467bfa0( sdcpp::sequence images, cv::Mat const & channels, ::cv::Mat const & mask, ::cv::MatND & hist, cv::Mat const & histSize, bp::object const & ranges, bool uniform=true, bool accumulate=false ){
    std::vector< ::cv::Mat > images2;
    int channels2;
    int * channels3;
    int histSize2;
    int * histSize3;
    convert_from_seq_of_Mat_to_vector_of_T(images, images2);
    convert_from_Mat_to_array_of_T(channels, channels3, channels2);
    convert_from_Mat_to_array_of_T(histSize, histSize3, histSize2);
    bool b_ranges = (ranges.ptr() != Py_None);
    std::vector<std::vector< float > > arr_ranges;
    if(b_ranges) convert_from_object_to_T(ranges, arr_ranges);
    int n0_ranges = b_ranges? arr_ranges.size(): 0;
    
    std::vector< float * > buf_ranges;
    std::vector<int> n1_ranges;
    if(b_ranges)
    {
        buf_ranges.resize(n0_ranges);
        n1_ranges.resize(n0_ranges);
        for(int i_ranges = 0; i_ranges < n0_ranges; ++i_ranges)
        {
            buf_ranges[i_ranges] = &arr_ranges[i_ranges][0];
            n1_ranges[i_ranges] = arr_ranges[i_ranges].size();
        }
    }
        
    ::cv::calcHist((::cv::Mat const *)&images2[0], images2.size(), channels3, mask, hist, histSize2, histSize3, (float const * *) &buf_ranges[0], uniform, accumulate);
}

static void calcOpticalFlowPyrLK_2855d31de3545ba96e3fc0ad950740f1( ::cv::Mat const & prevImg, ::cv::Mat const & nextImg, cv::Mat const & prevPts, cv::Mat & nextPts, cv::Mat & status, cv::Mat & err, ::cv::Size winSize=cv::Size_<int>(15, 15), int maxLevel=3, ::cv::TermCriteria criteria=cv::TermCriteria(3, 30, 1.0000000000000000208166817117216851329430937767e-2), double derivLambda=5.0e-1, int flags=0 ){
    ::std::vector< cv::Point_<float> > prevPts2;
    ::std::vector< cv::Point_<float> > nextPts2;
    ::std::vector< unsigned char > status2;
    ::std::vector< float > err2;
    convert_from_Mat_to_vector_of_T(prevPts, prevPts2);
    convert_from_Mat_to_vector_of_T(nextPts, nextPts2);
    convert_from_Mat_to_vector_of_T(status, status2);
    convert_from_Mat_to_vector_of_T(err, err2);
    ::cv::calcOpticalFlowPyrLK(prevImg, nextImg, prevPts2, nextPts2, status2, err2, winSize, maxLevel, criteria, derivLambda, flags);
    convert_from_vector_of_T_to_Mat(nextPts2, nextPts);
    convert_from_vector_of_T_to_Mat(status2, status);
    convert_from_vector_of_T_to_Mat(err2, err);
}

static boost::python::tuple calibrateCamera_e3c243276629b1246626096d8ff70485( bp::list const & objectPoints, bp::list const & imagePoints, ::cv::Size imageSize, ::cv::Mat & cameraMatrix, ::cv::Mat & distCoeffs, int flags=0 ){
    ::std::vector< cv::Mat > rvecs2;
    bp::list rvecs3;
    ::std::vector< cv::Mat > tvecs2;
    bp::list tvecs3;
    ::std::vector< std::vector< cv::Point3_<float> > > objectPoints2;
    ::std::vector< std::vector< cv::Point_<float> > > imagePoints2;
    convert_from_object_to_T(objectPoints, objectPoints2);
    convert_from_object_to_T(imagePoints, imagePoints2);
    double result = ::cv::calibrateCamera(objectPoints2, imagePoints2, imageSize, cameraMatrix, distCoeffs, rvecs2, tvecs2, flags);
    convert_from_T_to_object(rvecs2, rvecs3);
    convert_from_T_to_object(tvecs2, tvecs3);
    return bp::make_tuple( result, rvecs3, tvecs3 );
}

static boost::python::tuple checkRange_138f1b60b28a059182d9f09088ca2474( ::cv::MatND const & a, bool quiet=true, double minVal=-1.79769313486231570814527423731704356798070567526e+308, double maxVal=1.79769313486231570814527423731704356798070567526e+308 ){
    int idx2;
    bool result = ::cv::checkRange(a, quiet, &idx2, minVal, maxVal);
    return bp::make_tuple( result, idx2 );
}

static boost::python::tuple checkRange_31cc45f75977959e58047954bd730b32( ::cv::Mat const & a, bool quiet=true, double minVal=-1.79769313486231570814527423731704356798070567526e+308, double maxVal=1.79769313486231570814527423731704356798070567526e+308 ){
    cv::Point_<int> pt2;
    bool result = ::cv::checkRange(a, quiet, &pt2, minVal, maxVal);
    return bp::make_tuple( result, pt2 );
}

static boost::python::object computeCorrespondEpilines_c5fa9f4742dac0ce300bb37345eb1f07( ::cv::Mat const & points1, int whichImage, ::cv::Mat const & F ){
    ::std::vector< cv::Vec<float, 3> > lines2;
    cv::Mat lines3;
    ::cv::computeCorrespondEpilines(points1, whichImage, F, lines2);
    convert_from_vector_of_T_to_Mat(lines2, lines3);
    return bp::object( lines3 );
}

static boost::python::object convertPointsHomogeneous_a80a768ed55e897cac15946457cd1696( ::cv::Mat const & src ){
    ::std::vector< cv::Point_<float> > dst2;
    cv::Mat dst3;
    ::cv::convertPointsHomogeneous(src, dst2);
    convert_from_vector_of_T_to_Mat(dst2, dst3);
    return bp::object( dst3 );
}

static boost::python::object convertPointsHomogeneous_d220e3269e8c59fdb5b2dc2f830579b0( ::cv::Mat const & src ){
    ::std::vector< cv::Point3_<float> > dst2;
    cv::Mat dst3;
    ::cv::convertPointsHomogeneous(src, dst2);
    convert_from_vector_of_T_to_Mat(dst2, dst3);
    return bp::object( dst3 );
}

static boost::python::object convexHull_42e8e723b1326dae78cb20a5c349e4e6( ::cv::Mat const & points, bool clockwise=false ){
    ::std::vector< cv::Point_<float> > hull2;
    cv::Mat hull3;
    ::cv::convexHull(points, hull2, clockwise);
    convert_from_vector_of_T_to_Mat(hull2, hull3);
    return bp::object( hull3 );
}

static boost::python::object convexHull_bf35caecb3465c45234b484233937f99( ::cv::Mat const & points, bool clockwise=false ){
    ::std::vector< cv::Point_<int> > hull2;
    cv::Mat hull3;
    ::cv::convexHull(points, hull2, clockwise);
    convert_from_vector_of_T_to_Mat(hull2, hull3);
    return bp::object( hull3 );
}

static boost::python::object convexHull_a7bf196b869588f11c69529c43975a42( ::cv::Mat const & points, bool clockwise=false ){
    ::std::vector< int > hull2;
    cv::Mat hull3;
    ::cv::convexHull(points, hull2, clockwise);
    convert_from_vector_of_T_to_Mat(hull2, hull3);
    return bp::object( hull3 );
}

static void cornerSubPix_897410ee39f221d5b382cc794de38b84( ::cv::Mat const & image, cv::Mat & corners, ::cv::Size winSize, ::cv::Size zeroZone, ::cv::TermCriteria criteria ){
    ::std::vector< cv::Point_<float> > corners2;
    convert_from_Mat_to_vector_of_T(corners, corners2);
    ::cv::cornerSubPix(image, corners2, winSize, zeroZone, criteria);
    convert_from_vector_of_T_to_Mat(corners2, corners);
}

static boost::python::tuple createTrackbar_a255009d4d0c76c9c0a784685d2594ee( ::std::string const & trackbarname, ::std::string const & winname, unsigned int value, int count, boost::python::object onChange=bp::object(), boost::python::object userdata=bp::object() ){
    bp::tuple z_onChange= bp::make_tuple(onChange, userdata);
    int result = ::cv::createTrackbar(trackbarname, winname, reinterpret_cast< int * >( value ), count, sdTrackbarCallback2, (void *)(z_onChange.ptr()));
    return bp::make_tuple( result, z_onChange );
}

static void cvAcc_ef7ed9735ac6fce4129e5e89f645482d( ::cv::Mat & image, ::cv::Mat & sum, ::cv::Mat mask=cv::Mat() ){
    ::cvAcc(get_CvMat_ptr(image), get_CvMat_ptr(sum), get_CvMat_ptr(mask));
}

static boost::python::tuple cvCalcAffineFlowPyrLK_3a4b3f5dff85e72a121da3f42cded4aa( ::cv::Mat & prev, ::cv::Mat & curr, ::cv::Mat & prev_pyr, ::cv::Mat & curr_pyr, cv::Mat const & prev_features, ::CvSize win_size, int level, ::CvTermCriteria criteria, int flags ){
    int prev_features2;
    CvPoint2D32f * prev_features3;
    std::vector < char > status2;
    std::vector < float > track_error2;
    std::vector < ::CvPoint2D32f > curr_features2;
    std::vector < float > matrices2;
    convert_from_Mat_to_array_of_T(prev_features, prev_features3, prev_features2);
    status2.resize(prev_features2 * 1);
    track_error2.resize(prev_features2 * 1);
    curr_features2.resize(prev_features2 * 1);
    matrices2.resize(prev_features2 * 1);
    ::cvCalcAffineFlowPyrLK(get_CvMat_ptr(prev), get_CvMat_ptr(curr), get_CvMat_ptr(prev_pyr), get_CvMat_ptr(curr_pyr), prev_features3, &(curr_features2[0]), &(matrices2[0]), prev_features2, win_size, level, &(status2[0]), &(track_error2[0]), criteria, flags);
    return bp::make_tuple( convert_from_T_to_object(status2)
                            , convert_from_T_to_object(track_error2)
                            , convert_from_T_to_object(curr_features2)
                            , convert_from_T_to_object(matrices2) );
}

static boost::python::object cvCalcEMD2_f4e5308a9258b3a75a06fb112d06a2e8( ::cv::Mat & signature1, ::cv::Mat & signature2, int distance_type, boost::python::object distance_func=bp::object(), ::cv::Mat cost_matrix=cv::Mat(), ::cv::Mat flow=cv::Mat(), float * lower_bound=0, boost::python::object userdata=bp::object() ){
    bool b_distance_func= distance_func.ptr() != Py_None;
    boost::python::tuple z_distance_func;
    if(b_distance_func) z_distance_func = bp::make_tuple(distance_func, userdata);
    float result = ::cvCalcEMD2(get_CvMat_ptr(signature1), get_CvMat_ptr(signature2), distance_type, b_distance_func? sdDistanceFunction: 0, get_CvMat_ptr(cost_matrix), get_CvMat_ptr(flow), lower_bound, b_distance_func? (void *)(z_distance_func.ptr()): 0);
    return bp::object( result );
}

static boost::python::object cvCalcGlobalOrientation_9d75a586d5a67c41e4450ccf9b8af7b3( ::cv::Mat & orientation, ::cv::Mat & mask, ::cv::Mat & mhi, double timestamp, double duration ){
    double result = ::cvCalcGlobalOrientation(get_CvMat_ptr(orientation), get_CvMat_ptr(mask), get_CvMat_ptr(mhi), timestamp, duration);
    return bp::object( result );
}

static boost::python::object cvCalcImageHomography_a814cf819bbf03a0c8d0b4fd1b700335( boost::python::object line, ::CvPoint3D32f * center, boost::python::object intrinsic ){
    float native_line[3];
    float native_intrinsic[9];
    float native_homography[9];
    boost::python::list py_homography;
    pyplus_conv::ensure_uniform_sequence< float >( line, 3 );
    pyplus_conv::copy_sequence( line, pyplus_conv::array_inserter( native_line, 3 ) );
    pyplus_conv::ensure_uniform_sequence< float >( intrinsic, 9 );
    pyplus_conv::copy_sequence( intrinsic, pyplus_conv::array_inserter( native_intrinsic, 9 ) );
    ::cvCalcImageHomography(native_line, center, native_intrinsic, native_homography);
    pyplus_conv::copy_container( native_homography, native_homography + 9, pyplus_conv::list_inserter( py_homography ) );
    return bp::object( py_homography );
}

static void cvCalcMotionGradient_7506fb6ca34b4a6cb9165f5aff081454( ::cv::Mat & mhi, ::cv::Mat & mask, ::cv::Mat & orientation, double delta1, double delta2, int aperture_size=3 ){
    ::cvCalcMotionGradient(get_CvMat_ptr(mhi), get_CvMat_ptr(mask), get_CvMat_ptr(orientation), delta1, delta2, aperture_size);
}

static void cvCalcOpticalFlowBM_3537c5574d176e4f3dea85450be5ee9f( ::cv::Mat & prev, ::cv::Mat & curr, ::CvSize block_size, ::CvSize shift_size, ::CvSize max_range, int use_previous, ::cv::Mat & velx, ::cv::Mat & vely ){
    ::cvCalcOpticalFlowBM(get_CvMat_ptr(prev), get_CvMat_ptr(curr), block_size, shift_size, max_range, use_previous, get_CvMat_ptr(velx), get_CvMat_ptr(vely));
}

static void cvCalcOpticalFlowFarneback_409b7a55ce4ab8f251cb192176e9376c( ::cv::Mat & prev, ::cv::Mat & next, ::cv::Mat & flow, double pyr_scale, int levels, int winsize, int iterations, int poly_n, double poly_sigma, int flags ){
    ::cvCalcOpticalFlowFarneback(get_CvMat_ptr(prev), get_CvMat_ptr(next), get_CvMat_ptr(flow), pyr_scale, levels, winsize, iterations, poly_n, poly_sigma, flags);
}

static void cvCalcOpticalFlowHS_0757feb4eeb7fd8c38b710aec2f5f8e9( ::cv::Mat & prev, ::cv::Mat & curr, int use_previous, ::cv::Mat & velx, ::cv::Mat & vely, double lambda, ::CvTermCriteria criteria ){
    ::cvCalcOpticalFlowHS(get_CvMat_ptr(prev), get_CvMat_ptr(curr), use_previous, get_CvMat_ptr(velx), get_CvMat_ptr(vely), lambda, criteria);
}

static void cvCalcOpticalFlowLK_0539268816232dbc93df209c0dc87327( ::cv::Mat & prev, ::cv::Mat & curr, ::CvSize win_size, ::cv::Mat & velx, ::cv::Mat & vely ){
    ::cvCalcOpticalFlowLK(get_CvMat_ptr(prev), get_CvMat_ptr(curr), win_size, get_CvMat_ptr(velx), get_CvMat_ptr(vely));
}

static boost::python::tuple cvCalcOpticalFlowPyrLK_925fd4448f97740474886f84b12836c2( ::cv::Mat & prev, ::cv::Mat & curr, ::cv::Mat & prev_pyr, ::cv::Mat & curr_pyr, cv::Mat const & prev_features, ::CvSize win_size, int level, ::CvTermCriteria criteria, int flags ){
    int prev_features2;
    CvPoint2D32f * prev_features3;
    std::vector < char > status2;
    std::vector < float > track_error2;
    std::vector < ::CvPoint2D32f > curr_features2;
    convert_from_Mat_to_array_of_T(prev_features, prev_features3, prev_features2);
    status2.resize(prev_features2 * 1);
    track_error2.resize(prev_features2 * 1);
    curr_features2.resize(prev_features2 * 1);
    ::cvCalcOpticalFlowPyrLK(get_CvMat_ptr(prev), get_CvMat_ptr(curr), get_CvMat_ptr(prev_pyr), get_CvMat_ptr(curr_pyr), prev_features3, &(curr_features2[0]), prev_features2, win_size, level, &(status2[0]), &(track_error2[0]), criteria, flags);
    return bp::make_tuple( convert_from_T_to_object(status2)
                            , convert_from_T_to_object(track_error2)
                            , convert_from_T_to_object(curr_features2) );
}

static boost::python::object cvCheckChessboard_59f8753d978791ecd1fc97cea5e10f04( ::cv::Mat & src, ::CvSize size ){
    int result = ::cvCheckChessboard(get_IplImage_ptr(src), size);
    return bp::object( result );
}

static void cvConDensInitSampleSet_2b2c9d04e9f57fb36a248c795590341d( ::CvConDensation * condens, ::cv::Mat & lower_bound, ::cv::Mat & upper_bound ){
    ::cvConDensInitSampleSet(condens, get_CvMat_ptr(lower_bound), get_CvMat_ptr(upper_bound));
}

static void cvConvertImage_9d5028440635df77832885475bf0ea00( ::cv::Mat & src, ::cv::Mat & dst, int flags=0 ){
    ::cvConvertImage(get_CvMat_ptr(src), get_CvMat_ptr(dst), flags);
}

static boost::python::object cvConvexityDefects_cc97bf52cc42e365950605a23b42e95a( ::cv::Mat & contour, ::cv::Mat & convexhull, ::CvMemStorage * storage=0 ){
    ::CvSeq * result = ::cvConvexityDefects(get_CvMat_ptr(contour), get_CvMat_ptr(convexhull), storage);
    typedef bp::with_custodian_and_ward_postcall< 0, 2, bp::with_custodian_and_ward_postcall< 0, 1, bp::with_custodian_and_ward_postcall< 0, 3, bp::return_value_policy< bp::reference_existing_object > > > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvSeq * >( result ) );
}

static void cvCorrectMatches_055faac2f695cea7fa86e829ba6bdc99( ::cv::Mat & F, ::cv::Mat & points1, ::cv::Mat & points2, ::cv::Mat & new_points1, ::cv::Mat & new_points2 ){
    ::cvCorrectMatches(get_CvMat_ptr(F), get_CvMat_ptr(points1), get_CvMat_ptr(points2), get_CvMat_ptr(new_points1), get_CvMat_ptr(new_points2));
}

static boost::python::object cvCreateKDTree_bedd697814f42b0adb235e1d1bda9bdd( ::cv::Mat & desc ){
    ::CvFeatureTree * result = ::cvCreateKDTree(get_CvMat_ptr(desc));
    typedef bp::with_ownershiplevel_postcall< 1, bp::with_custodian_and_ward_postcall< 0, 1, bp::return_value_policy< bp::reference_existing_object > > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvFeatureTree * >( result ) );
}

static boost::python::object cvCreateSpillTree_22146c3478f3d8c8ff22213a86f1b244( ::cv::Mat & raw_data, int const naive=50, double const rho=6.99999999999999955591079014993738383054733276367e-1, double const tau=1.00000000000000005551115123125782702118158340454e-1 ){
    ::CvFeatureTree * result = ::cvCreateSpillTree(get_CvMat_ptr(raw_data), naive, rho, tau);
    typedef bp::with_ownershiplevel_postcall< 1, bp::with_custodian_and_ward_postcall< 0, 1, bp::return_value_policy< bp::reference_existing_object > > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvFeatureTree * >( result ) );
}

static void cvDistTransform_68addecae85b6b48cd46044102a6c028( ::cv::Mat & src, ::cv::Mat & dst, int distance_type=2, int mask_size=3, cv::Mat mask=cv::Mat(), ::cv::Mat labels=cv::Mat() ){
    int mask2;
    float * mask3;
    convert_from_Mat_to_array_of_T(mask, mask3, mask2);
    ::cvDistTransform(get_CvMat_ptr(src), get_CvMat_ptr(dst), distance_type, mask_size, mask3, get_CvMat_ptr(labels));
}

static void cvEndWriteStruct_49df8f8a99539026dfbd302575d7a485( ::cv::FileStorage & fs ){
    ::cvEndWriteStruct(fs.fs);
}

static boost::python::object cvEstimateRigidTransform_2f885814bd847b94c8621a570a36abad( ::cv::Mat & A, ::cv::Mat & B, ::cv::Mat & M, int full_affine ){
    int result = ::cvEstimateRigidTransform(get_CvMat_ptr(A), get_CvMat_ptr(B), get_CvMat_ptr(M), full_affine);
    return bp::object( result );
}

static void cvFindFeatures_3cdcd7c246944a80a295b6f20e448cfc( ::CvFeatureTree * tr, ::cv::Mat & query_points, ::cv::Mat & indices, ::cv::Mat & dist, int k, int emax=20 ){
    ::cvFindFeatures(tr, get_CvMat_ptr(query_points), get_CvMat_ptr(indices), get_CvMat_ptr(dist), k, emax);
}

static boost::python::object cvFindFeaturesBoxed_6d675cd8257b64f665600bd276900d3e( ::CvFeatureTree * tr, ::cv::Mat & bounds_min, ::cv::Mat & bounds_max, ::cv::Mat & out_indices ){
    int result = ::cvFindFeaturesBoxed(tr, get_CvMat_ptr(bounds_min), get_CvMat_ptr(bounds_max), get_CvMat_ptr(out_indices));
    return bp::object( result );
}

static boost::python::object cvFindNearestPoint2D_4658231361f43a6fc66c2e150f75dca8( ::CvSubdiv2D * subdiv, const ::cv::Point2f & pt ){
    ::CvSubdiv2DPoint * result = ::cvFindNearestPoint2D(subdiv, (CvPoint2D32f)(pt));
    typedef bp::with_custodian_and_ward_postcall< 0, 1, bp::return_value_policy< bp::reference_existing_object > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvSubdiv2DPoint * >( result ) );
}

static void cvFindStereoCorrespondence_7b07c127d562a5149232dd8cc1bc470d( ::cv::Mat & leftImage, ::cv::Mat & rightImage, int mode, ::cv::Mat & dispImage, int maxDisparity, double param1=12345, double param2=12345, double param3=12345, double param4=12345, double param5=12345 ){
    ::cvFindStereoCorrespondence(get_CvMat_ptr(leftImage), get_CvMat_ptr(rightImage), mode, get_CvMat_ptr(dispImage), maxDisparity, param1, param2, param3, param4, param5);
}

static void cvFindStereoCorrespondenceGC_c3eefaed321a780e7059f7c3392c4672( ::cv::Mat & left, ::cv::Mat & right, ::cv::Mat & disparityLeft, ::cv::Mat & disparityRight, ::CvStereoGCState * state, int useDisparityGuess=0 ){
    ::cvFindStereoCorrespondenceGC(get_CvMat_ptr(left), get_CvMat_ptr(right), get_CvMat_ptr(disparityLeft), get_CvMat_ptr(disparityRight), state, useDisparityGuess);
}

static boost::python::object cvGetElemType_28303ccd15acadc45a20b8189b3b5941( ::cv::Mat & arr ){
    int result = ::cvGetElemType(get_CvMat_ptr(arr));
    return bp::object( result );
}

static boost::python::object cvGetHashedKey_5bf3bb09f908d63c5767d651120f813f( ::cv::FileStorage & fs, char const * name, int len=-0x000000001, int create_missing=0 ){
    ::CvStringHashNode * result = ::cvGetHashedKey(fs.fs, name, len, create_missing);
    typedef bp::with_custodian_and_ward_postcall< 0, 1, bp::return_value_policy< bp::reference_existing_object > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvStringHashNode * >( result ) );
}

static void cvGetQuadrangleSubPix_fe2b1a5028fa8b02301dc960cdfbc131( ::cv::Mat & src, ::cv::Mat & dst, ::cv::Mat & map_matrix ){
    ::cvGetQuadrangleSubPix(get_CvMat_ptr(src), get_CvMat_ptr(dst), get_CvMat_ptr(map_matrix));
}

static boost::python::object cvInitNArrayIterator_4c1924434c279d42b088754762acc53b( cv::Mat const & arrs, ::cv::Mat & mask, ::CvMatND * stubs, ::CvNArrayIterator * array_iterator, int flags=0 ){
    int arrs2;
    void * * arrs3;
    convert_from_Mat_to_array_of_T(arrs, arrs3, arrs2);
    int result = ::cvInitNArrayIterator(arrs2, arrs3, get_CvMat_ptr(mask), stubs, array_iterator, flags);
    return bp::object( result );
}

static boost::python::object cvInitSystem_f0aa383f9ae0b2f0bf89bbcb5e73da23( cv::Mat const & argv ){
    int argv2;
    char * * argv3;
    convert_from_Mat_to_array_of_T(argv, argv3, argv2);
    int result = ::cvInitSystem(argv2, argv3);
    return bp::object( result );
}

static void cvLSHAdd_fead3e6b36de0b14c88ef1b561c6e621( ::CvLSH * lsh, ::cv::Mat & data, ::cv::Mat indices=cv::Mat() ){
    ::cvLSHAdd(lsh, get_CvMat_ptr(data), get_CvMat_ptr(indices));
}

static void cvLSHQuery_a5f47e360cc9701a6672c12490153852( ::CvLSH * lsh, ::cv::Mat & query_points, ::cv::Mat & indices, ::cv::Mat & dist, int k, int emax ){
    ::cvLSHQuery(lsh, get_CvMat_ptr(query_points), get_CvMat_ptr(indices), get_CvMat_ptr(dist), k, emax);
}

static void cvLSHRemove_5f32fb503216c52038c4ae3bf17b62db( ::CvLSH * lsh, ::cv::Mat & indices ){
    ::cvLSHRemove(lsh, get_CvMat_ptr(indices));
}

static void cvLinearPolar_b75d44697de3c90f0462366e93d77425( ::cv::Mat & src, ::cv::Mat & dst, const ::cv::Point2f & center, double maxRadius, int flags=9 ){
    ::cvLinearPolar(get_CvMat_ptr(src), get_CvMat_ptr(dst), (CvPoint2D32f)(center), maxRadius, flags);
}

static void cvLogPolar_27c4d18226a6e750886777db97773f4d( ::cv::Mat & src, ::cv::Mat & dst, const ::cv::Point2f & center, double M, int flags=9 ){
    ::cvLogPolar(get_CvMat_ptr(src), get_CvMat_ptr(dst), (CvPoint2D32f)(center), M, flags);
}

static void cvMultiplyAcc_c64c83fc39cb1265f3d1a69d9e600a47( ::cv::Mat & image1, ::cv::Mat & image2, ::cv::Mat & acc, ::cv::Mat mask=cv::Mat() ){
    ::cvMultiplyAcc(get_CvMat_ptr(image1), get_CvMat_ptr(image2), get_CvMat_ptr(acc), get_CvMat_ptr(mask));
}

static boost::python::object cvPointSeqFromMat_ef8459cfef37d715411cf088e0da5576( int seq_kind, ::cv::Mat & mat, ::CvContour * contour_header, ::CvSeqBlock * block ){
    ::CvSeq * result = ::cvPointSeqFromMat(seq_kind, get_CvMat_ptr(mat), contour_header, block);
    typedef bp::with_custodian_and_ward_postcall< 0, 2, bp::with_custodian_and_ward_postcall< 0, 3, bp::return_value_policy< bp::reference_existing_object > > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvSeq * >( result ) );
}

static void cvPyrMeanShiftFiltering_21ec6b7149a6e00a31f1d76aebb9a22b( ::cv::Mat & src, ::cv::Mat & dst, double sp, double sr, int max_level=1, ::CvTermCriteria termcrit=cv::TermCriteria(3, 5, 1.0e+0) ){
    ::cvPyrMeanShiftFiltering(get_CvMat_ptr(src), get_CvMat_ptr(dst), sp, sr, max_level, termcrit);
}

static boost::python::object cvPyrSegmentation_0a5e58f4641f1c9757bb83d3f16f4191( ::cv::Mat & src, ::cv::Mat & dst, ::CvMemStorage * storage, int level, double threshold1, double threshold2 ){
    CvSeq * comp2=(::CvSeq *)0;
    ::cvPyrSegmentation(get_IplImage_ptr(src), get_IplImage_ptr(dst), storage, &comp2, level, threshold1, threshold2);
    typedef bp::with_custodian_and_ward_postcall< 0, 3, bp::return_value_policy< bp::reference_existing_object > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvSeq * >( comp2 ) );
}

static void cvRandArr_7e6e03c94e3a5f654b62b47647889d1d( ::cv::RNG & rng, ::cv::Mat & arr, int dist_type, ::CvScalar param1, ::CvScalar param2 ){
    ::cvRandArr(&rng.state, get_CvMat_ptr(arr), dist_type, param1, param2);
}

static boost::python::object cvRange_073a997114e2c96bbeff2aaa986e76a1( ::cv::Mat & mat, double start, double end ){
    ::CvArr * result = ::cvRange(get_CvMat_ptr(mat), start, end);
    typedef bp::return_self< > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvArr * >( result ) );
}

static void cvReleaseConDensation_f998e5f5422410bd74b2ba960fd05e2c( ::CvConDensation condens ){
    CvConDensation * tmp_condens = reinterpret_cast< CvConDensation * >(& condens);
    ::cvReleaseConDensation(reinterpret_cast< CvConDensation * * >( & tmp_condens ));
}

static void cvReleaseFileStorage_d53aa99c3241294fee03f3f038aa2bba( ::CvFileStorage fs ){
    CvFileStorage * tmp_fs = reinterpret_cast< CvFileStorage * >(& fs);
    ::cvReleaseFileStorage(reinterpret_cast< CvFileStorage * * >( & tmp_fs ));
}

static void cvReleaseMemStorage_6ff4687a489093fb83fd38fb1d920837( ::CvMemStorage storage ){
    CvMemStorage * tmp_storage = reinterpret_cast< CvMemStorage * >(& storage);
    ::cvReleaseMemStorage(reinterpret_cast< CvMemStorage * * >( & tmp_storage ));
}

static void cvReleasePOSITObject_679a5da1d4e28b86fdc9a28aa691c6ef( ::CvPOSITObject posit_object ){
    CvPOSITObject * tmp_posit_object = reinterpret_cast< CvPOSITObject * >(& posit_object);
    ::cvReleasePOSITObject(reinterpret_cast< CvPOSITObject * * >( & tmp_posit_object ));
}

static void cvReleaseStereoGCState_f9448f3f98670de75bac96972e1b9d45( ::CvStereoGCState state ){
    CvStereoGCState * tmp_state = reinterpret_cast< CvStereoGCState * >(& state);
    ::cvReleaseStereoGCState(reinterpret_cast< CvStereoGCState * * >( & tmp_state ));
}

static void cvReprojectImageTo3D_4ca87cd67ba33150d51d345f21a24447( ::cv::Mat & disparityImage, ::cv::Mat & _3dImage, ::cv::Mat & Q, int handleMissingValues=0 ){
    ::cvReprojectImageTo3D(get_CvMat_ptr(disparityImage), get_CvMat_ptr(_3dImage), get_CvMat_ptr(Q), handleMissingValues);
}

static void cvRunningAvg_16515bd00db4472140aa21554e25bbc7( ::cv::Mat & image, ::cv::Mat & acc, double alpha, ::cv::Mat mask=cv::Mat() ){
    ::cvRunningAvg(get_CvMat_ptr(image), get_CvMat_ptr(acc), alpha, get_CvMat_ptr(mask));
}

static boost::python::object cvSURFPoint_c0d89cc1fa2a754074aaa768acb95f48( const ::cv::Point2f & pt, int laplacian, int size, float dir=0, float hessian=0 ){
    ::CvSURFPoint result = ::cvSURFPoint((CvPoint2D32f)(pt), laplacian, size, dir, hessian);
    return bp::object( result );
}

static boost::python::object cvSampleLine_9eb7a74db955c3538aef5be3e7392fc5( ::cv::Mat & image, ::CvPoint pt1, ::CvPoint pt2, void * buffer, int connectivity=8 ){
    int result = ::cvSampleLine(get_CvMat_ptr(image), pt1, pt2, buffer, connectivity);
    return bp::object( result );
}

static boost::python::object cvSegmentImage_7b95313fd97ffe28d678124b5aa0a301( ::cv::Mat & srcarr, ::cv::Mat & dstarr, double canny_threshold, double ffill_threshold, ::CvMemStorage * storage ){
    ::CvSeq * result = ::cvSegmentImage(get_CvMat_ptr(srcarr), get_CvMat_ptr(dstarr), canny_threshold, ffill_threshold, storage);
    typedef bp::with_custodian_and_ward_postcall< 0, 5, bp::return_value_policy< bp::reference_existing_object > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvSeq * >( result ) );
}

static boost::python::object cvSegmentMotion_ed831c1d8f816ea759222aec4d41f1f0( ::cv::Mat & mhi, ::cv::Mat & seg_mask, ::CvMemStorage * storage, double timestamp, double seg_thresh ){
    ::CvSeq * result = ::cvSegmentMotion(get_CvMat_ptr(mhi), get_CvMat_ptr(seg_mask), storage, timestamp, seg_thresh);
    typedef bp::with_custodian_and_ward_postcall< 0, 3, bp::return_value_policy< bp::reference_existing_object > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvSeq * >( result ) );
}

static void cvSeqInsertSlice_870f54253b0103a244c6ac596f2820c4( ::CvSeq * seq, int before_index, ::cv::Mat & from_arr ){
    ::cvSeqInsertSlice(seq, before_index, get_CvMat_ptr(from_arr));
}

static boost::python::object cvSetMouseCallback_c212defec0903d7de57c5c0b0ee9b03d( char const * window_name, boost::python::object on_mouse, boost::python::object param=bp::object() ){
    boost::python::tuple z_on_mouse= bp::make_tuple(on_mouse, param);
    ::cvSetMouseCallback(window_name, sdMouseCallback, (void *)(z_on_mouse.ptr()));
    typedef bp::return_value_policy< bp::reference_existing_object > call_policies_t;
    return bp::object( z_on_mouse );
}

static void cvSmooth_77e0c983f4273497b4a61c0a6dcda04f( ::cv::Mat & src, ::cv::Mat & dst, int smoothtype=2, int size1=3, int size2=0, double sigma1=0, double sigma2=0 ){
    ::cvSmooth(get_CvMat_ptr(src), get_CvMat_ptr(dst), smoothtype, size1, size2, sigma1, sigma2);
}

static boost::python::object cvSolveCubic_97d0ac3b0fc6ba46cd5b5f2eaea79583( ::cv::Mat & coeffs, ::cv::Mat & roots ){
    int result = ::cvSolveCubic(get_CvMat_ptr(coeffs), get_CvMat_ptr(roots));
    return bp::object( result );
}

static void cvSolvePoly_a7fe4b7abe368e2e780716aa49dc8f82( ::cv::Mat & coeffs, ::cv::Mat & roots2, int maxiter=20, int fig=100 ){
    ::cvSolvePoly(get_CvMat_ptr(coeffs), get_CvMat_ptr(roots2), maxiter, fig);
}

static void cvSquareAcc_df8ad076f822a2856ccecbbdf6a2b2b0( ::cv::Mat & image, ::cv::Mat & sqsum, ::cv::Mat mask=cv::Mat() ){
    ::cvSquareAcc(get_CvMat_ptr(image), get_CvMat_ptr(sqsum), get_CvMat_ptr(mask));
}

static boost::python::object cvStartFindContours_1914ce1dccb0d5710ebdf49d4c3d96cc( ::cv::Mat & image, ::CvMemStorage * storage, int header_size=88u, int mode=1, int method=2, ::CvPoint offset=cv::Point(0, 0) ){
    ::CvContourScanner result = ::cvStartFindContours(get_CvMat_ptr(image), storage, header_size, mode, method, offset);
    typedef bp::with_ownershiplevel_postcall< 1, bp::with_custodian_and_ward_postcall< 0, 2, bp::return_value_policy< bp::reference_existing_object > > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvContourScanner >( result ) );
}

static void cvStartNextStream_db71e53dfa9475145f4487a80d5d8bf2( ::cv::FileStorage & fs ){
    ::cvStartNextStream(fs.fs);
}

static void cvStartWriteStruct_e7e2128639c3a858bdb332c89468a8e0( ::cv::FileStorage & fs, char const * name, int struct_flags, char const * type_name=0, ::CvAttrList attributes=cvAttrList(0u, 0u) ){
    ::cvStartWriteStruct(fs.fs, name, struct_flags, type_name, attributes);
}

static boost::python::tuple cvSubdiv2DLocate_1df86dbc29fc9de6df2bbdb2196d6db3( ::CvSubdiv2D * subdiv, const ::cv::Point2f & pt, ::CvSubdiv2DEdge * edge ){
    CvSubdiv2DPoint * vertex2=(::CvSubdiv2DPoint *)0;
    ::CvSubdiv2DPointLocation result = ::cvSubdiv2DLocate(subdiv, (CvPoint2D32f)(pt), edge, &vertex2);
    return bp::make_tuple( result, vertex2 );
}

static boost::python::object cvSubdivDelaunay2DInsert_0d66ff0b2bc8918d0793f968404f1cb2( ::CvSubdiv2D * subdiv, const ::cv::Point2f & pt ){
    ::CvSubdiv2DPoint * result = ::cvSubdivDelaunay2DInsert(subdiv, (CvPoint2D32f)(pt));
    typedef bp::with_custodian_and_ward_postcall< 0, 1, bp::return_value_policy< bp::reference_existing_object > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvSubdiv2DPoint * >( result ) );
}

static boost::python::object cvTriangleArea_727599fdabcae9fb78274a766e9dac94( const ::cv::Point2f & a, const ::cv::Point2f & b, const ::cv::Point2f & c ){
    double result = ::cvTriangleArea((CvPoint2D32f)(a), (CvPoint2D32f)(b), (CvPoint2D32f)(c));
    return bp::object( result );
}

static void cvTriangulatePoints_eb948ff6300aa4ebf4fad0ec7d6d4e78( ::cv::Mat & projMatr1, ::cv::Mat & projMatr2, ::cv::Mat & projPoints1, ::cv::Mat & projPoints2, ::cv::Mat & points4D ){
    ::cvTriangulatePoints(get_CvMat_ptr(projMatr1), get_CvMat_ptr(projMatr2), get_CvMat_ptr(projPoints1), get_CvMat_ptr(projPoints2), get_CvMat_ptr(points4D));
}

static boost::python::object cvTypeOf_4e7bd20b082b35b68253f04b04f578ce( ::CvArr * struct_ptr ){
    ::CvTypeInfo * result = ::cvTypeOf(reinterpret_cast< void const * >( struct_ptr ));
    typedef bp::return_value_policy< bp::reference_existing_object > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvTypeInfo * >( result ) );
}

static void cvUpdateMotionHistory_fb635b1eb55f77d94f46a70f41eac0b3( ::cv::Mat & silhouette, ::cv::Mat & mhi, double timestamp, double duration ){
    ::cvUpdateMotionHistory(get_CvMat_ptr(silhouette), get_CvMat_ptr(mhi), timestamp, duration);
}

static void cvWrite_00335cc764e72fb9408450c10fffab4a( ::cv::FileStorage & fs, char const * name, const char * ptr, ::CvAttrList attributes=cvAttrList(0u, 0u) ){
    ::cvWrite(fs.fs, name, ((void const *) ptr), attributes);
}

static void cvWriteComment_3e89473031f5fbea0ed6232440721138( ::cv::FileStorage & fs, char const * comment, int eol_comment ){
    ::cvWriteComment(fs.fs, comment, eol_comment);
}

static void cvWriteFileNode_4df1ea107367e738fdd6f88f15146fb9( ::cv::FileStorage & fs, char const * new_node_name, ::cv::FileNode const & node, int embed ){
    ::cvWriteFileNode(fs.fs, new_node_name, *(node), embed);
}

static void drawContours_03a5aed7ca57b253d8b3346ee2f05f74( ::cv::Mat & image, bp::list const & contours, int contourIdx, ::cv::Scalar const & color, int thickness=1, int lineType=8, cv::Mat const & hierarchy=convert_from_vector_of_T_to_Mat(std::vector<cv::Vec4i>()), int maxLevel=2147483647, ::cv::Point offset=cv::Point_<int>() ){
    ::std::vector< std::vector< cv::Point_<int> > > contours2;
    ::std::vector< cv::Vec<int, 4> > hierarchy2;
    convert_from_object_to_T(contours, contours2);
    convert_from_Mat_to_vector_of_T(hierarchy, hierarchy2);
    ::cv::drawContours(image, contours2, contourIdx, color, thickness, lineType, hierarchy2, maxLevel, offset);
}

static void ellipse2Poly_a1937ebf152fa736fc27822db2e0081a( ::cv::Point center, ::cv::Size axes, int angle, int arcStart, int arcEnd, int delta, cv::Mat & pts ){
    ::std::vector< cv::Point_<int> > pts2;
    convert_from_Mat_to_vector_of_T(pts, pts2);
    ::cv::ellipse2Poly(center, axes, angle, arcStart, arcEnd, delta, pts2);
    convert_from_vector_of_T_to_Mat(pts2, pts);
}

static boost::python::object estimateAffine3D_fd3dca5e5fd5d2ce4664db813a2c08bf( ::cv::Mat const & from, ::cv::Mat const & to, ::cv::Mat & out, cv::Mat & outliers, double param1=3.0e+0, double param2=9.89999999999999991118215802998747676610946655273e-1 ){
    ::std::vector< unsigned char > outliers2;
    convert_from_Mat_to_vector_of_T(outliers, outliers2);
    int result = ::cv::estimateAffine3D(from, to, out, outliers2, param1, param2);
    convert_from_vector_of_T_to_Mat(outliers2, outliers);
    return bp::object( result );
}

static void fillConvexPoly_1312287b0cded13c02c57cc3d8ebf4b4( ::cv::Mat & img, cv::Mat const & pts, ::cv::Scalar const & color, int lineType=8, int shift=0 ){
    int pts2;
    cv::Point_<int> * pts3;
    convert_from_Mat_to_array_of_T(pts, pts3, pts2);
    ::cv::fillConvexPoly(img, pts3, pts2, color, lineType, shift);
}

static void fillPoly_e862cfcf1208f193efcd2bec59b744ec( ::cv::Mat & img, bp::object const & pts, ::cv::Scalar const & color, int lineType=8, int shift=0, ::cv::Point offset=cv::Point_<int>() ){
    bool b_pts = (pts.ptr() != Py_None);
    std::vector<std::vector< ::cv::Point_<int> > > arr_pts;
    if(b_pts) convert_from_object_to_T(pts, arr_pts);
    int n0_pts = b_pts? arr_pts.size(): 0;
    
    std::vector< ::cv::Point_<int> * > buf_pts;
    std::vector<int> n1_pts;
    if(b_pts)
    {
        buf_pts.resize(n0_pts);
        n1_pts.resize(n0_pts);
        for(int i_pts = 0; i_pts < n0_pts; ++i_pts)
        {
            buf_pts[i_pts] = &arr_pts[i_pts][0];
            n1_pts[i_pts] = arr_pts[i_pts].size();
        }
    }
        
    ::cv::fillPoly(img, (::cv::Point const * *) &buf_pts[0], &n1_pts[0], n0_pts, color, lineType, shift, offset);
}

static boost::python::object find4QuadCornerSubpix_ca00fc1537bfc5b612545bbb0796233b( ::cv::Mat const & img, cv::Mat & corners, ::cv::Size region_size ){
    ::std::vector< cv::Point_<float> > corners2;
    convert_from_Mat_to_vector_of_T(corners, corners2);
    bool result = ::cv::find4QuadCornerSubpix(img, corners2, region_size);
    convert_from_vector_of_T_to_Mat(corners2, corners);
    return bp::object( result );
}

static boost::python::tuple findChessboardCorners_dbf15a4ace0e613206118382aa1793ea( ::cv::Mat const & image, ::cv::Size patternSize, int flags=3 ){
    ::std::vector< cv::Point_<float> > corners2;
    cv::Mat corners3;
    bool result = ::cv::findChessboardCorners(image, patternSize, corners2, flags);
    convert_from_vector_of_T_to_Mat(corners2, corners3);
    return bp::make_tuple( result, corners3 );
}

static boost::python::object findContours_664763de08e36b95bc7d4fcebc9ccbf7( ::cv::Mat & image, int mode, int method, ::cv::Point offset=cv::Point_<int>() ){
    ::std::vector< std::vector< cv::Point_<int> > > contours2;
    bp::list contours3;
    ::cv::findContours(image, contours2, mode, method, offset);
    convert_from_T_to_object(contours2, contours3);
    return bp::object( contours3 );
}

static boost::python::tuple findContours_369c42510a246d95804d68f7fdfbd8aa( ::cv::Mat & image, int mode, int method, ::cv::Point offset=cv::Point_<int>() ){
    ::std::vector< std::vector< cv::Point_<int> > > contours2;
    bp::list contours3;
    ::std::vector< cv::Vec<int, 4> > hierarchy2;
    cv::Mat hierarchy3;
    ::cv::findContours(image, contours2, hierarchy2, mode, method, offset);
    convert_from_T_to_object(contours2, contours3);
    convert_from_vector_of_T_to_Mat(hierarchy2, hierarchy3);
    return bp::make_tuple( contours3, hierarchy3 );
}

static boost::python::tuple findFundamentalMat_4b8947da99452ee36abb2b044e941f4a( ::cv::Mat const & points1, ::cv::Mat const & points2, int method=int(::cv::FM_RANSAC), double param1=3.0e+0, double param2=9.89999999999999991118215802998747676610946655273e-1 ){
    ::std::vector< unsigned char > mask2;
    cv::Mat mask3;
    ::cv::Mat result = ::cv::findFundamentalMat(points1, points2, mask2, method, param1, param2);
    convert_from_vector_of_T_to_Mat(mask2, mask3);
    return bp::make_tuple( result, mask3 );
}

static boost::python::tuple findHomography_43999ba4bb258d7c74f144c8915f1665( ::cv::Mat const & srcPoints, ::cv::Mat const & dstPoints, int method=0, double ransacReprojThreshold=0 ){
    ::std::vector< unsigned char > mask2;
    cv::Mat mask3;
    ::cv::Mat result = ::cv::findHomography(srcPoints, dstPoints, mask2, method, ransacReprojThreshold);
    convert_from_vector_of_T_to_Mat(mask2, mask3);
    return bp::make_tuple( result, mask3 );
}

static boost::python::tuple floodFill_a833ccdf7b45572779d5c63d9adc2b15( ::cv::Mat & image, ::cv::Mat & mask, ::cv::Point seedPoint, ::cv::Scalar newVal, ::cv::Scalar loDiff=cv::Scalar_<double>(), ::cv::Scalar upDiff=cv::Scalar_<double>(), int flags=4 ){
    cv::Rect_<int> rect2;
    int result = ::cv::floodFill(image, mask, seedPoint, newVal, &rect2, loDiff, upDiff, flags);
    return bp::make_tuple( result, rect2 );
}

static boost::python::tuple floodFill_75a8a8f3e3e22b4d281bb304a7881151( ::cv::Mat & image, ::cv::Point seedPoint, ::cv::Scalar newVal, ::cv::Scalar loDiff=cv::Scalar_<double>(), ::cv::Scalar upDiff=cv::Scalar_<double>(), int flags=4 ){
    cv::Rect_<int> rect2;
    int result = ::cv::floodFill(image, seedPoint, newVal, &rect2, loDiff, upDiff, flags);
    return bp::make_tuple( result, rect2 );
}

static boost::python::object getAffineTransform_aa493630c3e4efe1ff49141fe5060922( cv::Mat const & src, cv::Mat const & dst ){
    int src2;
    cv::Point_<float> * src3;
    int dst2;
    cv::Point_<float> * dst3;
    convert_from_Mat_to_array_of_T(src, src3, src2);
    convert_from_Mat_to_array_of_T(dst, dst3, dst2);
    ::cv::Mat result = ::cv::getAffineTransform(src3, dst3);
    return bp::object( result );
}

static boost::python::tuple getOptimalNewCameraMatrix_e98b8ab28b52edfb3a210046fcf0527e( ::cv::Mat const & cameraMatrix, ::cv::Mat const & distCoeffs, ::cv::Size imageSize, double alpha, ::cv::Size newImgSize=cv::Size_<int>() ){
    cv::Rect_<int> validPixROI2;
    ::cv::Mat result = ::cv::getOptimalNewCameraMatrix(cameraMatrix, distCoeffs, imageSize, alpha, newImgSize, &validPixROI2);
    return bp::make_tuple( result, validPixROI2 );
}

static boost::python::object getPerspectiveTransform_c06a0392152cb20f6b57ae1ff2ac2c11( cv::Mat const & src, cv::Mat const & dst ){
    int src2;
    cv::Point_<float> * src3;
    int dst2;
    cv::Point_<float> * dst3;
    convert_from_Mat_to_array_of_T(src, src3, src2);
    convert_from_Mat_to_array_of_T(dst, dst3, dst2);
    ::cv::Mat result = ::cv::getPerspectiveTransform(src3, dst3);
    return bp::object( result );
}

static boost::python::tuple getTextSize_efe6452b14ca0fcca5a50ca33199f5e7( ::std::string const & text, int fontFace, double fontScale, int thickness ){
    int baseLine2;
    ::cv::Size result = ::cv::getTextSize(text, fontFace, fontScale, thickness, &baseLine2);
    return bp::make_tuple( result, baseLine2 );
}

static boost::python::object goodFeaturesToTrack_a887e3eb7b667339b1ac0c1a02f5735c( ::cv::Mat const & image, int maxCorners, double qualityLevel, double minDistance, ::cv::Mat const & mask=cv::Mat(), int blockSize=3, bool useHarrisDetector=false, double k=4.00000000000000008326672684688674053177237510681e-2 ){
    ::std::vector< cv::Point_<float> > corners2;
    cv::Mat corners3;
    ::cv::goodFeaturesToTrack(image, corners2, maxCorners, qualityLevel, minDistance, mask, blockSize, useHarrisDetector, k);
    convert_from_vector_of_T_to_Mat(corners2, corners3);
    return bp::object( corners3 );
}

static void groupRectangles_d5f10e6823ff191659b8e372e1acdb8b( cv::Mat & rectList, cv::Mat & weights, int groupThreshold, double eps=2.00000000000000011102230246251565404236316680908e-1 ){
    ::std::vector< cv::Rect_<int> > rectList2;
    ::std::vector< int > weights2;
    convert_from_Mat_to_vector_of_T(rectList, rectList2);
    convert_from_Mat_to_vector_of_T(weights, weights2);
    ::cv::groupRectangles(rectList2, weights2, groupThreshold, eps);
    convert_from_vector_of_T_to_Mat(rectList2, rectList);
    convert_from_vector_of_T_to_Mat(weights2, weights);
}

static void groupRectangles_daddb1eb144574c44042d3cef39f8656( cv::Mat & rectList, int groupThreshold, double eps=2.00000000000000011102230246251565404236316680908e-1 ){
    ::std::vector< cv::Rect_<int> > rectList2;
    convert_from_Mat_to_vector_of_T(rectList, rectList2);
    ::cv::groupRectangles(rectList2, groupThreshold, eps);
    convert_from_vector_of_T_to_Mat(rectList2, rectList);
}

static boost::python::tuple imencode_7058867f40db2ceceebdc74b4943c841( ::std::string const & ext, ::cv::Mat const & img, cv::Mat const & params=convert_from_vector_of_T_to_Mat(std::vector<int>()) ){
    ::std::vector< unsigned char > buf2;
    cv::Mat buf3;
    ::std::vector< int > params2;
    convert_from_Mat_to_vector_of_T(params, params2);
    bool result = ::cv::imencode(ext, img, buf2, params2);
    convert_from_vector_of_T_to_Mat(buf2, buf3);
    return bp::make_tuple( result, buf3 );
}

static boost::python::object imwrite_08123c4d4c07e7af51577328378c9683( ::std::string const & filename, ::cv::Mat const & img, cv::Mat const & params=convert_from_vector_of_T_to_Mat(std::vector<int>()) ){
    ::std::vector< int > params2;
    convert_from_Mat_to_vector_of_T(params, params2);
    bool result = ::cv::imwrite(filename, img, params2);
    return bp::object( result );
}

static boost::python::object initCameraMatrix2D_a63e0813c9e7ddf60786347e47acca95( bp::list const & objectPoints, bp::list const & imagePoints, ::cv::Size imageSize, double aspectRatio=1.0e+0 ){
    ::std::vector< std::vector< cv::Point3_<float> > > objectPoints2;
    ::std::vector< std::vector< cv::Point_<float> > > imagePoints2;
    convert_from_object_to_T(objectPoints, objectPoints2);
    convert_from_object_to_T(imagePoints, imagePoints2);
    ::cv::Mat result = ::cv::initCameraMatrix2D(objectPoints2, imagePoints2, imageSize, aspectRatio);
    return bp::object( result );
}

static boost::python::tuple kmeans_7acc1faebc4e430dbd210d93113e85c9( ::cv::Mat const & data, int K, ::cv::Mat & best_labels, ::cv::TermCriteria criteria, int attempts, int flags ){
    cv::Mat centers2;
    double result = ::cv::kmeans(data, K, best_labels, criteria, attempts, flags, &centers2);
    return bp::make_tuple( result, centers2 );
}

static void merge_181a45f787822fd2b5f0d1797cf24cb9( bp::list const & mv, ::cv::MatND & dst ){
    ::std::vector< cv::MatND > mv2;
    convert_from_object_to_T(mv, mv2);
    ::cv::merge(mv2, dst);
}

static void merge_d67e402c11e8166727b306edf7cce556( bp::list const & mv, ::cv::Mat & dst ){
    ::std::vector< cv::Mat > mv2;
    convert_from_object_to_T(mv, mv2);
    ::cv::merge(mv2, dst);
}

static boost::python::tuple minMaxLoc_5898fb91ebb58d1df6569148b5c62cce( ::cv::SparseMat const & a ){
    double minVal2;
    double maxVal2;
    int minIdx2;
    int maxIdx2;
    ::cv::minMaxLoc(a, &minVal2, &maxVal2, &minIdx2, &maxIdx2);
    return bp::make_tuple( minVal2, maxVal2, minIdx2, maxIdx2 );
}

static boost::python::tuple minMaxLoc_794fc6a6cce59bf895fdda1a015e64b1( ::cv::MatND const & a, ::cv::MatND const & mask=cv::MatND() ){
    double minVal2;
    double maxVal2;
    int minIdx2;
    int maxIdx2;
    ::cv::minMaxLoc(a, &minVal2, &maxVal2, &minIdx2, &maxIdx2, mask);
    return bp::make_tuple( minVal2, maxVal2, minIdx2, maxIdx2 );
}

static boost::python::tuple minMaxLoc_35f2a2e80fcf305e891ee746d58be725( ::cv::Mat const & a, ::cv::Mat const & mask=cv::Mat() ){
    double minVal2;
    double maxVal2;
    cv::Point_<int> minLoc2;
    cv::Point_<int> maxLoc2;
    ::cv::minMaxLoc(a, &minVal2, &maxVal2, &minLoc2, &maxLoc2, mask);
    return bp::make_tuple( minVal2, maxVal2, minLoc2, maxLoc2 );
}

static void mixChannels_c8fa9614f4fb5a79f84423883d102a9e( bp::list const & src, bp::list & dst, cv::Mat const & fromTo, int npairs ){
    ::std::vector< cv::MatND > src2;
    ::std::vector< cv::MatND > dst2;
    int fromTo2;
    int * fromTo3;
    convert_from_object_to_T(src, src2);
    convert_from_object_to_T(dst, dst2);
    convert_from_Mat_to_array_of_T(fromTo, fromTo3, fromTo2);
    ::cv::mixChannels(src2, dst2, fromTo3, npairs);
    convert_from_T_to_object(dst2, dst);
}

static void mixChannels_269d2fa250748779c49641b632451e5f( bp::list const & src, bp::list & dst, cv::Mat const & fromTo, int npairs ){
    ::std::vector< cv::Mat > src2;
    ::std::vector< cv::Mat > dst2;
    int fromTo2;
    int * fromTo3;
    convert_from_object_to_T(src, src2);
    convert_from_object_to_T(dst, dst2);
    convert_from_Mat_to_array_of_T(fromTo, fromTo3, fromTo2);
    ::cv::mixChannels(src2, dst2, fromTo3, npairs);
    convert_from_T_to_object(dst2, dst);
}

static void polylines_4b2b9aca4a0ee1864678eae6b982fcc0( ::cv::Mat & img, bp::object const & pts, bool isClosed, ::cv::Scalar const & color, int thickness=1, int lineType=8, int shift=0 ){
    bool b_pts = (pts.ptr() != Py_None);
    std::vector<std::vector< ::cv::Point_<int> > > arr_pts;
    if(b_pts) convert_from_object_to_T(pts, arr_pts);
    int n0_pts = b_pts? arr_pts.size(): 0;
    
    std::vector< ::cv::Point_<int> * > buf_pts;
    std::vector<int> n1_pts;
    if(b_pts)
    {
        buf_pts.resize(n0_pts);
        n1_pts.resize(n0_pts);
        for(int i_pts = 0; i_pts < n0_pts; ++i_pts)
        {
            buf_pts[i_pts] = &arr_pts[i_pts][0];
            n1_pts[i_pts] = arr_pts[i_pts].size();
        }
    }
        
    ::cv::polylines(img, (::cv::Point const * *) &buf_pts[0], &n1_pts[0], n0_pts, isClosed, color, thickness, lineType, shift);
}

static boost::python::object projectPoints_c3cbd5f3e0c4a976b617302062632da4( ::cv::Mat const & objectPoints, ::cv::Mat const & rvec, ::cv::Mat const & tvec, ::cv::Mat const & cameraMatrix, ::cv::Mat const & distCoeffs, ::cv::Mat & dpdrot, ::cv::Mat & dpdt, ::cv::Mat & dpdf, ::cv::Mat & dpdc, ::cv::Mat & dpddist, double aspectRatio=0 ){
    ::std::vector< cv::Point_<float> > imagePoints2;
    cv::Mat imagePoints3;
    ::cv::projectPoints(objectPoints, rvec, tvec, cameraMatrix, distCoeffs, imagePoints2, dpdrot, dpdt, dpdf, dpdc, dpddist, aspectRatio);
    convert_from_vector_of_T_to_Mat(imagePoints2, imagePoints3);
    return bp::object( imagePoints3 );
}

static boost::python::object projectPoints_ce9cea7b4fadb5986d2a47a4d012fac0( ::cv::Mat const & objectPoints, ::cv::Mat const & rvec, ::cv::Mat const & tvec, ::cv::Mat const & cameraMatrix, ::cv::Mat const & distCoeffs ){
    ::std::vector< cv::Point_<float> > imagePoints2;
    cv::Mat imagePoints3;
    ::cv::projectPoints(objectPoints, rvec, tvec, cameraMatrix, distCoeffs, imagePoints2);
    convert_from_vector_of_T_to_Mat(imagePoints2, imagePoints3);
    return bp::object( imagePoints3 );
}

static boost::python::object read_19f776a07d0494421b17575379bc2106( ::cv::FileNode const & node ){
    ::std::vector< cv::KeyPoint > keypoints2;
    bp::list keypoints3;
    ::cv::read(node, keypoints2);
    convert_from_T_to_object(keypoints2, keypoints3);
    return bp::object( keypoints3 );
}

static boost::python::object read_70c5e2668ef6bb953f654143837a7095( ::cv::FileNode const & node, ::cv::SparseMat const & default_mat=cv::SparseMat() ){
    cv::SparseMat mat2;
    ::cv::read(node, mat2, default_mat);
    return bp::object( mat2 );
}

static boost::python::object read_fcf3602693271e7c8a4e15ff65aede4c( ::cv::FileNode const & node, ::cv::MatND const & default_mat=cv::MatND() ){
    cv::MatND mat2;
    ::cv::read(node, mat2, default_mat);
    return bp::object( mat2 );
}

static boost::python::object read_fd962997898e5b5f59cbef9efc942bcd( ::cv::FileNode const & node, ::cv::Mat const & default_mat=cv::Mat() ){
    cv::Mat mat2;
    ::cv::read(node, mat2, default_mat);
    return bp::object( mat2 );
}

static boost::python::object read_31e582223a7f98972af6d67b7558569e( ::cv::FileNode const & node, ::std::string const & default_value ){
    std::basic_string<char,std::char_traits<char>,std::allocator<char> > value2;
    ::cv::read(node, value2, default_value);
    return bp::object( value2 );
}

static boost::python::object read_9a054275260bdb7b0741c9b9e8cf5aae( ::cv::FileNode const & node, double default_value ){
    double value2;
    ::cv::read(node, value2, default_value);
    return bp::object( value2 );
}

static boost::python::object read_9b06f36c44aa0d63d7f9f36cebc8d25f( ::cv::FileNode const & node, float default_value ){
    float value2;
    ::cv::read(node, value2, default_value);
    return bp::object( value2 );
}

static boost::python::object read_29c2b389d482b9f6d13cfbe5d7264926( ::cv::FileNode const & node, int default_value ){
    int value2;
    ::cv::read(node, value2, default_value);
    return bp::object( value2 );
}

static boost::python::object read_62eac78db6563e1e714f1e282bf790db( ::cv::FileNode const & node, short int default_value ){
    short int value2;
    ::cv::read(node, value2, default_value);
    return bp::object( value2 );
}

static boost::python::object read_81b0a1f4d595a311c77148001bd0046d( ::cv::FileNode const & node, ::ushort default_value ){
    short unsigned int value2;
    ::cv::read(node, value2, default_value);
    return bp::object( value2 );
}

static boost::python::object read_b68923bb48bf8de904fed0f0570414f5( ::cv::FileNode const & node, ::schar default_value ){
    signed char value2;
    ::cv::read(node, value2, default_value);
    return bp::object( value2 );
}

static boost::python::object read_e3dbdb6033985682cd13b98ac06df84e( ::cv::FileNode const & node, ::uchar default_value ){
    unsigned char value2;
    ::cv::read(node, value2, default_value);
    return bp::object( value2 );
}

static boost::python::object read_2ba57a356ec17a70685f21fbad5a9438( ::cv::FileNode const & node, bool default_value ){
    bool value2;
    ::cv::read(node, value2, default_value);
    return bp::object( value2 );
}

static void split_12da852b2108a4c5223916b7b3caf48f( ::cv::MatND const & m, bp::list & mv ){
    ::std::vector< cv::MatND > mv2;
    convert_from_object_to_T(mv, mv2);
    ::cv::split(m, mv2);
    convert_from_T_to_object(mv2, mv);
}

static void split_5e87cb7b08d019948a672b023e58e480( ::cv::Mat const & m, bp::list & mv ){
    ::std::vector< cv::Mat > mv2;
    convert_from_object_to_T(mv, mv2);
    ::cv::split(m, mv2);
    convert_from_T_to_object(mv2, mv);
}

static boost::python::object stereoCalibrate_14726b7172922289400130b4861f4a12( bp::list const & objectPoints, bp::list const & imagePoints1, bp::list const & imagePoints2, ::cv::Mat & cameraMatrix1, ::cv::Mat & distCoeffs1, ::cv::Mat & cameraMatrix2, ::cv::Mat & distCoeffs2, ::cv::Size imageSize, ::cv::Mat & R, ::cv::Mat & T, ::cv::Mat & E, ::cv::Mat & F, ::cv::TermCriteria criteria=cv::TermCriteria(3, 30, 9.99999999999999954748111825886258685613938723691e-7), int flags=int(::cv::CALIB_FIX_INTRINSIC) ){
    ::std::vector< std::vector< cv::Point3_<float> > > objectPoints2;
    ::std::vector< std::vector< cv::Point_<float> > > imagePoints12;
    ::std::vector< std::vector< cv::Point_<float> > > imagePoints22;
    convert_from_object_to_T(objectPoints, objectPoints2);
    convert_from_object_to_T(imagePoints1, imagePoints12);
    convert_from_object_to_T(imagePoints2, imagePoints22);
    double result = ::cv::stereoCalibrate(objectPoints2, imagePoints12, imagePoints22, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T, E, F, criteria, flags);
    return bp::object( result );
}

static boost::python::tuple stereoRectify_82767028a891c6d71aa41b85e724aef7( ::cv::Mat const & cameraMatrix1, ::cv::Mat const & distCoeffs1, ::cv::Mat const & cameraMatrix2, ::cv::Mat const & distCoeffs2, ::cv::Size imageSize, ::cv::Mat const & R, ::cv::Mat const & T, ::cv::Mat & R1, ::cv::Mat & R2, ::cv::Mat & P1, ::cv::Mat & P2, ::cv::Mat & Q, double alpha, ::cv::Size newImageSize=cv::Size_<int>(), int flags=int(::cv::CALIB_ZERO_DISPARITY) ){
    cv::Rect_<int> validPixROI12;
    cv::Rect_<int> validPixROI22;
    ::cv::stereoRectify(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T, R1, R2, P1, P2, Q, alpha, newImageSize, &validPixROI12, &validPixROI22, flags);
    return bp::make_tuple( validPixROI12, validPixROI22 );
}

static boost::python::object undistortPoints_e5fdbe55500ffb118c2a9845da49f34b( ::cv::Mat const & src, ::cv::Mat const & cameraMatrix, ::cv::Mat const & distCoeffs, ::cv::Mat const & R=cv::Mat(), ::cv::Mat const & P=cv::Mat() ){
    ::std::vector< cv::Point_<float> > dst2;
    cv::Mat dst3;
    ::cv::undistortPoints(src, dst2, cameraMatrix, distCoeffs, R, P);
    convert_from_vector_of_T_to_Mat(dst2, dst3);
    return bp::object( dst3 );
}

static void write_df76e3ba45561ddd23c917a610929778( ::cv::FileStorage & fs, ::std::string const & name, bp::list const & keypoints ){
    ::std::vector< cv::KeyPoint > keypoints2;
    convert_from_object_to_T(keypoints, keypoints2);
    ::cv::write(fs, name, keypoints2);
}

struct CvRNG_to_python
{
    static PyObject* convert(CvRNG const& x)
    {
        return bp::incref(bp::object(cv::RNG(x)).ptr());
    }
};

static void sdSnakeImage( cv::Mat const & image, cv::Mat const & points, bp::object const & alpha, bp::object const & beta, bp::object const & gamma, int coeff_usage, cv::Size const & win, cv::TermCriteria const & criteria, int calc_gradient=1 ){
    char s[500];
    float alpha2, beta2, gamma2;
    std::vector<float> alpha3, beta3, gamma3;
    
    cv::Point *points2; int points2_len; convert_from_Mat_to_array_of_T(points, points2, points2_len);
    
    IplImage img = image;
    
    switch (coeff_usage)
    {
    case CV_VALUE:
        alpha2 = (float) bp::extract<float>(alpha);
        beta2 = (float) bp::extract<float>(beta);
        gamma2 = (float) bp::extract<float>(gamma);
        ::cvSnakeImage(&img, (CvPoint *)points2, points2_len, &alpha2, &beta2, &gamma2, coeff_usage, (CvSize)win, (CvTermCriteria)criteria, calc_gradient);
        break;
    case CV_ARRAY:
        convert_from_object_to_T(alpha, alpha3);
        convert_from_object_to_T(beta, beta3);
        convert_from_object_to_T(gamma, gamma3);
        ::cvSnakeImage(&img, (CvPoint *)points2, points2_len, &alpha3[0], &beta3[0], &gamma3[0], coeff_usage, (CvSize)win, (CvTermCriteria)criteria, calc_gradient);
        break;
    default:
        sprintf(s, "coeff_usage only takes either CV_VALUE or CV_ARRAY as value, %d was given.", coeff_usage);
        PyErr_SetString(PyExc_ValueError, s);
        throw bp::error_already_set(); 
    }
}

BOOST_PYTHON_MODULE(pyopencvext){
    register_enumerations();

    register_CvANN_MLP_TrainParams_class();

    register_CvStatModel_class();

    register_Mat_class();

    register_CvANN_MLP_class();

    register_CvAdaptiveSkinDetector_class();

    register_CvAttrList_class();

    register_CvAvgComp_class();

    register_CvBlob_class();

    register_CvBlobSeq_class();

    register_CvBlobTrack_class();

    register_CvBlobTrackSeq_class();

    register_CvDTreeParams_class();

    register_CvBoostParams_class();

    register_CvSlice_class();

    register_CvBoost_class();

    register_CvDTreeSplit_class();

    register_CvDTree_class();

    register_CvBoostTree_class();

    register_CvBox2D_class();

    register_CvCamShiftTracker_class();

    register_CvChain_class();

    register_CvChainPtReader_class();

    register_CvConDensation_class();

    register_CvConnectedComp_class();

    register_CvContour_class();

    register_CvContourTree_class();

    register_CvConvexityDefect_class();

    register_CvDTreeTrainData_class();

    register_CvDefParam_class();

    register_CvDetectedBlob_class();

    register_CvTermCriteria_class();

    register_CvEMParams_class();

    register_CvEM_class();

    register_CvRTParams_class();

    register_CvRTrees_class();

    register_CvERTrees_class();

    register_CvFeatureTree_class();

    register_CvForestTree_class();

    register_CvForestERTree_class();

    register_CvFuzzyController_class();

    register_CvFuzzyCurve_class();

    register_CvFuzzyFunction_class();

    register_CvFuzzyMeanShiftTracker_class();

    register_CvFuzzyPoint_class();

    register_CvFuzzyRule_class();

    register_CvGenericHash_class();

    register_CvGraph_class();

    register_CvGraphEdge_class();

    register_CvGraphScanner_class();

    register_CvGraphVtx_class();

    register_CvGraphVtx2D_class();

    register_CvHaarClassifier_class();

    register_CvHaarClassifierCascade_class();

    register_CvHaarFeature_class();

    register_CvHaarStageClassifier_class();

    register_CvHidHaarClassifierCascade_class();

    register_CvKNearest_class();

    register_CvLSH_class();

    register_CvLSHOperations_class();

    register_CvLevMarq_class();

    register_CvMLData_class();

    register_CvMSERParams_class();

    register_CvMemBlock_class();

    register_CvMemStorage_class();

    register_CvMemStoragePos_class();

    register_CvModule_class();

    register_CvModuleInfo_class();

    register_CvNArrayIterator_class();

    register_CvNormalBayesClassifier_class();

    register_CvObjectDetector_class();

    register_CvPOSITObject_class();

    register_CvParamGrid_class();

    register_CvPluginFuncInfo_class();

    register_CvPoint_class();

    register_CvPoint2D32f_class();

    register_CvPoint2D64f_class();

    register_CvPoint3D32f_class();

    register_CvPoint3D64f_class();

    register_CvQuadEdge2D_class();

    register_CvRect_class();

    register_CvSURFParams_class();

    register_CvSURFPoint_class();

    register_CvSVMParams_class();

    register_CvSVM_class();

    register_CvScalar_class();

    register_CvSeq_class();

    register_CvSeqBlock_class();

    register_CvSeqReader_class();

    register_CvSeqWriter_class();

    register_CvSet_class();

    register_CvSetElem_class();

    register_CvSize_class();

    register_CvSize2D32f_class();

    register_CvStarDetectorParams_class();

    register_CvStarKeypoint_class();

    register_CvStereoGCState_class();

    register_CvString_class();

    register_CvStringHashNode_class();

    register_CvSubdiv2D_class();

    register_CvSubdiv2DPoint_class();

    register_CvTreeNodeIterator_class();

    register_CvType_class();

    register_CvTypeInfo_class();

    register_CvVSModule_class();

    register_CvVectors_class();

    register_CvContourScanner_class();

    register_BackgroundSubtractor_class();

    register_BackgroundSubtractorMOG_class();

    register_Size2i_class();

    bp::implicitly_convertible< cv::Size_< int >, CvSize >();

    bp::implicitly_convertible< cv::Size_< int >, CvSize2D32f >();

    register_CascadeClassifier_class();

    register_Complexd_class();

    register_Complexf_class();

    register_CvAffinePose_class();

    register_DefaultRngAuto_class();

    register_FeatureEvaluator_class();

    register_PatchGenerator_class();

    register_FernClassifier_class();

    register_FileNode_class();

    bp::implicitly_convertible< cv::FileNode, std::string >();

    bp::implicitly_convertible< cv::FileNode, double >();

    bp::implicitly_convertible< cv::FileNode, float >();

    bp::implicitly_convertible< cv::FileNode, int >();

    register_FileStorage_class();

    register_Point2i_class();

    bp::implicitly_convertible< cv::Point_< int >, CvPoint >();

    bp::implicitly_convertible< cv::Point_< int >, CvPoint2D32f >();

    bp::implicitly_convertible< cv::Point_< int >, cv::Vec< int, 2 > >();

    register_Rect_class();

    bp::implicitly_convertible< cv::Rect_< int >, CvRect >();

    register_Vec4d_class();

    bp::implicitly_convertible< cv::Vec< double, 4 >, CvScalar >();

    register_Scalar_class();

    bp::implicitly_convertible< cv::Scalar_< double >, CvScalar >();

    register_FilterEngine_class();

    register_HOGDescriptor_class();

    register_KDTree_class();

    register_KalmanFilter_class();

    register_KeyPoint_class();

    register_LDetector_class();

    register_TermCriteria_class();

    bp::implicitly_convertible< cv::TermCriteria, CvTermCriteria >();

    register_LevMarqSparse_class();

    register_MSER_class();

    register_MatND_class();

    bp::implicitly_convertible< cv::MatND, cv::Mat >();

    register_Mesh3D_class();

    register_Moments_class();

    register_NAryMatNDIterator_class();

    register_Octree_class();

    register_OneWayDescriptor_class();

    register_OneWayDescriptorBase_class();

    register_PCA_class();

    register_PlanarObjectDetector_class();

    register_Point3d_class();

    bp::implicitly_convertible< cv::Point3_< double >, CvPoint3D32f >();

    bp::implicitly_convertible< cv::Point3_< double >, cv::Vec< double, 3 > >();

    register_Point3f_class();

    bp::implicitly_convertible< cv::Point3_< float >, CvPoint3D32f >();

    bp::implicitly_convertible< cv::Point3_< float >, cv::Vec< float, 3 > >();

    register_Point3i_class();

    bp::implicitly_convertible< cv::Point3_< int >, CvPoint3D32f >();

    bp::implicitly_convertible< cv::Point3_< int >, cv::Vec< int, 3 > >();

    register_Point2d_class();

    bp::implicitly_convertible< cv::Point_< double >, CvPoint >();

    bp::implicitly_convertible< cv::Point_< double >, CvPoint2D32f >();

    bp::implicitly_convertible< cv::Point_< double >, cv::Vec< double, 2 > >();

    register_Point2f_class();

    bp::implicitly_convertible< cv::Point_< float >, CvPoint >();

    bp::implicitly_convertible< cv::Point_< float >, CvPoint2D32f >();

    bp::implicitly_convertible< cv::Point_< float >, cv::Vec< float, 2 > >();

    register_Ptr_CvHaarClassifierCascade_class();

    register_Ptr_CvStereoBMState_class();

    register_Ptr_BaseColumnFilter_class();

    register_Ptr_BaseFilter_class();

    register_Ptr_BaseRowFilter_class();

    register_Ptr_FeatureEvaluator_class();

    register_Ptr_FilterEngine_class();

    register_RNG_class();

    bp::implicitly_convertible< cv::RNG, schar >();

    bp::implicitly_convertible< cv::RNG, uchar >();

    bp::implicitly_convertible< cv::RNG, ushort >();

    bp::implicitly_convertible< cv::RNG, double >();

    bp::implicitly_convertible< cv::RNG, float >();

    bp::implicitly_convertible< cv::RNG, int >();

    bp::implicitly_convertible< cv::RNG, short int >();

    bp::implicitly_convertible< cv::RNG, unsigned int >();

    register_Range_class();

    bp::implicitly_convertible< cv::Range, CvSlice >();

    register_Rectd_class();

    bp::implicitly_convertible< cv::Rect_< double >, CvRect >();

    register_Rectf_class();

    bp::implicitly_convertible< cv::Rect_< float >, CvRect >();

    register_RotatedRect_class();

    bp::implicitly_convertible< cv::RotatedRect, CvBox2D >();

    register_SURF_class();

    register_SVD_class();

    register_SelfSimDescriptor_class();

    register_Size2d_class();

    bp::implicitly_convertible< cv::Size_< double >, CvSize >();

    bp::implicitly_convertible< cv::Size_< double >, CvSize2D32f >();

    register_Size2f_class();

    bp::implicitly_convertible< cv::Size_< float >, CvSize >();

    bp::implicitly_convertible< cv::Size_< float >, CvSize2D32f >();

    register_SparseMat_class();

    register_SparseMatConstIterator_class();

    register_SparseMatIterator_class();

    register_SpinImageModel_class();

    register_StarDetector_class();

    register_StereoBM_class();

    register_StereoSGBM_class();

    register_TickMeter_class();

    register_Vec2d_class();

    bp::implicitly_convertible< cv::Vec< double, 2 >, CvScalar >();

    register_Vec3d_class();

    bp::implicitly_convertible< cv::Vec< double, 3 >, CvScalar >();

    register_Vec6d_class();

    bp::implicitly_convertible< cv::Vec< double, 6 >, CvScalar >();

    register_Vec2f_class();

    bp::implicitly_convertible< cv::Vec< float, 2 >, CvScalar >();

    register_Vec3f_class();

    bp::implicitly_convertible< cv::Vec< float, 3 >, CvScalar >();

    register_Vec4f_class();

    bp::implicitly_convertible< cv::Vec< float, 4 >, CvScalar >();

    register_Vec6f_class();

    bp::implicitly_convertible< cv::Vec< float, 6 >, CvScalar >();

    register_Vec2i_class();

    bp::implicitly_convertible< cv::Vec< int, 2 >, CvScalar >();

    register_Vec3i_class();

    bp::implicitly_convertible< cv::Vec< int, 3 >, CvScalar >();

    register_Vec4i_class();

    bp::implicitly_convertible< cv::Vec< int, 4 >, CvScalar >();

    register_Vec2s_class();

    bp::implicitly_convertible< cv::Vec< short, 2 >, CvScalar >();

    register_Vec3s_class();

    bp::implicitly_convertible< cv::Vec< short, 3 >, CvScalar >();

    register_Vec4s_class();

    bp::implicitly_convertible< cv::Vec< short, 4 >, CvScalar >();

    register_Vec2b_class();

    bp::implicitly_convertible< cv::Vec< unsigned char, 2 >, CvScalar >();

    register_Vec3b_class();

    bp::implicitly_convertible< cv::Vec< unsigned char, 3 >, CvScalar >();

    register_Vec4b_class();

    bp::implicitly_convertible< cv::Vec< unsigned char, 4 >, CvScalar >();

    register_Vec2w_class();

    bp::implicitly_convertible< cv::Vec< unsigned short, 2 >, CvScalar >();

    register_Vec3w_class();

    bp::implicitly_convertible< cv::Vec< unsigned short, 3 >, CvScalar >();

    register_Vec4w_class();

    bp::implicitly_convertible< cv::Vec< unsigned short, 4 >, CvScalar >();

    register_VideoCapture_class();

    register_VideoWriter_class();

    register___dummy_struct_class();

    register_IndexFactory_class();

    register_IndexParams_class();

    register_AutotunedIndexParams_class();

    register_CompositeIndexParams_class();

    register_Index_class();

    register_KDTreeIndexParams_class();

    register_KMeansIndexParams_class();

    register_LinearIndexParams_class();

    register_SavedIndexParams_class();

    register_SearchParams_class();

    register_flann_Index_class();

    register_lsh_hash_class();

    register_DifferentialImage_class();

    register_IntegralHistogram_class();

    register_IntegralImage_class();

    register_LineIterator_class();

    { //::cv::FAST
    
        typedef boost::python::object ( *FAST_function_type )( ::cv::Mat const &,int,bool );
        
        bp::def( 
            "FAST"
            , FAST_function_type( &FAST_23d17220884e2f371691b185394322ec )
            , ( bp::arg("image"), bp::arg("threshold"), bp::arg("nonmax_supression")=(bool)(true) )
            , "\nArgument 'keypoints':"\
    "\n    C/C++ type: ::std::vector< cv::KeyPoint > &."\
    "\n    Python type: list."\
    "\n    To convert a Mat into a list, invoke one of Mat's member functions "\
    "\n    to_list_of_...()."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::HoughCircles
    
        typedef boost::python::object ( *HoughCircles_function_type )( ::cv::Mat const &,int,double,double,double,double,int,int );
        
        bp::def( 
            "HoughCircles"
            , HoughCircles_function_type( &HoughCircles_ea2999473356200d9d2fc8b7258555b0 )
            , ( bp::arg("image"), bp::arg("method"), bp::arg("dp"), bp::arg("minDist"), bp::arg("param1")=100, bp::arg("param2")=100, bp::arg("minRadius")=(int)(0), bp::arg("maxRadius")=(int)(0) )
            , "\nArgument 'circles':"\
    "\n    C/C++ type: ::std::vector< cv::Vec<float, 3> > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::HoughLines
    
        typedef boost::python::object ( *HoughLines_function_type )( ::cv::Mat const &,double,double,int,double,double );
        
        bp::def( 
            "HoughLines"
            , HoughLines_function_type( &HoughLines_deaa796a20e753a0b781de4a4d81ba3d )
            , ( bp::arg("image"), bp::arg("rho"), bp::arg("theta"), bp::arg("threshold"), bp::arg("srn")=0, bp::arg("stn")=0 )
            , "\nArgument 'lines':"\
    "\n    C/C++ type: ::std::vector< cv::Vec<float, 2> > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::HoughLinesP
    
        typedef boost::python::object ( *HoughLinesP_function_type )( ::cv::Mat &,double,double,int,double,double );
        
        bp::def( 
            "HoughLinesP"
            , HoughLinesP_function_type( &HoughLinesP_7e83e90590dfee49ad9ee8d704d1cfcb )
            , ( bp::arg("image"), bp::arg("rho"), bp::arg("theta"), bp::arg("threshold"), bp::arg("minLineLength")=0, bp::arg("maxLineGap")=0 )
            , "\nArgument 'lines':"\
    "\n    C/C++ type: ::std::vector< cv::Vec<int, 4> > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::HuMoments
    
        typedef boost::python::object ( *HuMoments_function_type )( ::cv::Moments const & );
        
        bp::def( 
            "HuMoments"
            , HuMoments_function_type( &HuMoments_646f4ee3824db566d9124eee2bb204ab )
            , ( bp::arg("moments") ) );
    
    }

    { //::cv::approxPolyDP
    
        typedef boost::python::object ( *approxPolyDP_float32_function_type )( ::cv::Mat const &,double,bool );
        
        bp::def( 
            "approxPolyDP_float32"
            , approxPolyDP_float32_function_type( &approxPolyDP_6246fabc9452f087130300d2a52e2a7d )
            , ( bp::arg("curve"), bp::arg("epsilon"), bp::arg("closed") )
            , "\nWrapped function:"
    "\n    approxPolyDP"
    "\nArgument 'approxCurve':"\
    "\n    C/C++ type: ::std::vector< cv::Point_<float> > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::approxPolyDP
    
        typedef boost::python::object ( *approxPolyDP_int_function_type )( ::cv::Mat const &,double,bool );
        
        bp::def( 
            "approxPolyDP_int"
            , approxPolyDP_int_function_type( &approxPolyDP_d6c85380d14cce99fc92c414781ada55 )
            , ( bp::arg("curve"), bp::arg("epsilon"), bp::arg("closed") )
            , "\nWrapped function:"
    "\n    approxPolyDP"
    "\nArgument 'approxCurve':"\
    "\n    C/C++ type: ::std::vector< cv::Point_<int> > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::buildPyramid
    
        typedef void ( *buildPyramid_function_type )( ::cv::Mat const &,bp::list &,int );
        
        bp::def( 
            "buildPyramid"
            , buildPyramid_function_type( &buildPyramid_84cd4ffd24fbd4dbaeccf86ceb1007ac )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("maxlevel") )
            , "\nArgument 'dst':"\
    "\n    C/C++ type: ::std::vector< cv::Mat > &."\
    "\n    Python type: list of Mat, e.g. [Mat(), Mat(), Mat()]." );
    
    }

    { //::cv::calcBackProject
    
        typedef void ( *calcBackProject_function_type )( sdcpp::sequence,cv::Mat const &,::cv::SparseMat const &,::cv::Mat &,bp::object const &,double,bool );
        
        bp::def( 
            "calcBackProject"
            , calcBackProject_function_type( &calcBackProject_fe6cdc6fffc26e8d864a094a2b14971b )
            , ( bp::arg("images"), bp::arg("channels"), bp::arg("hist"), bp::arg("backProject"), bp::arg("ranges"), bp::arg("scale")=1, bp::arg("uniform")=(bool)(true) )
            , "\nArgument 'images':"\
    "\n    C/C++ type: ::cv::Mat const *."\
    "\n    Python type: list of MatND, e.g. [MatND(), MatND(), MatND()]."\
    "\nArgument 'channels':"\
    "\n    C/C++ type: int const *."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\nArgument 'nimages':"\
    "\n    Dependent argument: omitted from the function's calling sequence, as "\
    "\n    its value is derived from argument 'images'."\
    "\nArgument 'ranges':"\
    "\n    C/C++ type: float const * *."\
    "\n    Python type: 2d list."\
    "\n    Depending on its C++ argument type, it should be a list of Mats or a "\
    "\n    list of lists." );
    
    }

    { //::cv::calcBackProject
    
        typedef void ( *calcBackProject_function_type )( sdcpp::sequence,cv::Mat const &,::cv::MatND const &,::cv::Mat &,bp::object const &,double,bool );
        
        bp::def( 
            "calcBackProject"
            , calcBackProject_function_type( &calcBackProject_84908d355b9d9fa6b6e1e0115efb65f8 )
            , ( bp::arg("images"), bp::arg("channels"), bp::arg("hist"), bp::arg("backProject"), bp::arg("ranges"), bp::arg("scale")=1, bp::arg("uniform")=(bool)(true) )
            , "\nArgument 'images':"\
    "\n    C/C++ type: ::cv::Mat const *."\
    "\n    Python type: list of MatND, e.g. [MatND(), MatND(), MatND()]."\
    "\nArgument 'channels':"\
    "\n    C/C++ type: int const *."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\nArgument 'nimages':"\
    "\n    Dependent argument: omitted from the function's calling sequence, as "\
    "\n    its value is derived from argument 'images'."\
    "\nArgument 'ranges':"\
    "\n    C/C++ type: float const * *."\
    "\n    Python type: 2d list."\
    "\n    Depending on its C++ argument type, it should be a list of Mats or a "\
    "\n    list of lists." );
    
    }

    { //::cv::calcCovarMatrix
    
        typedef void ( *calcCovarMatrix_function_type )( bp::list const &,::cv::Mat &,::cv::Mat &,int,int );
        
        bp::def( 
            "calcCovarMatrix"
            , calcCovarMatrix_function_type( &calcCovarMatrix_e8cf288956f6478b98045989198e81f5 )
            , ( bp::arg("samples"), bp::arg("covar"), bp::arg("mean"), bp::arg("flags"), bp::arg("ctype")=(int)(6) )
            , "\nCalculates covariation matrix of a set of vectors."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#calccovarmatrix"
    "\nArgument 'nsamples':"\
    "\n    Dependent argument: omitted from the function's calling sequence, as "\
    "\n    its value is derived from argument 'samples'."\
    "\nArgument 'samples':"\
    "\n    C/C++ type: ::cv::Mat const *."\
    "\n    Python type: list of Mat, e.g. [Mat(), Mat(), Mat()]." );
    
    }

    { //::cv::calcHist
    
        typedef void ( *calcHist_function_type )( sdcpp::sequence,cv::Mat const &,::cv::Mat const &,::cv::SparseMat &,cv::Mat const &,bp::object const &,bool,bool );
        
        bp::def( 
            "calcHist"
            , calcHist_function_type( &calcHist_8e436c4da97e1e09468541e1bed60274 )
            , ( bp::arg("images"), bp::arg("channels"), bp::arg("mask"), bp::arg("hist"), bp::arg("histSize"), bp::arg("ranges"), bp::arg("uniform")=(bool)(true), bp::arg("accumulate")=(bool)(false) )
            , "\nArgument 'ranges':"\
    "\n    C/C++ type: float const * *."\
    "\n    Python type: 2d list."\
    "\n    Depending on its C++ argument type, it should be a list of Mats or a "\
    "\n    list of lists."\
    "\nArgument 'histSize':"\
    "\n    C/C++ type: int const *."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\nArgument 'channels':"\
    "\n    C/C++ type: int const *."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\nArgument 'dims':"\
    "\n    Dependent argument: omitted from the function's calling sequence, as "\
    "\n    its value is derived from argument 'histSize'."\
    "\nArgument 'images':"\
    "\n    C/C++ type: ::cv::Mat const *."\
    "\n    Python type: list of MatND, e.g. [MatND(), MatND(), MatND()]."\
    "\nArgument 'nimages':"\
    "\n    Dependent argument: omitted from the function's calling sequence, as "\
    "\n    its value is derived from argument 'images'." );
    
    }

    { //::cv::calcHist
    
        typedef void ( *calcHist_function_type )( sdcpp::sequence,cv::Mat const &,::cv::Mat const &,::cv::MatND &,cv::Mat const &,bp::object const &,bool,bool );
        
        bp::def( 
            "calcHist"
            , calcHist_function_type( &calcHist_a4cce9bdd9689d0fb0adf901f467bfa0 )
            , ( bp::arg("images"), bp::arg("channels"), bp::arg("mask"), bp::arg("hist"), bp::arg("histSize"), bp::arg("ranges"), bp::arg("uniform")=(bool)(true), bp::arg("accumulate")=(bool)(false) )
            , "\nArgument 'ranges':"\
    "\n    C/C++ type: float const * *."\
    "\n    Python type: 2d list."\
    "\n    Depending on its C++ argument type, it should be a list of Mats or a "\
    "\n    list of lists."\
    "\nArgument 'histSize':"\
    "\n    C/C++ type: int const *."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\nArgument 'channels':"\
    "\n    C/C++ type: int const *."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\nArgument 'dims':"\
    "\n    Dependent argument: omitted from the function's calling sequence, as "\
    "\n    its value is derived from argument 'histSize'."\
    "\nArgument 'images':"\
    "\n    C/C++ type: ::cv::Mat const *."\
    "\n    Python type: list of MatND, e.g. [MatND(), MatND(), MatND()]."\
    "\nArgument 'nimages':"\
    "\n    Dependent argument: omitted from the function's calling sequence, as "\
    "\n    its value is derived from argument 'images'." );
    
    }

    { //::cv::calcOpticalFlowPyrLK
    
        typedef void ( *calcOpticalFlowPyrLK_function_type )( ::cv::Mat const &,::cv::Mat const &,cv::Mat const &,cv::Mat &,cv::Mat &,cv::Mat &,::cv::Size,int,::cv::TermCriteria,double,int );
        
        bp::def( 
            "calcOpticalFlowPyrLK"
            , calcOpticalFlowPyrLK_function_type( &calcOpticalFlowPyrLK_2855d31de3545ba96e3fc0ad950740f1 )
            , ( bp::arg("prevImg"), bp::arg("nextImg"), bp::arg("prevPts"), bp::arg("nextPts"), bp::arg("status"), bp::arg("err"), bp::arg("winSize")=cv::Size_<int>(15, 15), bp::arg("maxLevel")=(int)(3), bp::arg("criteria")=cv::TermCriteria(3, 30, 1.0000000000000000208166817117216851329430937767e-2), bp::arg("derivLambda")=5.0e-1, bp::arg("flags")=(int)(0) )
            , "\nArgument 'status':"\
    "\n    C/C++ type: ::std::vector< unsigned char > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\nArgument 'nextPts':"\
    "\n    C/C++ type: ::std::vector< cv::Point_<float> > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\nArgument 'prevPts':"\
    "\n    C/C++ type: ::std::vector< cv::Point_<float> > const &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\nArgument 'err':"\
    "\n    C/C++ type: ::std::vector< float > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))." );
    
    }

    { //::cv::calibrateCamera
    
        typedef boost::python::tuple ( *calibrateCamera_function_type )( bp::list const &,bp::list const &,::cv::Size,::cv::Mat &,::cv::Mat &,int );
        
        bp::def( 
            "calibrateCamera"
            , calibrateCamera_function_type( &calibrateCamera_e3c243276629b1246626096d8ff70485 )
            , ( bp::arg("objectPoints"), bp::arg("imagePoints"), bp::arg("imageSize"), bp::arg("cameraMatrix"), bp::arg("distCoeffs"), bp::arg("flags")=(int)(0) )
            , "\nArgument 'tvecs':"\
    "\n    C/C++ type: ::std::vector< cv::Mat > &."\
    "\n    Python type: list of Mat, e.g. [Mat(), Mat(), Mat()]."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)."\
    "\nArgument 'objectPoints':"\
    "\n    C/C++ type: ::std::vector< std::vector< cv::Point3_<float> > > const "\
    "\n    &."\
    "\n    Python type: list of Mat, e.g. [Mat(), Mat(), Mat()]."\
    "\n    Invoke asMat() to convert every 1D Python sequence into a Mat, e.g. "\
    "\n    [asMat([0,1,2]), asMat((0,1,2)]."\
    "\nArgument 'rvecs':"\
    "\n    C/C++ type: ::std::vector< cv::Mat > &."\
    "\n    Python type: list of Mat, e.g. [Mat(), Mat(), Mat()]."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)."\
    "\nArgument 'imagePoints':"\
    "\n    C/C++ type: ::std::vector< std::vector< cv::Point_<float> > > const &."\
    "\n    Python type: list of Mat, e.g. [Mat(), Mat(), Mat()]."\
    "\n    Invoke asMat() to convert every 1D Python sequence into a Mat, e.g. "\
    "\n    [asMat([0,1,2]), asMat((0,1,2)]." );
    
    }

    { //::cv::checkRange
    
        typedef boost::python::tuple ( *checkRange_function_type )( ::cv::MatND const &,bool,double,double );
        
        bp::def( 
            "checkRange"
            , checkRange_function_type( &checkRange_138f1b60b28a059182d9f09088ca2474 )
            , ( bp::arg("a"), bp::arg("quiet")=(bool)(true), bp::arg("minVal")=-1.79769313486231570814527423731704356798070567526e+308, bp::arg("maxVal")=1.79769313486231570814527423731704356798070567526e+308 )
            , "\nChecks every element of an input array for invalid values."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#checkrange"
    "\nArgument 'idx':"\
    "\n    C/C++ type: int *."\
    "\n    Python type: Python equivalence of the C/C++ type without pointer."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::checkRange
    
        typedef boost::python::tuple ( *checkRange_function_type )( ::cv::Mat const &,bool,double,double );
        
        bp::def( 
            "checkRange"
            , checkRange_function_type( &checkRange_31cc45f75977959e58047954bd730b32 )
            , ( bp::arg("a"), bp::arg("quiet")=(bool)(true), bp::arg("minVal")=-1.79769313486231570814527423731704356798070567526e+308, bp::arg("maxVal")=1.79769313486231570814527423731704356798070567526e+308 )
            , "\nChecks every element of an input array for invalid values."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#checkrange"
    "\nArgument 'pt':"\
    "\n    C/C++ type: ::cv::Point *."\
    "\n    Python type: Python equivalence of the C/C++ type without pointer."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::computeCorrespondEpilines
    
        typedef boost::python::object ( *computeCorrespondEpilines_function_type )( ::cv::Mat const &,int,::cv::Mat const & );
        
        bp::def( 
            "computeCorrespondEpilines"
            , computeCorrespondEpilines_function_type( &computeCorrespondEpilines_c5fa9f4742dac0ce300bb37345eb1f07 )
            , ( bp::arg("points1"), bp::arg("whichImage"), bp::arg("F") )
            , "\nArgument 'lines':"\
    "\n    C/C++ type: ::std::vector< cv::Vec<float, 3> > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::convertPointsHomogeneous
    
        typedef boost::python::object ( *convertPointsHomogeneous2D_function_type )( ::cv::Mat const & );
        
        bp::def( 
            "convertPointsHomogeneous2D"
            , convertPointsHomogeneous2D_function_type( &convertPointsHomogeneous_a80a768ed55e897cac15946457cd1696 )
            , ( bp::arg("src") )
            , "\nWrapped function:"
    "\n    convertPointsHomogeneous"
    "\nArgument 'dst':"\
    "\n    C/C++ type: ::std::vector< cv::Point_<float> > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::convertPointsHomogeneous
    
        typedef boost::python::object ( *convertPointsHomogeneous3D_function_type )( ::cv::Mat const & );
        
        bp::def( 
            "convertPointsHomogeneous3D"
            , convertPointsHomogeneous3D_function_type( &convertPointsHomogeneous_d220e3269e8c59fdb5b2dc2f830579b0 )
            , ( bp::arg("src") )
            , "\nWrapped function:"
    "\n    convertPointsHomogeneous"
    "\nArgument 'dst':"\
    "\n    C/C++ type: ::std::vector< cv::Point3_<float> > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::convexHull
    
        typedef boost::python::object ( *convexHull_float32_function_type )( ::cv::Mat const &,bool );
        
        bp::def( 
            "convexHull_float32"
            , convexHull_float32_function_type( &convexHull_42e8e723b1326dae78cb20a5c349e4e6 )
            , ( bp::arg("points"), bp::arg("clockwise")=(bool)(false) )
            , "\nWrapped function:"
    "\n    convexHull"
    "\nArgument 'hull':"\
    "\n    C/C++ type: ::std::vector< cv::Point_<float> > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::convexHull
    
        typedef boost::python::object ( *convexHull_int_function_type )( ::cv::Mat const &,bool );
        
        bp::def( 
            "convexHull_int"
            , convexHull_int_function_type( &convexHull_bf35caecb3465c45234b484233937f99 )
            , ( bp::arg("points"), bp::arg("clockwise")=(bool)(false) )
            , "\nWrapped function:"
    "\n    convexHull"
    "\nArgument 'hull':"\
    "\n    C/C++ type: ::std::vector< cv::Point_<int> > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::convexHull
    
        typedef boost::python::object ( *convexHullIdx_function_type )( ::cv::Mat const &,bool );
        
        bp::def( 
            "convexHullIdx"
            , convexHullIdx_function_type( &convexHull_a7bf196b869588f11c69529c43975a42 )
            , ( bp::arg("points"), bp::arg("clockwise")=(bool)(false) )
            , "\nWrapped function:"
    "\n    convexHull"
    "\nArgument 'hull':"\
    "\n    C/C++ type: ::std::vector< int > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::cornerSubPix
    
        typedef void ( *cornerSubPix_function_type )( ::cv::Mat const &,cv::Mat &,::cv::Size,::cv::Size,::cv::TermCriteria );
        
        bp::def( 
            "cornerSubPix"
            , cornerSubPix_function_type( &cornerSubPix_897410ee39f221d5b382cc794de38b84 )
            , ( bp::arg("image"), bp::arg("corners"), bp::arg("winSize"), bp::arg("zeroZone"), bp::arg("criteria") )
            , "\nArgument 'corners':"\
    "\n    C/C++ type: ::std::vector< cv::Point_<float> > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))." );
    
    }

    { //::cv::createTrackbar
    
        typedef boost::python::tuple ( *_createTrackbar_function_type )( ::std::string const &,::std::string const &,unsigned int,int,boost::python::object,boost::python::object );
        
        bp::def( 
            "_createTrackbar"
            , _createTrackbar_function_type( &createTrackbar_a255009d4d0c76c9c0a784685d2594ee )
            , ( bp::arg("trackbarname"), bp::arg("winname"), bp::arg("value"), bp::arg("count"), bp::arg("onChange")=bp::object(), bp::arg("userdata")=bp::object() )
            , "\nCreates a trackbar and attaches it to the specified window."
    "\nWrapped function:"
    "\n    createTrackbar"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/user_interface.html#cv-createtrackbar"
    "\nArgument 'onChange' is a Python function that should look like below:"\
    "\n    def on_trackbar(pos, user_data):"\
    "\n        ..."\
    "\nArgument 'userdata' is a Python object that is passed to function "\
    "\non_trackbar() as 'user_data'." );
    
    }

    { //::cvAcc
    
        typedef void ( *acc_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat );
        
        bp::def( 
            "acc"
            , acc_function_type( &cvAcc_ef7ed9735ac6fce4129e5e89f645482d )
            , ( bp::arg("image"), bp::arg("sum"), bp::arg("mask")=cv::Mat() )
            , "\nWrapped function:"
    "\n    cvAcc"
    "\nArgument 'image':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'mask':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'sum':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvCalcAffineFlowPyrLK
    
        typedef boost::python::tuple ( *calcAffineFlowPyrLK_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,cv::Mat const &,::CvSize,int,::CvTermCriteria,int );
        
        bp::def( 
            "calcAffineFlowPyrLK"
            , calcAffineFlowPyrLK_function_type( &cvCalcAffineFlowPyrLK_3a4b3f5dff85e72a121da3f42cded4aa )
            , ( bp::arg("prev"), bp::arg("curr"), bp::arg("prev_pyr"), bp::arg("curr_pyr"), bp::arg("prev_features"), bp::arg("win_size"), bp::arg("level"), bp::arg("criteria"), bp::arg("flags") )
            , "\nWrapped function:"
    "\n    cvCalcAffineFlowPyrLK"
    "\nArgument 'count':"\
    "\n    Dependent argument: omitted from the function's calling sequence, as "\
    "\n    its value is derived from argument 'prev_features'."\
    "\nArgument 'status':"\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)."\
    "\nArgument 'prev':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'curr':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'track_error':"\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)."\
    "\nArgument 'prev_pyr':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'curr_pyr':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'prev_features':"\
    "\n    C/C++ type: ::CvPoint2D32f const *."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\nArgument 'curr_features':"\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)."\
    "\nArgument 'matrices':"\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cvCalcEMD2
    
        typedef boost::python::object ( *calcEMD2_function_type )( ::cv::Mat &,::cv::Mat &,int,boost::python::object,::cv::Mat,::cv::Mat,float *,boost::python::object );
        
        bp::def( 
            "calcEMD2"
            , calcEMD2_function_type( &cvCalcEMD2_f4e5308a9258b3a75a06fb112d06a2e8 )
            , ( bp::arg("signature1"), bp::arg("signature2"), bp::arg("distance_type"), bp::arg("distance_func")=bp::object(), bp::arg("cost_matrix")=cv::Mat(), bp::arg("flow")=cv::Mat(), bp::arg("lower_bound")=bp::object(), bp::arg("userdata")=bp::object() )
            , "\nWrapped function:"
    "\n    cvCalcEMD2"
    "\nArgument 'signature1':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'signature2':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'flow':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'cost_matrix':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvCalcGlobalOrientation
    
        typedef boost::python::object ( *calcGlobalOrientation_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,double,double );
        
        bp::def( 
            "calcGlobalOrientation"
            , calcGlobalOrientation_function_type( &cvCalcGlobalOrientation_9d75a586d5a67c41e4450ccf9b8af7b3 )
            , ( bp::arg("orientation"), bp::arg("mask"), bp::arg("mhi"), bp::arg("timestamp"), bp::arg("duration") )
            , "\nWrapped function:"
    "\n    cvCalcGlobalOrientation"
    "\nArgument 'mask':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'orientation':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'mhi':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvCalcImageHomography
    
        typedef boost::python::object ( *calcImageHomography_function_type )( boost::python::object,::CvPoint3D32f *,boost::python::object );
        
        bp::def( 
            "calcImageHomography"
            , calcImageHomography_function_type( &cvCalcImageHomography_a814cf819bbf03a0c8d0b4fd1b700335 )
            , ( bp::arg("line"), bp::arg("center"), bp::arg("intrinsic") )
            , "\nWrapped function:"
    "\n    cvCalcImageHomography" );
    
    }

    { //::cvCalcMotionGradient
    
        typedef void ( *calcMotionGradient_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,double,double,int );
        
        bp::def( 
            "calcMotionGradient"
            , calcMotionGradient_function_type( &cvCalcMotionGradient_7506fb6ca34b4a6cb9165f5aff081454 )
            , ( bp::arg("mhi"), bp::arg("mask"), bp::arg("orientation"), bp::arg("delta1"), bp::arg("delta2"), bp::arg("aperture_size")=(int)(3) )
            , "\nWrapped function:"
    "\n    cvCalcMotionGradient"
    "\nArgument 'mask':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'orientation':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'mhi':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvCalcOpticalFlowBM
    
        typedef void ( *calcOpticalFlowBM_function_type )( ::cv::Mat &,::cv::Mat &,::CvSize,::CvSize,::CvSize,int,::cv::Mat &,::cv::Mat & );
        
        bp::def( 
            "calcOpticalFlowBM"
            , calcOpticalFlowBM_function_type( &cvCalcOpticalFlowBM_3537c5574d176e4f3dea85450be5ee9f )
            , ( bp::arg("prev"), bp::arg("curr"), bp::arg("block_size"), bp::arg("shift_size"), bp::arg("max_range"), bp::arg("use_previous"), bp::arg("velx"), bp::arg("vely") )
            , "\nWrapped function:"
    "\n    cvCalcOpticalFlowBM"
    "\nArgument 'prev':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'curr':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'vely':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'velx':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvCalcOpticalFlowFarneback
    
        typedef void ( *calcOpticalFlowFarneback_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,double,int,int,int,int,double,int );
        
        bp::def( 
            "calcOpticalFlowFarneback"
            , calcOpticalFlowFarneback_function_type( &cvCalcOpticalFlowFarneback_409b7a55ce4ab8f251cb192176e9376c )
            , ( bp::arg("prev"), bp::arg("next"), bp::arg("flow"), bp::arg("pyr_scale"), bp::arg("levels"), bp::arg("winsize"), bp::arg("iterations"), bp::arg("poly_n"), bp::arg("poly_sigma"), bp::arg("flags") )
            , "\nWrapped function:"
    "\n    cvCalcOpticalFlowFarneback"
    "\nArgument 'prev':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'flow':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'next':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvCalcOpticalFlowHS
    
        typedef void ( *calcOpticalFlowHS_function_type )( ::cv::Mat &,::cv::Mat &,int,::cv::Mat &,::cv::Mat &,double,::CvTermCriteria );
        
        bp::def( 
            "calcOpticalFlowHS"
            , calcOpticalFlowHS_function_type( &cvCalcOpticalFlowHS_0757feb4eeb7fd8c38b710aec2f5f8e9 )
            , ( bp::arg("prev"), bp::arg("curr"), bp::arg("use_previous"), bp::arg("velx"), bp::arg("vely"), bp::arg("lambda"), bp::arg("criteria") )
            , "\nWrapped function:"
    "\n    cvCalcOpticalFlowHS"
    "\nArgument 'prev':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'curr':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'vely':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'velx':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvCalcOpticalFlowLK
    
        typedef void ( *calcOpticalFlowLK_function_type )( ::cv::Mat &,::cv::Mat &,::CvSize,::cv::Mat &,::cv::Mat & );
        
        bp::def( 
            "calcOpticalFlowLK"
            , calcOpticalFlowLK_function_type( &cvCalcOpticalFlowLK_0539268816232dbc93df209c0dc87327 )
            , ( bp::arg("prev"), bp::arg("curr"), bp::arg("win_size"), bp::arg("velx"), bp::arg("vely") )
            , "\nWrapped function:"
    "\n    cvCalcOpticalFlowLK"
    "\nArgument 'prev':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'curr':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'vely':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'velx':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvCalcOpticalFlowPyrLK
    
        typedef boost::python::tuple ( *calcOpticalFlowPyrLK_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,cv::Mat const &,::CvSize,int,::CvTermCriteria,int );
        
        bp::def( 
            "calcOpticalFlowPyrLK"
            , calcOpticalFlowPyrLK_function_type( &cvCalcOpticalFlowPyrLK_925fd4448f97740474886f84b12836c2 )
            , ( bp::arg("prev"), bp::arg("curr"), bp::arg("prev_pyr"), bp::arg("curr_pyr"), bp::arg("prev_features"), bp::arg("win_size"), bp::arg("level"), bp::arg("criteria"), bp::arg("flags") )
            , "\nWrapped function:"
    "\n    cvCalcOpticalFlowPyrLK"
    "\nArgument 'count':"\
    "\n    Dependent argument: omitted from the function's calling sequence, as "\
    "\n    its value is derived from argument 'prev_features'."\
    "\nArgument 'status':"\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)."\
    "\nArgument 'prev':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'curr':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'track_error':"\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)."\
    "\nArgument 'prev_pyr':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'prev_features':"\
    "\n    C/C++ type: ::CvPoint2D32f const *."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\nArgument 'curr_features':"\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)."\
    "\nArgument 'curr_pyr':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvCheckChessboard
    
        typedef boost::python::object ( *checkChessboard_function_type )( ::cv::Mat &,::CvSize );
        
        bp::def( 
            "checkChessboard"
            , checkChessboard_function_type( &cvCheckChessboard_59f8753d978791ecd1fc97cea5e10f04 )
            , ( bp::arg("src"), bp::arg("size") )
            , "\nWrapped function:"
    "\n    cvCheckChessboard"
    "\nArgument 'src':"\
    "\n    C/C++ type: ::IplImage *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvConDensInitSampleSet
    
        typedef void ( *conDensInitSampleSet_function_type )( ::CvConDensation *,::cv::Mat &,::cv::Mat & );
        
        bp::def( 
            "conDensInitSampleSet"
            , conDensInitSampleSet_function_type( &cvConDensInitSampleSet_2b2c9d04e9f57fb36a248c795590341d )
            , ( bp::arg("condens"), bp::arg("lower_bound"), bp::arg("upper_bound") )
            , "\nWrapped function:"
    "\n    cvConDensInitSampleSet"
    "\nArgument 'lower_bound':"\
    "\n    C/C++ type: ::CvMat *."\
    "\n    Python type: Mat."\
    "\nArgument 'upper_bound':"\
    "\n    C/C++ type: ::CvMat *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvConvertImage
    
        typedef void ( *convertImage_function_type )( ::cv::Mat &,::cv::Mat &,int );
        
        bp::def( 
            "convertImage"
            , convertImage_function_type( &cvConvertImage_9d5028440635df77832885475bf0ea00 )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("flags")=(int)(0) )
            , "\nConverts one image to another with an optional vertical flip."
    "\nWrapped function:"
    "\n    cvConvertImage"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/c/user_interface.html#convertimage#convertimage"
    "\nArgument 'src':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'dst':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvConvexityDefects
    
        typedef boost::python::object ( *convexityDefects_function_type )( ::cv::Mat &,::cv::Mat &,::CvMemStorage * );
        
        bp::def( 
            "convexityDefects"
            , convexityDefects_function_type( &cvConvexityDefects_cc97bf52cc42e365950605a23b42e95a )
            , ( bp::arg("contour"), bp::arg("convexhull"), bp::arg("storage")=bp::object() )
            , "\nWrapped function:"
    "\n    cvConvexityDefects"
    "\nArgument 'contour':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'convexhull':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvCorrectMatches
    
        typedef void ( *correctMatches_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat & );
        
        bp::def( 
            "correctMatches"
            , correctMatches_function_type( &cvCorrectMatches_055faac2f695cea7fa86e829ba6bdc99 )
            , ( bp::arg("F"), bp::arg("points1"), bp::arg("points2"), bp::arg("new_points1"), bp::arg("new_points2") )
            , "\nWrapped function:"
    "\n    cvCorrectMatches"
    "\nArgument 'points1':"\
    "\n    C/C++ type: ::CvMat *."\
    "\n    Python type: Mat."\
    "\nArgument 'points2':"\
    "\n    C/C++ type: ::CvMat *."\
    "\n    Python type: Mat."\
    "\nArgument 'new_points2':"\
    "\n    C/C++ type: ::CvMat *."\
    "\n    Python type: Mat."\
    "\nArgument 'new_points1':"\
    "\n    C/C++ type: ::CvMat *."\
    "\n    Python type: Mat."\
    "\nArgument 'F':"\
    "\n    C/C++ type: ::CvMat *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvCreateKDTree
    
        typedef boost::python::object ( *createKDTree_function_type )( ::cv::Mat & );
        
        bp::def( 
            "createKDTree"
            , createKDTree_function_type( &cvCreateKDTree_bedd697814f42b0adb235e1d1bda9bdd )
            , ( bp::arg("desc") )
            , "\nWrapped function:"
    "\n    cvCreateKDTree"
    "\nArgument 'desc':"\
    "\n    C/C++ type: ::CvMat *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvCreateSpillTree
    
        typedef boost::python::object ( *createSpillTree_function_type )( ::cv::Mat &,int const,double const,double const );
        
        bp::def( 
            "createSpillTree"
            , createSpillTree_function_type( &cvCreateSpillTree_22146c3478f3d8c8ff22213a86f1b244 )
            , ( bp::arg("raw_data"), bp::arg("naive")=(int const)(50), bp::arg("rho")=6.99999999999999955591079014993738383054733276367e-1, bp::arg("tau")=1.00000000000000005551115123125782702118158340454e-1 )
            , "\nWrapped function:"
    "\n    cvCreateSpillTree"
    "\nArgument 'raw_data':"\
    "\n    C/C++ type: ::CvMat const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvDistTransform
    
        typedef void ( *distTransform_function_type )( ::cv::Mat &,::cv::Mat &,int,int,cv::Mat,::cv::Mat );
        
        bp::def( 
            "distTransform"
            , distTransform_function_type( &cvDistTransform_68addecae85b6b48cd46044102a6c028 )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("distance_type")=(int)(2), bp::arg("mask_size")=(int)(3), bp::arg("mask")=cv::Mat(), bp::arg("labels")=cv::Mat() )
            , "\nWrapped function:"
    "\n    cvDistTransform"
    "\nArgument 'src':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'dst':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'labels':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'mask':"\
    "\n    C/C++ type: float const *."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))." );
    
    }

    { //::cvEndWriteStruct
    
        typedef void ( *endWriteStruct_function_type )( ::cv::FileStorage & );
        
        bp::def( 
            "endWriteStruct"
            , endWriteStruct_function_type( &cvEndWriteStruct_49df8f8a99539026dfbd302575d7a485 )
            , ( bp::arg("fs") )
            , "\nWrapped function:"
    "\n    cvEndWriteStruct"
    "\nArgument 'fs':"\
    "\n    C/C++ type: ::CvFileStorage *."\
    "\n    Python type: FileStorage." );
    
    }

    { //::cvEstimateRigidTransform
    
        typedef boost::python::object ( *estimateRigidTransform_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,int );
        
        bp::def( 
            "estimateRigidTransform"
            , estimateRigidTransform_function_type( &cvEstimateRigidTransform_2f885814bd847b94c8621a570a36abad )
            , ( bp::arg("A"), bp::arg("B"), bp::arg("M"), bp::arg("full_affine") )
            , "\nWrapped function:"
    "\n    cvEstimateRigidTransform"
    "\nArgument 'A':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'B':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'M':"\
    "\n    C/C++ type: ::CvMat *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvFindFeatures
    
        typedef void ( *findFeatures_function_type )( ::CvFeatureTree *,::cv::Mat &,::cv::Mat &,::cv::Mat &,int,int );
        
        bp::def( 
            "findFeatures"
            , findFeatures_function_type( &cvFindFeatures_3cdcd7c246944a80a295b6f20e448cfc )
            , ( bp::arg("tr"), bp::arg("query_points"), bp::arg("indices"), bp::arg("dist"), bp::arg("k"), bp::arg("emax")=(int)(20) )
            , "\nWrapped function:"
    "\n    cvFindFeatures"
    "\nArgument 'indices':"\
    "\n    C/C++ type: ::CvMat *."\
    "\n    Python type: Mat."\
    "\nArgument 'query_points':"\
    "\n    C/C++ type: ::CvMat const *."\
    "\n    Python type: Mat."\
    "\nArgument 'dist':"\
    "\n    C/C++ type: ::CvMat *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvFindFeaturesBoxed
    
        typedef boost::python::object ( *findFeaturesBoxed_function_type )( ::CvFeatureTree *,::cv::Mat &,::cv::Mat &,::cv::Mat & );
        
        bp::def( 
            "findFeaturesBoxed"
            , findFeaturesBoxed_function_type( &cvFindFeaturesBoxed_6d675cd8257b64f665600bd276900d3e )
            , ( bp::arg("tr"), bp::arg("bounds_min"), bp::arg("bounds_max"), bp::arg("out_indices") )
            , "\nWrapped function:"
    "\n    cvFindFeaturesBoxed"
    "\nArgument 'bounds_min':"\
    "\n    C/C++ type: ::CvMat *."\
    "\n    Python type: Mat."\
    "\nArgument 'out_indices':"\
    "\n    C/C++ type: ::CvMat *."\
    "\n    Python type: Mat."\
    "\nArgument 'bounds_max':"\
    "\n    C/C++ type: ::CvMat *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvFindNearestPoint2D
    
        typedef boost::python::object ( *findNearestPoint2D_function_type )( ::CvSubdiv2D *,const ::cv::Point2f & );
        
        bp::def( 
            "findNearestPoint2D"
            , findNearestPoint2D_function_type( &cvFindNearestPoint2D_4658231361f43a6fc66c2e150f75dca8 )
            , ( bp::arg("subdiv"), bp::arg("pt") )
            , "\nWrapped function:"
    "\n    cvFindNearestPoint2D"
    "\nArgument 'pt':"\
    "\n    C/C++ type: ::CvPoint2D32f."\
    "\n    Python type: Point2f." );
    
    }

    { //::cvFindStereoCorrespondence
    
        typedef void ( *findStereoCorrespondence_function_type )( ::cv::Mat &,::cv::Mat &,int,::cv::Mat &,int,double,double,double,double,double );
        
        bp::def( 
            "findStereoCorrespondence"
            , findStereoCorrespondence_function_type( &cvFindStereoCorrespondence_7b07c127d562a5149232dd8cc1bc470d )
            , ( bp::arg("leftImage"), bp::arg("rightImage"), bp::arg("mode"), bp::arg("dispImage"), bp::arg("maxDisparity"), bp::arg("param1")=12345, bp::arg("param2")=12345, bp::arg("param3")=12345, bp::arg("param4")=12345, bp::arg("param5")=12345 )
            , "\nWrapped function:"
    "\n    cvFindStereoCorrespondence"
    "\nArgument 'dispImage':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'leftImage':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'rightImage':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvFindStereoCorrespondenceGC
    
        typedef void ( *findStereoCorrespondenceGC_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::CvStereoGCState *,int );
        
        bp::def( 
            "findStereoCorrespondenceGC"
            , findStereoCorrespondenceGC_function_type( &cvFindStereoCorrespondenceGC_c3eefaed321a780e7059f7c3392c4672 )
            , ( bp::arg("left"), bp::arg("right"), bp::arg("disparityLeft"), bp::arg("disparityRight"), bp::arg("state"), bp::arg("useDisparityGuess")=(int)(0) )
            , "\nWrapped function:"
    "\n    cvFindStereoCorrespondenceGC"
    "\nArgument 'disparityLeft':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'right':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'disparityRight':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'left':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvGetElemType
    
        typedef boost::python::object ( *getElemType_function_type )( ::cv::Mat & );
        
        bp::def( 
            "getElemType"
            , getElemType_function_type( &cvGetElemType_28303ccd15acadc45a20b8189b3b5941 )
            , ( bp::arg("arr") )
            , "\nWrapped function:"
    "\n    cvGetElemType"
    "\nArgument 'arr':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvGetHashedKey
    
        typedef boost::python::object ( *getHashedKey_function_type )( ::cv::FileStorage &,char const *,int,int );
        
        bp::def( 
            "getHashedKey"
            , getHashedKey_function_type( &cvGetHashedKey_5bf3bb09f908d63c5767d651120f813f )
            , ( bp::arg("fs"), bp::arg("name"), bp::arg("len")=(int)(-0x000000001), bp::arg("create_missing")=(int)(0) )
            , "\nWrapped function:"
    "\n    cvGetHashedKey"
    "\nArgument 'fs':"\
    "\n    C/C++ type: ::CvFileStorage *."\
    "\n    Python type: FileStorage." );
    
    }

    { //::cvGetQuadrangleSubPix
    
        typedef void ( *getQuadrangleSubPix_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat & );
        
        bp::def( 
            "getQuadrangleSubPix"
            , getQuadrangleSubPix_function_type( &cvGetQuadrangleSubPix_fe2b1a5028fa8b02301dc960cdfbc131 )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("map_matrix") )
            , "\nWrapped function:"
    "\n    cvGetQuadrangleSubPix"
    "\nArgument 'map_matrix':"\
    "\n    C/C++ type: ::CvMat const *."\
    "\n    Python type: Mat."\
    "\nArgument 'src':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'dst':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvInitNArrayIterator
    
        typedef boost::python::object ( *initNArrayIterator_function_type )( cv::Mat const &,::cv::Mat &,::CvMatND *,::CvNArrayIterator *,int );
        
        bp::def( 
            "initNArrayIterator"
            , initNArrayIterator_function_type( &cvInitNArrayIterator_4c1924434c279d42b088754762acc53b )
            , ( bp::arg("arrs"), bp::arg("mask"), bp::arg("stubs"), bp::arg("array_iterator"), bp::arg("flags")=(int)(0) )
            , "\nWrapped function:"
    "\n    cvInitNArrayIterator"
    "\nArgument 'count':"\
    "\n    Dependent argument: omitted from the function's calling sequence, as "\
    "\n    its value is derived from argument 'arrs'."\
    "\nArgument 'mask':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'arrs':"\
    "\n    C/C++ type: ::CvArr * *."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))." );
    
    }

    { //::cvInitSystem
    
        typedef boost::python::object ( *initSystem_function_type )( cv::Mat const & );
        
        bp::def( 
            "initSystem"
            , initSystem_function_type( &cvInitSystem_f0aa383f9ae0b2f0bf89bbcb5e73da23 )
            , ( bp::arg("argv") )
            , "\nInitializes HighGUI."
    "\nWrapped function:"
    "\n    cvInitSystem"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/c/user_interface.html#convertimage#initsystem"
    "\nArgument 'argc':"\
    "\n    Dependent argument: omitted from the function's calling sequence, as "\
    "\n    its value is derived from argument 'argv'."\
    "\nArgument 'argv':"\
    "\n    C/C++ type: char * *."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))." );
    
    }

    { //::cvLSHAdd
    
        typedef void ( *LSHAdd_function_type )( ::CvLSH *,::cv::Mat &,::cv::Mat );
        
        bp::def( 
            "LSHAdd"
            , LSHAdd_function_type( &cvLSHAdd_fead3e6b36de0b14c88ef1b561c6e621 )
            , ( bp::arg("lsh"), bp::arg("data"), bp::arg("indices")=cv::Mat() )
            , "\nWrapped function:"
    "\n    cvLSHAdd"
    "\nArgument 'indices':"\
    "\n    C/C++ type: ::CvMat *."\
    "\n    Python type: Mat."\
    "\nArgument 'data':"\
    "\n    C/C++ type: ::CvMat const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvLSHQuery
    
        typedef void ( *LSHQuery_function_type )( ::CvLSH *,::cv::Mat &,::cv::Mat &,::cv::Mat &,int,int );
        
        bp::def( 
            "LSHQuery"
            , LSHQuery_function_type( &cvLSHQuery_a5f47e360cc9701a6672c12490153852 )
            , ( bp::arg("lsh"), bp::arg("query_points"), bp::arg("indices"), bp::arg("dist"), bp::arg("k"), bp::arg("emax") )
            , "\nWrapped function:"
    "\n    cvLSHQuery"
    "\nArgument 'indices':"\
    "\n    C/C++ type: ::CvMat *."\
    "\n    Python type: Mat."\
    "\nArgument 'query_points':"\
    "\n    C/C++ type: ::CvMat const *."\
    "\n    Python type: Mat."\
    "\nArgument 'dist':"\
    "\n    C/C++ type: ::CvMat *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvLSHRemove
    
        typedef void ( *LSHRemove_function_type )( ::CvLSH *,::cv::Mat & );
        
        bp::def( 
            "LSHRemove"
            , LSHRemove_function_type( &cvLSHRemove_5f32fb503216c52038c4ae3bf17b62db )
            , ( bp::arg("lsh"), bp::arg("indices") )
            , "\nWrapped function:"
    "\n    cvLSHRemove"
    "\nArgument 'indices':"\
    "\n    C/C++ type: ::CvMat const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvLinearPolar
    
        typedef void ( *linearPolar_function_type )( ::cv::Mat &,::cv::Mat &,const ::cv::Point2f &,double,int );
        
        bp::def( 
            "linearPolar"
            , linearPolar_function_type( &cvLinearPolar_b75d44697de3c90f0462366e93d77425 )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("center"), bp::arg("maxRadius"), bp::arg("flags")=(int)(9) )
            , "\nWrapped function:"
    "\n    cvLinearPolar"
    "\nArgument 'src':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'dst':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'center':"\
    "\n    C/C++ type: ::CvPoint2D32f."\
    "\n    Python type: Point2f." );
    
    }

    { //::cvLogPolar
    
        typedef void ( *logPolar_function_type )( ::cv::Mat &,::cv::Mat &,const ::cv::Point2f &,double,int );
        
        bp::def( 
            "logPolar"
            , logPolar_function_type( &cvLogPolar_27c4d18226a6e750886777db97773f4d )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("center"), bp::arg("M"), bp::arg("flags")=(int)(9) )
            , "\nWrapped function:"
    "\n    cvLogPolar"
    "\nArgument 'src':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'dst':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'center':"\
    "\n    C/C++ type: ::CvPoint2D32f."\
    "\n    Python type: Point2f." );
    
    }

    { //::cvMultiplyAcc
    
        typedef void ( *multiplyAcc_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat );
        
        bp::def( 
            "multiplyAcc"
            , multiplyAcc_function_type( &cvMultiplyAcc_c64c83fc39cb1265f3d1a69d9e600a47 )
            , ( bp::arg("image1"), bp::arg("image2"), bp::arg("acc"), bp::arg("mask")=cv::Mat() )
            , "\nWrapped function:"
    "\n    cvMultiplyAcc"
    "\nArgument 'acc':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'image2':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'image1':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'mask':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvPointSeqFromMat
    
        typedef boost::python::object ( *pointSeqFromMat_function_type )( int,::cv::Mat &,::CvContour *,::CvSeqBlock * );
        
        bp::def( 
            "pointSeqFromMat"
            , pointSeqFromMat_function_type( &cvPointSeqFromMat_ef8459cfef37d715411cf088e0da5576 )
            , ( bp::arg("seq_kind"), bp::arg("mat"), bp::arg("contour_header"), bp::arg("block") )
            , "\nWrapped function:"
    "\n    cvPointSeqFromMat"
    "\nArgument 'mat':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvPyrMeanShiftFiltering
    
        typedef void ( *pyrMeanShiftFiltering_function_type )( ::cv::Mat &,::cv::Mat &,double,double,int,::CvTermCriteria );
        
        bp::def( 
            "pyrMeanShiftFiltering"
            , pyrMeanShiftFiltering_function_type( &cvPyrMeanShiftFiltering_21ec6b7149a6e00a31f1d76aebb9a22b )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("sp"), bp::arg("sr"), bp::arg("max_level")=(int)(1), bp::arg("termcrit")=cv::TermCriteria(3, 5, 1.0e+0) )
            , "\nWrapped function:"
    "\n    cvPyrMeanShiftFiltering"
    "\nArgument 'src':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'dst':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvPyrSegmentation
    
        typedef boost::python::object ( *pyrSegmentation_function_type )( ::cv::Mat &,::cv::Mat &,::CvMemStorage *,int,double,double );
        
        bp::def( 
            "pyrSegmentation"
            , pyrSegmentation_function_type( &cvPyrSegmentation_0a5e58f4641f1c9757bb83d3f16f4191 )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("storage"), bp::arg("level"), bp::arg("threshold1"), bp::arg("threshold2") )
            , "\nWrapped function:"
    "\n    cvPyrSegmentation"
    "\nArgument 'comp':"\
    "\n    C/C++ type: ::CvSeq * *."\
    "\n    Python type: Python equivalence of the C/C++ type without pointer."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)."\
    "\nArgument 'dst':"\
    "\n    C/C++ type: ::IplImage *."\
    "\n    Python type: Mat."\
    "\nArgument 'src':"\
    "\n    C/C++ type: ::IplImage *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvRandArr
    
        typedef void ( *randArr_function_type )( ::cv::RNG &,::cv::Mat &,int,::CvScalar,::CvScalar );
        
        bp::def( 
            "randArr"
            , randArr_function_type( &cvRandArr_7e6e03c94e3a5f654b62b47647889d1d )
            , ( bp::arg("rng"), bp::arg("arr"), bp::arg("dist_type"), bp::arg("param1"), bp::arg("param2") )
            , "\nWrapped function:"
    "\n    cvRandArr"
    "\nArgument 'arr':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'rng':"\
    "\n    C/C++ type: ::CvRNG *."\
    "\n    Python type: RNG." );
    
    }

    { //::cvRange
    
        typedef boost::python::object ( *range__function_type )( ::cv::Mat &,double,double );
        
        bp::def( 
            "range_"
            , range__function_type( &cvRange_073a997114e2c96bbeff2aaa986e76a1 )
            , ( bp::arg("mat"), bp::arg("start"), bp::arg("end") )
            , "\nWrapped function:"
    "\n    cvRange"
    "\nArgument 'mat':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvReleaseConDensation
    
        typedef void ( *_cvReleaseConDensation_function_type )( ::CvConDensation );
        
        bp::def( 
            "_cvReleaseConDensation"
            , _cvReleaseConDensation_function_type( &cvReleaseConDensation_f998e5f5422410bd74b2ba960fd05e2c )
            , ( bp::arg("condens") )
            , "\nWrapped function:"
    "\n    cvReleaseConDensation"
    "\nArgument 'condens':"\
    "\n    C/C++ type: ::CvConDensation * *."\
    "\n    Python type: Python equivalence of the C/C++ type without double "\
    "\n    pointer." );
    
    }

    { //::cvReleaseFileStorage
    
        typedef void ( *_cvReleaseFileStorage_function_type )( ::CvFileStorage );
        
        bp::def( 
            "_cvReleaseFileStorage"
            , _cvReleaseFileStorage_function_type( &cvReleaseFileStorage_d53aa99c3241294fee03f3f038aa2bba )
            , ( bp::arg("fs") )
            , "\nWrapped function:"
    "\n    cvReleaseFileStorage"
    "\nArgument 'fs':"\
    "\n    C/C++ type: ::CvFileStorage * *."\
    "\n    Python type: Python equivalence of the C/C++ type without double "\
    "\n    pointer." );
    
    }

    { //::cvReleaseMemStorage
    
        typedef void ( *_cvReleaseMemStorage_function_type )( ::CvMemStorage );
        
        bp::def( 
            "_cvReleaseMemStorage"
            , _cvReleaseMemStorage_function_type( &cvReleaseMemStorage_6ff4687a489093fb83fd38fb1d920837 )
            , ( bp::arg("storage") )
            , "\nWrapped function:"
    "\n    cvReleaseMemStorage"
    "\nArgument 'storage':"\
    "\n    C/C++ type: ::CvMemStorage * *."\
    "\n    Python type: Python equivalence of the C/C++ type without double "\
    "\n    pointer." );
    
    }

    { //::cvReleasePOSITObject
    
        typedef void ( *_cvReleasePOSITObject_function_type )( ::CvPOSITObject );
        
        bp::def( 
            "_cvReleasePOSITObject"
            , _cvReleasePOSITObject_function_type( &cvReleasePOSITObject_679a5da1d4e28b86fdc9a28aa691c6ef )
            , ( bp::arg("posit_object") )
            , "\nWrapped function:"
    "\n    cvReleasePOSITObject"
    "\nArgument 'posit_object':"\
    "\n    C/C++ type: ::CvPOSITObject * *."\
    "\n    Python type: Python equivalence of the C/C++ type without double "\
    "\n    pointer." );
    
    }

    { //::cvReleaseStereoGCState
    
        typedef void ( *_cvReleaseStereoGCState_function_type )( ::CvStereoGCState );
        
        bp::def( 
            "_cvReleaseStereoGCState"
            , _cvReleaseStereoGCState_function_type( &cvReleaseStereoGCState_f9448f3f98670de75bac96972e1b9d45 )
            , ( bp::arg("state") )
            , "\nWrapped function:"
    "\n    cvReleaseStereoGCState"
    "\nArgument 'state':"\
    "\n    C/C++ type: ::CvStereoGCState * *."\
    "\n    Python type: Python equivalence of the C/C++ type without double "\
    "\n    pointer." );
    
    }

    { //::cvReprojectImageTo3D
    
        typedef void ( *reprojectImageTo3D_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,int );
        
        bp::def( 
            "reprojectImageTo3D"
            , reprojectImageTo3D_function_type( &cvReprojectImageTo3D_4ca87cd67ba33150d51d345f21a24447 )
            , ( bp::arg("disparityImage"), bp::arg("_3dImage"), bp::arg("Q"), bp::arg("handleMissingValues")=(int)(0) )
            , "\nWrapped function:"
    "\n    cvReprojectImageTo3D"
    "\nArgument 'Q':"\
    "\n    C/C++ type: ::CvMat const *."\
    "\n    Python type: Mat."\
    "\nArgument 'disparityImage':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument '_3dImage':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvRunningAvg
    
        typedef void ( *runningAvg_function_type )( ::cv::Mat &,::cv::Mat &,double,::cv::Mat );
        
        bp::def( 
            "runningAvg"
            , runningAvg_function_type( &cvRunningAvg_16515bd00db4472140aa21554e25bbc7 )
            , ( bp::arg("image"), bp::arg("acc"), bp::arg("alpha"), bp::arg("mask")=cv::Mat() )
            , "\nWrapped function:"
    "\n    cvRunningAvg"
    "\nArgument 'acc':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'image':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'mask':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvSURFPoint
    
        typedef boost::python::object ( *SURFPoint_function_type )( const ::cv::Point2f &,int,int,float,float );
        
        bp::def( 
            "SURFPoint"
            , SURFPoint_function_type( &cvSURFPoint_c0d89cc1fa2a754074aaa768acb95f48 )
            , ( bp::arg("pt"), bp::arg("laplacian"), bp::arg("size"), bp::arg("dir")=0, bp::arg("hessian")=0 )
            , "\nWrapped function:"
    "\n    cvSURFPoint"
    "\nArgument 'pt':"\
    "\n    C/C++ type: ::CvPoint2D32f."\
    "\n    Python type: Point2f." );
    
    }

    { //::cvSampleLine
    
        typedef boost::python::object ( *sampleLine_function_type )( ::cv::Mat &,::CvPoint,::CvPoint,void *,int );
        
        bp::def( 
            "sampleLine"
            , sampleLine_function_type( &cvSampleLine_9eb7a74db955c3538aef5be3e7392fc5 )
            , ( bp::arg("image"), bp::arg("pt1"), bp::arg("pt2"), bp::arg("buffer"), bp::arg("connectivity")=(int)(8) )
            , "\nWrapped function:"
    "\n    cvSampleLine"
    "\nArgument 'image':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvSegmentImage
    
        typedef boost::python::object ( *segmentImage_function_type )( ::cv::Mat &,::cv::Mat &,double,double,::CvMemStorage * );
        
        bp::def( 
            "segmentImage"
            , segmentImage_function_type( &cvSegmentImage_7b95313fd97ffe28d678124b5aa0a301 )
            , ( bp::arg("srcarr"), bp::arg("dstarr"), bp::arg("canny_threshold"), bp::arg("ffill_threshold"), bp::arg("storage") )
            , "\nWrapped function:"
    "\n    cvSegmentImage"
    "\nArgument 'dstarr':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'srcarr':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvSegmentMotion
    
        typedef boost::python::object ( *segmentMotion_function_type )( ::cv::Mat &,::cv::Mat &,::CvMemStorage *,double,double );
        
        bp::def( 
            "segmentMotion"
            , segmentMotion_function_type( &cvSegmentMotion_ed831c1d8f816ea759222aec4d41f1f0 )
            , ( bp::arg("mhi"), bp::arg("seg_mask"), bp::arg("storage"), bp::arg("timestamp"), bp::arg("seg_thresh") )
            , "\nWrapped function:"
    "\n    cvSegmentMotion"
    "\nArgument 'seg_mask':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'mhi':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvSeqInsertSlice
    
        typedef void ( *seqInsertSlice_function_type )( ::CvSeq *,int,::cv::Mat & );
        
        bp::def( 
            "seqInsertSlice"
            , seqInsertSlice_function_type( &cvSeqInsertSlice_870f54253b0103a244c6ac596f2820c4 )
            , ( bp::arg("seq"), bp::arg("before_index"), bp::arg("from_arr") )
            , "\nWrapped function:"
    "\n    cvSeqInsertSlice"
    "\nArgument 'from_arr':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvSetMouseCallback
    
        typedef boost::python::object ( *_cvSetMouseCallback_function_type )( char const *,boost::python::object,boost::python::object );
        
        bp::def( 
            "_cvSetMouseCallback"
            , _cvSetMouseCallback_function_type( &cvSetMouseCallback_c212defec0903d7de57c5c0b0ee9b03d )
            , ( bp::arg("window_name"), bp::arg("on_mouse"), bp::arg("param")=bp::object() )
            , "\nAssigns callback for mouse events."
    "\nWrapped function:"
    "\n    cvSetMouseCallback"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/c/user_interface.html#convertimage#setmousecallback"
    "\nArgument 'on_mouse' is a Python function that should look like below:"\
    "\n    def on_mouse(event, x, y, flags, user_data):"\
    "\n        ..."\
    "\nArgument 'param' is a Python object that is passed to function "\
    "\non_mouse() as 'user_data'." );
    
    }

    { //::cvSmooth
    
        typedef void ( *smooth_function_type )( ::cv::Mat &,::cv::Mat &,int,int,int,double,double );
        
        bp::def( 
            "smooth"
            , smooth_function_type( &cvSmooth_77e0c983f4273497b4a61c0a6dcda04f )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("smoothtype")=(int)(2), bp::arg("size1")=(int)(3), bp::arg("size2")=(int)(0), bp::arg("sigma1")=0, bp::arg("sigma2")=0 )
            , "\nWrapped function:"
    "\n    cvSmooth"
    "\nArgument 'src':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'dst':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvSolveCubic
    
        typedef boost::python::object ( *solveCubic_function_type )( ::cv::Mat &,::cv::Mat & );
        
        bp::def( 
            "solveCubic"
            , solveCubic_function_type( &cvSolveCubic_97d0ac3b0fc6ba46cd5b5f2eaea79583 )
            , ( bp::arg("coeffs"), bp::arg("roots") )
            , "\nWrapped function:"
    "\n    cvSolveCubic"
    "\nArgument 'coeffs':"\
    "\n    C/C++ type: ::CvMat const *."\
    "\n    Python type: Mat."\
    "\nArgument 'roots':"\
    "\n    C/C++ type: ::CvMat *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvSolvePoly
    
        typedef void ( *solvePoly_function_type )( ::cv::Mat &,::cv::Mat &,int,int );
        
        bp::def( 
            "solvePoly"
            , solvePoly_function_type( &cvSolvePoly_a7fe4b7abe368e2e780716aa49dc8f82 )
            , ( bp::arg("coeffs"), bp::arg("roots2"), bp::arg("maxiter")=(int)(20), bp::arg("fig")=(int)(100) )
            , "\nWrapped function:"
    "\n    cvSolvePoly"
    "\nArgument 'coeffs':"\
    "\n    C/C++ type: ::CvMat const *."\
    "\n    Python type: Mat."\
    "\nArgument 'roots2':"\
    "\n    C/C++ type: ::CvMat *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvSquareAcc
    
        typedef void ( *squareAcc_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat );
        
        bp::def( 
            "squareAcc"
            , squareAcc_function_type( &cvSquareAcc_df8ad076f822a2856ccecbbdf6a2b2b0 )
            , ( bp::arg("image"), bp::arg("sqsum"), bp::arg("mask")=cv::Mat() )
            , "\nWrapped function:"
    "\n    cvSquareAcc"
    "\nArgument 'mask':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'image':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'sqsum':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvStartFindContours
    
        typedef boost::python::object ( *startFindContours_function_type )( ::cv::Mat &,::CvMemStorage *,int,int,int,::CvPoint );
        
        bp::def( 
            "startFindContours"
            , startFindContours_function_type( &cvStartFindContours_1914ce1dccb0d5710ebdf49d4c3d96cc )
            , ( bp::arg("image"), bp::arg("storage"), bp::arg("header_size")=(int)(88u), bp::arg("mode")=(int)(1), bp::arg("method")=(int)(2), bp::arg("offset")=cv::Point(0, 0) )
            , "\nWrapped function:"
    "\n    cvStartFindContours"
    "\nArgument 'image':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvStartNextStream
    
        typedef void ( *startNextStream_function_type )( ::cv::FileStorage & );
        
        bp::def( 
            "startNextStream"
            , startNextStream_function_type( &cvStartNextStream_db71e53dfa9475145f4487a80d5d8bf2 )
            , ( bp::arg("fs") )
            , "\nWrapped function:"
    "\n    cvStartNextStream"
    "\nArgument 'fs':"\
    "\n    C/C++ type: ::CvFileStorage *."\
    "\n    Python type: FileStorage." );
    
    }

    { //::cvStartWriteStruct
    
        typedef void ( *startWriteStruct_function_type )( ::cv::FileStorage &,char const *,int,char const *,::CvAttrList );
        
        bp::def( 
            "startWriteStruct"
            , startWriteStruct_function_type( &cvStartWriteStruct_e7e2128639c3a858bdb332c89468a8e0 )
            , ( bp::arg("fs"), bp::arg("name"), bp::arg("struct_flags"), bp::arg("type_name")=bp::object(), bp::arg("attributes")=cvAttrList(0u, 0u) )
            , "\nWrapped function:"
    "\n    cvStartWriteStruct"
    "\nArgument 'fs':"\
    "\n    C/C++ type: ::CvFileStorage *."\
    "\n    Python type: FileStorage." );
    
    }

    { //::cvSubdiv2DLocate
    
        typedef boost::python::tuple ( *subdiv2DLocate_function_type )( ::CvSubdiv2D *,const ::cv::Point2f &,::CvSubdiv2DEdge * );
        
        bp::def( 
            "subdiv2DLocate"
            , subdiv2DLocate_function_type( &cvSubdiv2DLocate_1df86dbc29fc9de6df2bbdb2196d6db3 )
            , ( bp::arg("subdiv"), bp::arg("pt"), bp::arg("edge") )
            , "\nWrapped function:"
    "\n    cvSubdiv2DLocate"
    "\nArgument 'vertex':"\
    "\n    C/C++ type: ::CvSubdiv2DPoint * *."\
    "\n    Python type: Python equivalence of the C/C++ type without pointer."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)."\
    "\nArgument 'pt':"\
    "\n    C/C++ type: ::CvPoint2D32f."\
    "\n    Python type: Point2f." );
    
    }

    { //::cvSubdivDelaunay2DInsert
    
        typedef boost::python::object ( *subdivDelaunay2DInsert_function_type )( ::CvSubdiv2D *,const ::cv::Point2f & );
        
        bp::def( 
            "subdivDelaunay2DInsert"
            , subdivDelaunay2DInsert_function_type( &cvSubdivDelaunay2DInsert_0d66ff0b2bc8918d0793f968404f1cb2 )
            , ( bp::arg("subdiv"), bp::arg("pt") )
            , "\nWrapped function:"
    "\n    cvSubdivDelaunay2DInsert"
    "\nArgument 'pt':"\
    "\n    C/C++ type: ::CvPoint2D32f."\
    "\n    Python type: Point2f." );
    
    }

    { //::cvTriangleArea
    
        typedef boost::python::object ( *triangleArea_function_type )( const ::cv::Point2f &,const ::cv::Point2f &,const ::cv::Point2f & );
        
        bp::def( 
            "triangleArea"
            , triangleArea_function_type( &cvTriangleArea_727599fdabcae9fb78274a766e9dac94 )
            , ( bp::arg("a"), bp::arg("b"), bp::arg("c") )
            , "\nWrapped function:"
    "\n    cvTriangleArea"
    "\nArgument 'a':"\
    "\n    C/C++ type: ::CvPoint2D32f."\
    "\n    Python type: Point2f."\
    "\nArgument 'c':"\
    "\n    C/C++ type: ::CvPoint2D32f."\
    "\n    Python type: Point2f."\
    "\nArgument 'b':"\
    "\n    C/C++ type: ::CvPoint2D32f."\
    "\n    Python type: Point2f." );
    
    }

    { //::cvTriangulatePoints
    
        typedef void ( *triangulatePoints_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat & );
        
        bp::def( 
            "triangulatePoints"
            , triangulatePoints_function_type( &cvTriangulatePoints_eb948ff6300aa4ebf4fad0ec7d6d4e78 )
            , ( bp::arg("projMatr1"), bp::arg("projMatr2"), bp::arg("projPoints1"), bp::arg("projPoints2"), bp::arg("points4D") )
            , "\nWrapped function:"
    "\n    cvTriangulatePoints"
    "\nArgument 'projPoints2':"\
    "\n    C/C++ type: ::CvMat *."\
    "\n    Python type: Mat."\
    "\nArgument 'projPoints1':"\
    "\n    C/C++ type: ::CvMat *."\
    "\n    Python type: Mat."\
    "\nArgument 'projMatr2':"\
    "\n    C/C++ type: ::CvMat *."\
    "\n    Python type: Mat."\
    "\nArgument 'points4D':"\
    "\n    C/C++ type: ::CvMat *."\
    "\n    Python type: Mat."\
    "\nArgument 'projMatr1':"\
    "\n    C/C++ type: ::CvMat *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvTypeOf
    
        typedef boost::python::object ( *typeOf_function_type )( ::CvArr * );
        
        bp::def( 
            "typeOf"
            , typeOf_function_type( &cvTypeOf_4e7bd20b082b35b68253f04b04f578ce )
            , ( bp::arg("struct_ptr") )
            , "\nWrapped function:"
    "\n    cvTypeOf" );
    
    }

    { //::cvUpdateMotionHistory
    
        typedef void ( *updateMotionHistory_function_type )( ::cv::Mat &,::cv::Mat &,double,double );
        
        bp::def( 
            "updateMotionHistory"
            , updateMotionHistory_function_type( &cvUpdateMotionHistory_fb635b1eb55f77d94f46a70f41eac0b3 )
            , ( bp::arg("silhouette"), bp::arg("mhi"), bp::arg("timestamp"), bp::arg("duration") )
            , "\nWrapped function:"
    "\n    cvUpdateMotionHistory"
    "\nArgument 'silhouette':"\
    "\n    C/C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'mhi':"\
    "\n    C/C++ type: ::CvArr *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvWrite
    
        typedef void ( *write_function_type )( ::cv::FileStorage &,char const *,const char *,::CvAttrList );
        
        bp::def( 
            "write"
            , write_function_type( &cvWrite_00335cc764e72fb9408450c10fffab4a )
            , ( bp::arg("fs"), bp::arg("name"), bp::arg("ptr"), bp::arg("attributes")=cvAttrList(0u, 0u) )
            , "\nWrapped function:"
    "\n    cvWrite"
    "\nArgument 'fs':"\
    "\n    C/C++ type: ::CvFileStorage *."\
    "\n    Python type: FileStorage."\
    "\nArgument 'ptr':"\
    "\n    C/C++ type: void const *."\
    "\n    Python type: string." );
    
    }

    { //::cvWriteComment
    
        typedef void ( *writeComment_function_type )( ::cv::FileStorage &,char const *,int );
        
        bp::def( 
            "writeComment"
            , writeComment_function_type( &cvWriteComment_3e89473031f5fbea0ed6232440721138 )
            , ( bp::arg("fs"), bp::arg("comment"), bp::arg("eol_comment") )
            , "\nWrapped function:"
    "\n    cvWriteComment"
    "\nArgument 'fs':"\
    "\n    C/C++ type: ::CvFileStorage *."\
    "\n    Python type: FileStorage." );
    
    }

    { //::cvWriteFileNode
    
        typedef void ( *writeFileNode_function_type )( ::cv::FileStorage &,char const *,::cv::FileNode const &,int );
        
        bp::def( 
            "writeFileNode"
            , writeFileNode_function_type( &cvWriteFileNode_4df1ea107367e738fdd6f88f15146fb9 )
            , ( bp::arg("fs"), bp::arg("new_node_name"), bp::arg("node"), bp::arg("embed") )
            , "\nWrapped function:"
    "\n    cvWriteFileNode"
    "\nArgument 'node':"\
    "\n    C/C++ type: ::CvFileNode const *."\
    "\n    Python type: FileNode."\
    "\nArgument 'fs':"\
    "\n    C/C++ type: ::CvFileStorage *."\
    "\n    Python type: FileStorage." );
    
    }

    { //::cv::drawContours
    
        typedef void ( *drawContours_function_type )( ::cv::Mat &,bp::list const &,int,::cv::Scalar const &,int,int,cv::Mat const &,int,::cv::Point );
        
        bp::def( 
            "drawContours"
            , drawContours_function_type( &drawContours_03a5aed7ca57b253d8b3346ee2f05f74 )
            , ( bp::arg("image"), bp::arg("contours"), bp::arg("contourIdx"), bp::arg("color"), bp::arg("thickness")=(int)(1), bp::arg("lineType")=(int)(8), bp::arg("hierarchy")=convert_from_vector_of_T_to_Mat(std::vector<cv::Vec4i>()), bp::arg("maxLevel")=(int)(2147483647), bp::arg("offset")=cv::Point_<int>() )
            , "\nArgument 'hierarchy':"\
    "\n    C/C++ type: ::std::vector< cv::Vec<int, 4> > const &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\nArgument 'contours':"\
    "\n    C/C++ type: ::std::vector< std::vector< cv::Point_<int> > > const &."\
    "\n    Python type: list of Mat, e.g. [Mat(), Mat(), Mat()]."\
    "\n    Invoke asMat() to convert every 1D Python sequence into a Mat, e.g. "\
    "\n    [asMat([0,1,2]), asMat((0,1,2)]." );
    
    }

    { //::cv::ellipse2Poly
    
        typedef void ( *ellipse2Poly_function_type )( ::cv::Point,::cv::Size,int,int,int,int,cv::Mat & );
        
        bp::def( 
            "ellipse2Poly"
            , ellipse2Poly_function_type( &ellipse2Poly_a1937ebf152fa736fc27822db2e0081a )
            , ( bp::arg("center"), bp::arg("axes"), bp::arg("angle"), bp::arg("arcStart"), bp::arg("arcEnd"), bp::arg("delta"), bp::arg("pts") )
            , "\nApproximates an elliptic arc with a polyline."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/drawing_functions.html#cv-ellipse2poly"
    "\nArgument 'pts':"\
    "\n    C/C++ type: ::std::vector< cv::Point_<int> > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))." );
    
    }

    { //::cv::estimateAffine3D
    
        typedef boost::python::object ( *estimateAffine3D_function_type )( ::cv::Mat const &,::cv::Mat const &,::cv::Mat &,cv::Mat &,double,double );
        
        bp::def( 
            "estimateAffine3D"
            , estimateAffine3D_function_type( &estimateAffine3D_fd3dca5e5fd5d2ce4664db813a2c08bf )
            , ( bp::arg("from"), bp::arg("to"), bp::arg("out"), bp::arg("outliers"), bp::arg("param1")=3.0e+0, bp::arg("param2")=9.89999999999999991118215802998747676610946655273e-1 )
            , "\nArgument 'outliers':"\
    "\n    C/C++ type: ::std::vector< unsigned char > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))." );
    
    }

    { //::cv::fillConvexPoly
    
        typedef void ( *fillConvexPoly_function_type )( ::cv::Mat &,cv::Mat const &,::cv::Scalar const &,int,int );
        
        bp::def( 
            "fillConvexPoly"
            , fillConvexPoly_function_type( &fillConvexPoly_1312287b0cded13c02c57cc3d8ebf4b4 )
            , ( bp::arg("img"), bp::arg("pts"), bp::arg("color"), bp::arg("lineType")=(int)(8), bp::arg("shift")=(int)(0) )
            , "\nFills a convex polygon."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/drawing_functions.html#cv-fillconvexpoly"
    "\nArgument 'npts':"\
    "\n    Dependent argument: omitted from the function's calling sequence, as "\
    "\n    its value is derived from argument 'pts'."\
    "\nArgument 'pts':"\
    "\n    C/C++ type: ::cv::Point const *."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))." );
    
    }

    { //::cv::fillPoly
    
        typedef void ( *fillPoly_function_type )( ::cv::Mat &,bp::object const &,::cv::Scalar const &,int,int,::cv::Point );
        
        bp::def( 
            "fillPoly"
            , fillPoly_function_type( &fillPoly_e862cfcf1208f193efcd2bec59b744ec )
            , ( bp::arg("img"), bp::arg("pts"), bp::arg("color"), bp::arg("lineType")=(int)(8), bp::arg("shift")=(int)(0), bp::arg("offset")=cv::Point_<int>() )
            , "\nFills the area bounded by one or more polygons."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/drawing_functions.html#cv-fillpoly"
    "\nArgument 'npts':"\
    "\n    Dependent argument: omitted from the function's calling sequence, as "\
    "\n    its value is derived from argument 'pts'."\
    "\nArgument 'ncontours':"\
    "\n    Dependent argument: omitted from the function's calling sequence, as "\
    "\n    its value is derived from argument 'pts'."\
    "\nArgument 'pts':"\
    "\n    C/C++ type: ::cv::Point const * *."\
    "\n    Python type: 2d list."\
    "\n    Depending on its C++ argument type, it should be a list of Mats or a "\
    "\n    list of lists." );
    
    }

    { //::cv::find4QuadCornerSubpix
    
        typedef boost::python::object ( *find4QuadCornerSubpix_function_type )( ::cv::Mat const &,cv::Mat &,::cv::Size );
        
        bp::def( 
            "find4QuadCornerSubpix"
            , find4QuadCornerSubpix_function_type( &find4QuadCornerSubpix_ca00fc1537bfc5b612545bbb0796233b )
            , ( bp::arg("img"), bp::arg("corners"), bp::arg("region_size") )
            , "\nArgument 'corners':"\
    "\n    C/C++ type: ::std::vector< cv::Point_<float> > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))." );
    
    }

    { //::cv::findChessboardCorners
    
        typedef boost::python::tuple ( *findChessboardCorners_function_type )( ::cv::Mat const &,::cv::Size,int );
        
        bp::def( 
            "findChessboardCorners"
            , findChessboardCorners_function_type( &findChessboardCorners_dbf15a4ace0e613206118382aa1793ea )
            , ( bp::arg("image"), bp::arg("patternSize"), bp::arg("flags")=(int)(3) )
            , "\nArgument 'corners':"\
    "\n    C/C++ type: ::std::vector< cv::Point_<float> > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::findContours
    
        typedef boost::python::object ( *findContours_function_type )( ::cv::Mat &,int,int,::cv::Point );
        
        bp::def( 
            "findContours"
            , findContours_function_type( &findContours_664763de08e36b95bc7d4fcebc9ccbf7 )
            , ( bp::arg("image"), bp::arg("mode"), bp::arg("method"), bp::arg("offset")=cv::Point_<int>() )
            , "\nArgument 'contours':"\
    "\n    C/C++ type: ::std::vector< std::vector< cv::Point_<int> > > &."\
    "\n    Python type: list of Mat, e.g. [Mat(), Mat(), Mat()]."\
    "\n    Invoke asMat() to convert every 1D Python sequence into a Mat, e.g. "\
    "\n    [asMat([0,1,2]), asMat((0,1,2)]."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::findContours
    
        typedef boost::python::tuple ( *findContours_function_type )( ::cv::Mat &,int,int,::cv::Point );
        
        bp::def( 
            "findContours"
            , findContours_function_type( &findContours_369c42510a246d95804d68f7fdfbd8aa )
            , ( bp::arg("image"), bp::arg("mode"), bp::arg("method"), bp::arg("offset")=cv::Point_<int>() )
            , "\nArgument 'hierarchy':"\
    "\n    C/C++ type: ::std::vector< cv::Vec<int, 4> > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)."\
    "\nArgument 'contours':"\
    "\n    C/C++ type: ::std::vector< std::vector< cv::Point_<int> > > &."\
    "\n    Python type: list of Mat, e.g. [Mat(), Mat(), Mat()]."\
    "\n    Invoke asMat() to convert every 1D Python sequence into a Mat, e.g. "\
    "\n    [asMat([0,1,2]), asMat((0,1,2)]."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::findFundamentalMat
    
        typedef boost::python::tuple ( *findFundamentalMat2_function_type )( ::cv::Mat const &,::cv::Mat const &,int,double,double );
        
        bp::def( 
            "findFundamentalMat2"
            , findFundamentalMat2_function_type( &findFundamentalMat_4b8947da99452ee36abb2b044e941f4a )
            , ( bp::arg("points1"), bp::arg("points2"), bp::arg("method")=int(::cv::FM_RANSAC), bp::arg("param1")=3.0e+0, bp::arg("param2")=9.89999999999999991118215802998747676610946655273e-1 )
            , "\nWrapped function:"
    "\n    findFundamentalMat"
    "\nArgument 'mask':"\
    "\n    C/C++ type: ::std::vector< unsigned char > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::findHomography
    
        typedef boost::python::tuple ( *findHomography2_function_type )( ::cv::Mat const &,::cv::Mat const &,int,double );
        
        bp::def( 
            "findHomography2"
            , findHomography2_function_type( &findHomography_43999ba4bb258d7c74f144c8915f1665 )
            , ( bp::arg("srcPoints"), bp::arg("dstPoints"), bp::arg("method")=(int)(0), bp::arg("ransacReprojThreshold")=0 )
            , "\nWrapped function:"
    "\n    findHomography"
    "\nArgument 'mask':"\
    "\n    C/C++ type: ::std::vector< unsigned char > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::floodFill
    
        typedef boost::python::tuple ( *floodFill_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Point,::cv::Scalar,::cv::Scalar,::cv::Scalar,int );
        
        bp::def( 
            "floodFill"
            , floodFill_function_type( &floodFill_a833ccdf7b45572779d5c63d9adc2b15 )
            , ( bp::arg("image"), bp::arg("mask"), bp::arg("seedPoint"), bp::arg("newVal"), bp::arg("loDiff")=cv::Scalar_<double>(), bp::arg("upDiff")=cv::Scalar_<double>(), bp::arg("flags")=(int)(4) )
            , "\nArgument 'rect':"\
    "\n    C/C++ type: ::cv::Rect *."\
    "\n    Python type: Python equivalence of the C/C++ type without pointer."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::floodFill
    
        typedef boost::python::tuple ( *floodFill_function_type )( ::cv::Mat &,::cv::Point,::cv::Scalar,::cv::Scalar,::cv::Scalar,int );
        
        bp::def( 
            "floodFill"
            , floodFill_function_type( &floodFill_75a8a8f3e3e22b4d281bb304a7881151 )
            , ( bp::arg("image"), bp::arg("seedPoint"), bp::arg("newVal"), bp::arg("loDiff")=cv::Scalar_<double>(), bp::arg("upDiff")=cv::Scalar_<double>(), bp::arg("flags")=(int)(4) )
            , "\nArgument 'rect':"\
    "\n    C/C++ type: ::cv::Rect *."\
    "\n    Python type: Python equivalence of the C/C++ type without pointer."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::getAffineTransform
    
        typedef boost::python::object ( *getAffineTransform_function_type )( cv::Mat const &,cv::Mat const & );
        
        bp::def( 
            "getAffineTransform"
            , getAffineTransform_function_type( &getAffineTransform_aa493630c3e4efe1ff49141fe5060922 )
            , ( bp::arg("src"), bp::arg("dst") )
            , "\nArgument 'src':"\
    "\n    C/C++ type: ::cv::Point2f const *."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\nArgument 'dst':"\
    "\n    C/C++ type: ::cv::Point2f const *."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))." );
    
    }

    { //::cv::getOptimalNewCameraMatrix
    
        typedef boost::python::tuple ( *getOptimalNewCameraMatrix_function_type )( ::cv::Mat const &,::cv::Mat const &,::cv::Size,double,::cv::Size );
        
        bp::def( 
            "getOptimalNewCameraMatrix"
            , getOptimalNewCameraMatrix_function_type( &getOptimalNewCameraMatrix_e98b8ab28b52edfb3a210046fcf0527e )
            , ( bp::arg("cameraMatrix"), bp::arg("distCoeffs"), bp::arg("imageSize"), bp::arg("alpha"), bp::arg("newImgSize")=cv::Size_<int>() )
            , "\nArgument 'validPixROI':"\
    "\n    C/C++ type: ::cv::Rect *."\
    "\n    Python type: Python equivalence of the C/C++ type without pointer."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::getPerspectiveTransform
    
        typedef boost::python::object ( *getPerspectiveTransform_function_type )( cv::Mat const &,cv::Mat const & );
        
        bp::def( 
            "getPerspectiveTransform"
            , getPerspectiveTransform_function_type( &getPerspectiveTransform_c06a0392152cb20f6b57ae1ff2ac2c11 )
            , ( bp::arg("src"), bp::arg("dst") )
            , "\nArgument 'src':"\
    "\n    C/C++ type: ::cv::Point2f const *."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\nArgument 'dst':"\
    "\n    C/C++ type: ::cv::Point2f const *."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))." );
    
    }

    { //::cv::getTextSize
    
        typedef boost::python::tuple ( *getTextSize_function_type )( ::std::string const &,int,double,int );
        
        bp::def( 
            "getTextSize"
            , getTextSize_function_type( &getTextSize_efe6452b14ca0fcca5a50ca33199f5e7 )
            , ( bp::arg("text"), bp::arg("fontFace"), bp::arg("fontScale"), bp::arg("thickness") )
            , "\nCalculates the width and height of a text string."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/drawing_functions.html#cv-gettextsize"
    "\nArgument 'baseLine':"\
    "\n    C/C++ type: int *."\
    "\n    Python type: Python equivalence of the C/C++ type without pointer."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::goodFeaturesToTrack
    
        typedef boost::python::object ( *goodFeaturesToTrack_function_type )( ::cv::Mat const &,int,double,double,::cv::Mat const &,int,bool,double );
        
        bp::def( 
            "goodFeaturesToTrack"
            , goodFeaturesToTrack_function_type( &goodFeaturesToTrack_a887e3eb7b667339b1ac0c1a02f5735c )
            , ( bp::arg("image"), bp::arg("maxCorners"), bp::arg("qualityLevel"), bp::arg("minDistance"), bp::arg("mask")=cv::Mat(), bp::arg("blockSize")=(int)(3), bp::arg("useHarrisDetector")=(bool)(false), bp::arg("k")=4.00000000000000008326672684688674053177237510681e-2 )
            , "\nArgument 'corners':"\
    "\n    C/C++ type: ::std::vector< cv::Point_<float> > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::groupRectangles
    
        typedef void ( *groupRectangles_function_type )( cv::Mat &,cv::Mat &,int,double );
        
        bp::def( 
            "groupRectangles"
            , groupRectangles_function_type( &groupRectangles_d5f10e6823ff191659b8e372e1acdb8b )
            , ( bp::arg("rectList"), bp::arg("weights"), bp::arg("groupThreshold"), bp::arg("eps")=2.00000000000000011102230246251565404236316680908e-1 )
            , "\nArgument 'weights':"\
    "\n    C/C++ type: ::std::vector< int > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\nArgument 'rectList':"\
    "\n    C/C++ type: ::std::vector< cv::Rect_<int> > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))." );
    
    }

    { //::cv::groupRectangles
    
        typedef void ( *groupRectangles_function_type )( cv::Mat &,int,double );
        
        bp::def( 
            "groupRectangles"
            , groupRectangles_function_type( &groupRectangles_daddb1eb144574c44042d3cef39f8656 )
            , ( bp::arg("rectList"), bp::arg("groupThreshold"), bp::arg("eps")=2.00000000000000011102230246251565404236316680908e-1 )
            , "\nArgument 'rectList':"\
    "\n    C/C++ type: ::std::vector< cv::Rect_<int> > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))." );
    
    }

    { //::cv::imencode
    
        typedef boost::python::tuple ( *imencode_function_type )( ::std::string const &,::cv::Mat const &,cv::Mat const & );
        
        bp::def( 
            "imencode"
            , imencode_function_type( &imencode_7058867f40db2ceceebdc74b4943c841 )
            , ( bp::arg("ext"), bp::arg("img"), bp::arg("params")=convert_from_vector_of_T_to_Mat(std::vector<int>()) )
            , "\nEncode an image into a memory buffer."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/reading_and_writing_images_and_video.html#cv-imencode"
    "\nArgument 'params':"\
    "\n    C/C++ type: ::std::vector< int > const &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\nArgument 'buf':"\
    "\n    C/C++ type: ::std::vector< unsigned char > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::imwrite
    
        typedef boost::python::object ( *imwrite_function_type )( ::std::string const &,::cv::Mat const &,cv::Mat const & );
        
        bp::def( 
            "imwrite"
            , imwrite_function_type( &imwrite_08123c4d4c07e7af51577328378c9683 )
            , ( bp::arg("filename"), bp::arg("img"), bp::arg("params")=convert_from_vector_of_T_to_Mat(std::vector<int>()) )
            , "\nSaves an image to a specified file."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/reading_and_writing_images_and_video.html#cv-imwrite"
    "\nArgument 'params':"\
    "\n    C/C++ type: ::std::vector< int > const &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))." );
    
    }

    { //::cv::initCameraMatrix2D
    
        typedef boost::python::object ( *initCameraMatrix2D_function_type )( bp::list const &,bp::list const &,::cv::Size,double );
        
        bp::def( 
            "initCameraMatrix2D"
            , initCameraMatrix2D_function_type( &initCameraMatrix2D_a63e0813c9e7ddf60786347e47acca95 )
            , ( bp::arg("objectPoints"), bp::arg("imagePoints"), bp::arg("imageSize"), bp::arg("aspectRatio")=1.0e+0 )
            , "\nArgument 'objectPoints':"\
    "\n    C/C++ type: ::std::vector< std::vector< cv::Point3_<float> > > const "\
    "\n    &."\
    "\n    Python type: list of Mat, e.g. [Mat(), Mat(), Mat()]."\
    "\n    Invoke asMat() to convert every 1D Python sequence into a Mat, e.g. "\
    "\n    [asMat([0,1,2]), asMat((0,1,2)]."\
    "\nArgument 'imagePoints':"\
    "\n    C/C++ type: ::std::vector< std::vector< cv::Point_<float> > > const &."\
    "\n    Python type: list of Mat, e.g. [Mat(), Mat(), Mat()]."\
    "\n    Invoke asMat() to convert every 1D Python sequence into a Mat, e.g. "\
    "\n    [asMat([0,1,2]), asMat((0,1,2)]." );
    
    }

    { //::cv::kmeans
    
        typedef boost::python::tuple ( *kmeans_function_type )( ::cv::Mat const &,int,::cv::Mat &,::cv::TermCriteria,int,int );
        
        bp::def( 
            "kmeans"
            , kmeans_function_type( &kmeans_7acc1faebc4e430dbd210d93113e85c9 )
            , ( bp::arg("data"), bp::arg("K"), bp::arg("best_labels"), bp::arg("criteria"), bp::arg("attempts"), bp::arg("flags") )
            , "\nArgument 'centers':"\
    "\n    C/C++ type: ::cv::Mat *."\
    "\n    Python type: Python equivalence of the C/C++ type without pointer."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::merge
    
        typedef void ( *merge_function_type )( bp::list const &,::cv::MatND & );
        
        bp::def( 
            "merge"
            , merge_function_type( &merge_181a45f787822fd2b5f0d1797cf24cb9 )
            , ( bp::arg("mv"), bp::arg("dst") )
            , "\nComposes a multi-channel array from several single-channel arrays."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-merge"
    "\nArgument 'mv':"\
    "\n    C/C++ type: ::std::vector< cv::MatND > const &."\
    "\n    Python type: list of MatND, e.g. [MatND(), MatND(), MatND()]." );
    
    }

    { //::cv::merge
    
        typedef void ( *merge_function_type )( bp::list const &,::cv::Mat & );
        
        bp::def( 
            "merge"
            , merge_function_type( &merge_d67e402c11e8166727b306edf7cce556 )
            , ( bp::arg("mv"), bp::arg("dst") )
            , "\nComposes a multi-channel array from several single-channel arrays."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-merge"
    "\nArgument 'mv':"\
    "\n    C/C++ type: ::std::vector< cv::Mat > const &."\
    "\n    Python type: list of Mat, e.g. [Mat(), Mat(), Mat()]." );
    
    }

    { //::cv::minMaxLoc
    
        typedef boost::python::tuple ( *minMaxLoc_function_type )( ::cv::SparseMat const & );
        
        bp::def( 
            "minMaxLoc"
            , minMaxLoc_function_type( &minMaxLoc_5898fb91ebb58d1df6569148b5c62cce )
            , ( bp::arg("a") )
            , "\nFinds global minimum and maximum in a whole array or sub-array."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-minmaxloc"
    "\nArgument 'maxVal':"\
    "\n    C/C++ type: double *."\
    "\n    Python type: Python equivalence of the C/C++ type without pointer."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)."\
    "\nArgument 'minIdx':"\
    "\n    C/C++ type: int *."\
    "\n    Python type: Python equivalence of the C/C++ type without pointer."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)."\
    "\nArgument 'maxIdx':"\
    "\n    C/C++ type: int *."\
    "\n    Python type: Python equivalence of the C/C++ type without pointer."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)."\
    "\nArgument 'minVal':"\
    "\n    C/C++ type: double *."\
    "\n    Python type: Python equivalence of the C/C++ type without pointer."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::minMaxLoc
    
        typedef boost::python::tuple ( *minMaxLoc_function_type )( ::cv::MatND const &,::cv::MatND const & );
        
        bp::def( 
            "minMaxLoc"
            , minMaxLoc_function_type( &minMaxLoc_794fc6a6cce59bf895fdda1a015e64b1 )
            , ( bp::arg("a"), bp::arg("mask")=cv::MatND() )
            , "\nFinds global minimum and maximum in a whole array or sub-array."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-minmaxloc"
    "\nArgument 'maxVal':"\
    "\n    C/C++ type: double *."\
    "\n    Python type: Python equivalence of the C/C++ type without pointer."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)."\
    "\nArgument 'minIdx':"\
    "\n    C/C++ type: int *."\
    "\n    Python type: Python equivalence of the C/C++ type without pointer."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)."\
    "\nArgument 'maxIdx':"\
    "\n    C/C++ type: int *."\
    "\n    Python type: Python equivalence of the C/C++ type without pointer."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)."\
    "\nArgument 'minVal':"\
    "\n    C/C++ type: double *."\
    "\n    Python type: Python equivalence of the C/C++ type without pointer."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::minMaxLoc
    
        typedef boost::python::tuple ( *minMaxLoc_function_type )( ::cv::Mat const &,::cv::Mat const & );
        
        bp::def( 
            "minMaxLoc"
            , minMaxLoc_function_type( &minMaxLoc_35f2a2e80fcf305e891ee746d58be725 )
            , ( bp::arg("a"), bp::arg("mask")=cv::Mat() )
            , "\nFinds global minimum and maximum in a whole array or sub-array."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-minmaxloc"
    "\nArgument 'minLoc':"\
    "\n    C/C++ type: ::cv::Point *."\
    "\n    Python type: Python equivalence of the C/C++ type without pointer."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)."\
    "\nArgument 'maxVal':"\
    "\n    C/C++ type: double *."\
    "\n    Python type: Python equivalence of the C/C++ type without pointer."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)."\
    "\nArgument 'maxLoc':"\
    "\n    C/C++ type: ::cv::Point *."\
    "\n    Python type: Python equivalence of the C/C++ type without pointer."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)."\
    "\nArgument 'minVal':"\
    "\n    C/C++ type: double *."\
    "\n    Python type: Python equivalence of the C/C++ type without pointer."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::mixChannels
    
        typedef void ( *mixChannels_function_type )( bp::list const &,bp::list &,cv::Mat const &,int );
        
        bp::def( 
            "mixChannels"
            , mixChannels_function_type( &mixChannels_c8fa9614f4fb5a79f84423883d102a9e )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("fromTo"), bp::arg("npairs") )
            , "\nCopies specified channels from input arrays to the specified channels "
    "\nof output arrays."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-mixchannels"
    "\nArgument 'src':"\
    "\n    C/C++ type: ::std::vector< cv::MatND > const &."\
    "\n    Python type: list of MatND, e.g. [MatND(), MatND(), MatND()]."\
    "\nArgument 'dst':"\
    "\n    C/C++ type: ::std::vector< cv::MatND > &."\
    "\n    Python type: list of MatND, e.g. [MatND(), MatND(), MatND()]."\
    "\nArgument 'fromTo':"\
    "\n    C/C++ type: int const *."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))." );
    
    }

    { //::cv::mixChannels
    
        typedef void ( *mixChannels_function_type )( bp::list const &,bp::list &,cv::Mat const &,int );
        
        bp::def( 
            "mixChannels"
            , mixChannels_function_type( &mixChannels_269d2fa250748779c49641b632451e5f )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("fromTo"), bp::arg("npairs") )
            , "\nCopies specified channels from input arrays to the specified channels "
    "\nof output arrays."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-mixchannels"
    "\nArgument 'src':"\
    "\n    C/C++ type: ::std::vector< cv::Mat > const &."\
    "\n    Python type: list of Mat, e.g. [Mat(), Mat(), Mat()]."\
    "\nArgument 'dst':"\
    "\n    C/C++ type: ::std::vector< cv::Mat > &."\
    "\n    Python type: list of Mat, e.g. [Mat(), Mat(), Mat()]."\
    "\nArgument 'fromTo':"\
    "\n    C/C++ type: int const *."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))." );
    
    }

    { //::cv::polylines
    
        typedef void ( *polylines_function_type )( ::cv::Mat &,bp::object const &,bool,::cv::Scalar const &,int,int,int );
        
        bp::def( 
            "polylines"
            , polylines_function_type( &polylines_4b2b9aca4a0ee1864678eae6b982fcc0 )
            , ( bp::arg("img"), bp::arg("pts"), bp::arg("isClosed"), bp::arg("color"), bp::arg("thickness")=(int)(1), bp::arg("lineType")=(int)(8), bp::arg("shift")=(int)(0) )
            , "\nDraws several polygonal curves."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/drawing_functions.html#cv-polylines"
    "\nArgument 'npts':"\
    "\n    Dependent argument: omitted from the function's calling sequence, as "\
    "\n    its value is derived from argument 'pts'."\
    "\nArgument 'ncontours':"\
    "\n    Dependent argument: omitted from the function's calling sequence, as "\
    "\n    its value is derived from argument 'pts'."\
    "\nArgument 'pts':"\
    "\n    C/C++ type: ::cv::Point const * *."\
    "\n    Python type: 2d list."\
    "\n    Depending on its C++ argument type, it should be a list of Mats or a "\
    "\n    list of lists." );
    
    }

    { //::cv::projectPoints
    
        typedef boost::python::object ( *projectPoints2_function_type )( ::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,double );
        
        bp::def( 
            "projectPoints2"
            , projectPoints2_function_type( &projectPoints_c3cbd5f3e0c4a976b617302062632da4 )
            , ( bp::arg("objectPoints"), bp::arg("rvec"), bp::arg("tvec"), bp::arg("cameraMatrix"), bp::arg("distCoeffs"), bp::arg("dpdrot"), bp::arg("dpdt"), bp::arg("dpdf"), bp::arg("dpdc"), bp::arg("dpddist"), bp::arg("aspectRatio")=0 )
            , "\nWrapped function:"
    "\n    projectPoints"
    "\nArgument 'imagePoints':"\
    "\n    C/C++ type: ::std::vector< cv::Point_<float> > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::projectPoints
    
        typedef boost::python::object ( *projectPoints_function_type )( ::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Mat const & );
        
        bp::def( 
            "projectPoints"
            , projectPoints_function_type( &projectPoints_ce9cea7b4fadb5986d2a47a4d012fac0 )
            , ( bp::arg("objectPoints"), bp::arg("rvec"), bp::arg("tvec"), bp::arg("cameraMatrix"), bp::arg("distCoeffs") )
            , "\nArgument 'imagePoints':"\
    "\n    C/C++ type: ::std::vector< cv::Point_<float> > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::read
    
        typedef boost::python::object ( *read_list_of_KeyPoint_function_type )( ::cv::FileNode const & );
        
        bp::def( 
            "read_list_of_KeyPoint"
            , read_list_of_KeyPoint_function_type( &read_19f776a07d0494421b17575379bc2106 )
            , ( bp::arg("node") )
            , "\nWrapped function:"
    "\n    read"
    "\nArgument 'keypoints':"\
    "\n    C/C++ type: ::std::vector< cv::KeyPoint > &."\
    "\n    Python type: list."\
    "\n    To convert a Mat into a list, invoke one of Mat's member functions "\
    "\n    to_list_of_...()."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::read
    
        typedef boost::python::object ( *read_SparseMat_function_type )( ::cv::FileNode const &,::cv::SparseMat const & );
        
        bp::def( 
            "read_SparseMat"
            , read_SparseMat_function_type( &read_70c5e2668ef6bb953f654143837a7095 )
            , ( bp::arg("node"), bp::arg("default_mat")=cv::SparseMat() )
            , "\nWrapped function:"
    "\n    read"
    "\nArgument 'mat':"\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::read
    
        typedef boost::python::object ( *read_MatND_function_type )( ::cv::FileNode const &,::cv::MatND const & );
        
        bp::def( 
            "read_MatND"
            , read_MatND_function_type( &read_fcf3602693271e7c8a4e15ff65aede4c )
            , ( bp::arg("node"), bp::arg("default_mat")=cv::MatND() )
            , "\nWrapped function:"
    "\n    read"
    "\nArgument 'mat':"\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::read
    
        typedef boost::python::object ( *read_Mat_function_type )( ::cv::FileNode const &,::cv::Mat const & );
        
        bp::def( 
            "read_Mat"
            , read_Mat_function_type( &read_fd962997898e5b5f59cbef9efc942bcd )
            , ( bp::arg("node"), bp::arg("default_mat")=cv::Mat() )
            , "\nWrapped function:"
    "\n    read"
    "\nArgument 'mat':"\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::read
    
        typedef boost::python::object ( *read_str_function_type )( ::cv::FileNode const &,::std::string const & );
        
        bp::def( 
            "read_str"
            , read_str_function_type( &read_31e582223a7f98972af6d67b7558569e )
            , ( bp::arg("node"), bp::arg("default_value") )
            , "\nWrapped function:"
    "\n    read"
    "\nArgument 'value':"\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::read
    
        typedef boost::python::object ( *read_float64_function_type )( ::cv::FileNode const &,double );
        
        bp::def( 
            "read_float64"
            , read_float64_function_type( &read_9a054275260bdb7b0741c9b9e8cf5aae )
            , ( bp::arg("node"), bp::arg("default_value") )
            , "\nWrapped function:"
    "\n    read"
    "\nArgument 'value':"\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::read
    
        typedef boost::python::object ( *read_float32_function_type )( ::cv::FileNode const &,float );
        
        bp::def( 
            "read_float32"
            , read_float32_function_type( &read_9b06f36c44aa0d63d7f9f36cebc8d25f )
            , ( bp::arg("node"), bp::arg("default_value") )
            , "\nWrapped function:"
    "\n    read"
    "\nArgument 'value':"\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::read
    
        typedef boost::python::object ( *read_int_function_type )( ::cv::FileNode const &,int );
        
        bp::def( 
            "read_int"
            , read_int_function_type( &read_29c2b389d482b9f6d13cfbe5d7264926 )
            , ( bp::arg("node"), bp::arg("default_value") )
            , "\nWrapped function:"
    "\n    read"
    "\nArgument 'value':"\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::read
    
        typedef boost::python::object ( *read_int16_function_type )( ::cv::FileNode const &,short int );
        
        bp::def( 
            "read_int16"
            , read_int16_function_type( &read_62eac78db6563e1e714f1e282bf790db )
            , ( bp::arg("node"), bp::arg("default_value") )
            , "\nWrapped function:"
    "\n    read"
    "\nArgument 'value':"\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::read
    
        typedef boost::python::object ( *read_uint16_function_type )( ::cv::FileNode const &,::ushort );
        
        bp::def( 
            "read_uint16"
            , read_uint16_function_type( &read_81b0a1f4d595a311c77148001bd0046d )
            , ( bp::arg("node"), bp::arg("default_value") )
            , "\nWrapped function:"
    "\n    read"
    "\nArgument 'value':"\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::read
    
        typedef boost::python::object ( *read_int8_function_type )( ::cv::FileNode const &,::schar );
        
        bp::def( 
            "read_int8"
            , read_int8_function_type( &read_b68923bb48bf8de904fed0f0570414f5 )
            , ( bp::arg("node"), bp::arg("default_value") )
            , "\nWrapped function:"
    "\n    read"
    "\nArgument 'value':"\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::read
    
        typedef boost::python::object ( *read_uint8_function_type )( ::cv::FileNode const &,::uchar );
        
        bp::def( 
            "read_uint8"
            , read_uint8_function_type( &read_e3dbdb6033985682cd13b98ac06df84e )
            , ( bp::arg("node"), bp::arg("default_value") )
            , "\nWrapped function:"
    "\n    read"
    "\nArgument 'value':"\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::read
    
        typedef boost::python::object ( *read_bool_function_type )( ::cv::FileNode const &,bool );
        
        bp::def( 
            "read_bool"
            , read_bool_function_type( &read_2ba57a356ec17a70685f21fbad5a9438 )
            , ( bp::arg("node"), bp::arg("default_value") )
            , "\nWrapped function:"
    "\n    read"
    "\nArgument 'value':"\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::split
    
        typedef void ( *split_function_type )( ::cv::MatND const &,bp::list & );
        
        bp::def( 
            "split"
            , split_function_type( &split_12da852b2108a4c5223916b7b3caf48f )
            , ( bp::arg("m"), bp::arg("mv") )
            , "\nDivides multi-channel array into several single-channel arrays."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-split"
    "\nArgument 'mv':"\
    "\n    C/C++ type: ::std::vector< cv::MatND > &."\
    "\n    Python type: list of MatND, e.g. [MatND(), MatND(), MatND()]." );
    
    }

    { //::cv::split
    
        typedef void ( *split_function_type )( ::cv::Mat const &,bp::list & );
        
        bp::def( 
            "split"
            , split_function_type( &split_5e87cb7b08d019948a672b023e58e480 )
            , ( bp::arg("m"), bp::arg("mv") )
            , "\nDivides multi-channel array into several single-channel arrays."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-split"
    "\nArgument 'mv':"\
    "\n    C/C++ type: ::std::vector< cv::Mat > &."\
    "\n    Python type: list of Mat, e.g. [Mat(), Mat(), Mat()]." );
    
    }

    { //::cv::stereoCalibrate
    
        typedef boost::python::object ( *stereoCalibrate_function_type )( bp::list const &,bp::list const &,bp::list const &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Size,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::TermCriteria,int );
        
        bp::def( 
            "stereoCalibrate"
            , stereoCalibrate_function_type( &stereoCalibrate_14726b7172922289400130b4861f4a12 )
            , ( bp::arg("objectPoints"), bp::arg("imagePoints1"), bp::arg("imagePoints2"), bp::arg("cameraMatrix1"), bp::arg("distCoeffs1"), bp::arg("cameraMatrix2"), bp::arg("distCoeffs2"), bp::arg("imageSize"), bp::arg("R"), bp::arg("T"), bp::arg("E"), bp::arg("F"), bp::arg("criteria")=cv::TermCriteria(3, 30, 9.99999999999999954748111825886258685613938723691e-7), bp::arg("flags")=int(::cv::CALIB_FIX_INTRINSIC) )
            , "\nArgument 'objectPoints':"\
    "\n    C/C++ type: ::std::vector< std::vector< cv::Point3_<float> > > const "\
    "\n    &."\
    "\n    Python type: list of Mat, e.g. [Mat(), Mat(), Mat()]."\
    "\n    Invoke asMat() to convert every 1D Python sequence into a Mat, e.g. "\
    "\n    [asMat([0,1,2]), asMat((0,1,2)]."\
    "\nArgument 'imagePoints2':"\
    "\n    C/C++ type: ::std::vector< std::vector< cv::Point_<float> > > const &."\
    "\n    Python type: list of Mat, e.g. [Mat(), Mat(), Mat()]."\
    "\n    Invoke asMat() to convert every 1D Python sequence into a Mat, e.g. "\
    "\n    [asMat([0,1,2]), asMat((0,1,2)]."\
    "\nArgument 'imagePoints1':"\
    "\n    C/C++ type: ::std::vector< std::vector< cv::Point_<float> > > const &."\
    "\n    Python type: list of Mat, e.g. [Mat(), Mat(), Mat()]."\
    "\n    Invoke asMat() to convert every 1D Python sequence into a Mat, e.g. "\
    "\n    [asMat([0,1,2]), asMat((0,1,2)]." );
    
    }

    { //::cv::stereoRectify
    
        typedef boost::python::tuple ( *stereoRectify2_function_type )( ::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Size,::cv::Mat const &,::cv::Mat const &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,double,::cv::Size,int );
        
        bp::def( 
            "stereoRectify2"
            , stereoRectify2_function_type( &stereoRectify_82767028a891c6d71aa41b85e724aef7 )
            , ( bp::arg("cameraMatrix1"), bp::arg("distCoeffs1"), bp::arg("cameraMatrix2"), bp::arg("distCoeffs2"), bp::arg("imageSize"), bp::arg("R"), bp::arg("T"), bp::arg("R1"), bp::arg("R2"), bp::arg("P1"), bp::arg("P2"), bp::arg("Q"), bp::arg("alpha"), bp::arg("newImageSize")=cv::Size_<int>(), bp::arg("flags")=int(::cv::CALIB_ZERO_DISPARITY) )
            , "\nWrapped function:"
    "\n    stereoRectify"
    "\nArgument 'validPixROI2':"\
    "\n    C/C++ type: ::cv::Rect *."\
    "\n    Python type: Python equivalence of the C/C++ type without pointer."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)."\
    "\nArgument 'validPixROI1':"\
    "\n    C/C++ type: ::cv::Rect *."\
    "\n    Python type: Python equivalence of the C/C++ type without pointer."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::undistortPoints
    
        typedef boost::python::object ( *undistortPoints2_function_type )( ::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Mat const & );
        
        bp::def( 
            "undistortPoints2"
            , undistortPoints2_function_type( &undistortPoints_e5fdbe55500ffb118c2a9845da49f34b )
            , ( bp::arg("src"), bp::arg("cameraMatrix"), bp::arg("distCoeffs"), bp::arg("R")=cv::Mat(), bp::arg("P")=cv::Mat() )
            , "\nWrapped function:"
    "\n    undistortPoints"
    "\nArgument 'dst':"\
    "\n    C/C++ type: ::std::vector< cv::Point_<float> > &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))."\
    "\n    Output argument: omitted from the function's calling sequence, and is "\
    "\n    returned along with the function's return value (if any)." );
    
    }

    { //::cv::write
    
        typedef void ( *write_list_of_KeyPoint_function_type )( ::cv::FileStorage &,::std::string const &,bp::list const & );
        
        bp::def( 
            "write_list_of_KeyPoint"
            , write_list_of_KeyPoint_function_type( &write_df76e3ba45561ddd23c917a610929778 )
            , ( bp::arg("fs"), bp::arg("name"), bp::arg("keypoints") )
            , "\nWrapped function:"
    "\n    write"
    "\nArgument 'keypoints':"\
    "\n    C/C++ type: ::std::vector< cv::KeyPoint > const &."\
    "\n    Python type: list."\
    "\n    To convert a Mat into a list, invoke one of Mat's member functions "\
    "\n    to_list_of_...()." );
    
    }

    bp::to_python_converter<CvRNG, CvRNG_to_python, false>();

    bp::def("asVec4d", &sdcpp::from_ndarray< cv::Vec4d >, (bp::arg("inst_ndarray")) );

    bp::def("asVec3d", &sdcpp::from_ndarray< cv::Vec3d >, (bp::arg("inst_ndarray")) );

    bp::def("asVec2d", &sdcpp::from_ndarray< cv::Vec2d >, (bp::arg("inst_ndarray")) );

    bp::def("asVec4f", &sdcpp::from_ndarray< cv::Vec4f >, (bp::arg("inst_ndarray")) );

    bp::def("asVec3f", &sdcpp::from_ndarray< cv::Vec3f >, (bp::arg("inst_ndarray")) );

    bp::def("asVec2f", &sdcpp::from_ndarray< cv::Vec2f >, (bp::arg("inst_ndarray")) );

    bp::def("asVec4i", &sdcpp::from_ndarray< cv::Vec4i >, (bp::arg("inst_ndarray")) );

    bp::def("asVec3i", &sdcpp::from_ndarray< cv::Vec3i >, (bp::arg("inst_ndarray")) );

    bp::def("asVec2i", &sdcpp::from_ndarray< cv::Vec2i >, (bp::arg("inst_ndarray")) );

    bp::def("asVec4w", &sdcpp::from_ndarray< cv::Vec4w >, (bp::arg("inst_ndarray")) );

    bp::def("asVec3w", &sdcpp::from_ndarray< cv::Vec3w >, (bp::arg("inst_ndarray")) );

    bp::def("asVec2w", &sdcpp::from_ndarray< cv::Vec2w >, (bp::arg("inst_ndarray")) );

    bp::def("asVec4s", &sdcpp::from_ndarray< cv::Vec4s >, (bp::arg("inst_ndarray")) );

    bp::def("asVec3s", &sdcpp::from_ndarray< cv::Vec3s >, (bp::arg("inst_ndarray")) );

    bp::def("asVec2s", &sdcpp::from_ndarray< cv::Vec2s >, (bp::arg("inst_ndarray")) );

    bp::def("asVec4b", &sdcpp::from_ndarray< cv::Vec4b >, (bp::arg("inst_ndarray")) );

    bp::def("asVec3b", &sdcpp::from_ndarray< cv::Vec3b >, (bp::arg("inst_ndarray")) );

    bp::def("asVec2b", &sdcpp::from_ndarray< cv::Vec2b >, (bp::arg("inst_ndarray")) );

    bp::def("asVec6d", &sdcpp::from_ndarray< cv::Vec6d >, (bp::arg("inst_ndarray")) );

    bp::def("asVec6f", &sdcpp::from_ndarray< cv::Vec6f >, (bp::arg("inst_ndarray")) );

    bp::def("asPoint2i", &sdcpp::from_ndarray< cv::Point2i >, (bp::arg("inst_ndarray")) );

    bp::def("asPoint2f", &sdcpp::from_ndarray< cv::Point2f >, (bp::arg("inst_ndarray")) );

    bp::def("asPoint2d", &sdcpp::from_ndarray< cv::Point2d >, (bp::arg("inst_ndarray")) );

    bp::def("asPoint3i", &sdcpp::from_ndarray< cv::Point3i >, (bp::arg("inst_ndarray")) );

    bp::def("asPoint3f", &sdcpp::from_ndarray< cv::Point3f >, (bp::arg("inst_ndarray")) );

    bp::def("asPoint3d", &sdcpp::from_ndarray< cv::Point3d >, (bp::arg("inst_ndarray")) );

    bp::def("asSize2i", &sdcpp::from_ndarray< cv::Size2i >, (bp::arg("inst_ndarray")) );

    bp::def("asSize2d", &sdcpp::from_ndarray< cv::Size2d >, (bp::arg("inst_ndarray")) );

    bp::def("asSize2f", &sdcpp::from_ndarray< cv::Size2f >, (bp::arg("inst_ndarray")) );

    bp::def("asRect", &sdcpp::from_ndarray< cv::Rect >, (bp::arg("inst_ndarray")) );

    bp::def("asRectd", &sdcpp::from_ndarray< cv::Rectd >, (bp::arg("inst_ndarray")) );

    bp::def("asRectf", &sdcpp::from_ndarray< cv::Rectf >, (bp::arg("inst_ndarray")) );

    bp::def("asRotatedRect", &sdcpp::from_ndarray< cv::RotatedRect >, (bp::arg("inst_ndarray")) );

    bp::def("asScalar", &sdcpp::from_ndarray< cv::Scalar >, (bp::arg("inst_ndarray")) );

    bp::def("asRange", &sdcpp::from_ndarray< cv::Range >, (bp::arg("inst_ndarray")) );

    bp::def("asMat", &sdcpp::from_ndarray< cv::Mat >, (bp::arg("inst_ndarray")) );

    bp::def("asMatND", &sdcpp::from_ndarray< cv::MatND >, (bp::arg("inst_ndarray")) );

    bp::def( 
        "snakeImage"
        , &sdSnakeImage
        , ( bp::arg("image"), bp::arg("points"), bp::arg("alpha"), bp::arg("beta"), bp::arg("gamma"), bp::arg("coeff_usage"), bp::arg("win"), bp::arg("criteria"), bp::arg("calc_gradient")=(int)(1) ) );

    register_global_variables();

    register_free_functions();
}

