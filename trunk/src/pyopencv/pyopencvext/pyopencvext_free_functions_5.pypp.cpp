// This file has been generated by Py++.

#include "boost/python.hpp"
#include "opencv_headers.hpp"
#include "pyopencvext_free_functions_5.pypp.hpp"

namespace bp = boost::python;

void register_free_functions_5(){

    { //::cvFindDominantPoints
    
        typedef ::CvSeq * ( *findDominantPoints_function_type )( ::CvSeq *,::CvMemStorage *,int,double,double,double,double );
        
        bp::def( 
            "findDominantPoints"
            , findDominantPoints_function_type( &::cvFindDominantPoints )
            , ( bp::arg("contour"), bp::arg("storage"), bp::arg("method")=(int)(1), bp::arg("parameter1")=0, bp::arg("parameter2")=0, bp::arg("parameter3")=0, bp::arg("parameter4")=0 )
            , bp::with_custodian_and_ward_postcall< 0, 2, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvFindDominantPoints" );
    
    }

    { //::cvFindNextContour
    
        typedef ::CvSeq * ( *findNextContour_function_type )( ::CvContourScanner );
        
        bp::def( 
            "findNextContour"
            , findNextContour_function_type( &::cvFindNextContour )
            , ( bp::arg("scanner") )
            , bp::with_custodian_and_ward_postcall< 0, 1, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvFindNextContour" );
    
    }

    { //::cvFindType
    
        typedef ::CvTypeInfo * ( *findType_function_type )( char const * );
        
        bp::def( 
            "findType"
            , findType_function_type( &::cvFindType )
            , ( bp::arg("type_name") )
            , bp::return_value_policy< bp::reference_existing_object >()
            , "\nWrapped function:"
    "\n    cvFindType" );
    
    }

    { //::cvFirstType
    
        typedef ::CvTypeInfo * ( *firstType_function_type )(  );
        
        bp::def( 
            "firstType"
            , firstType_function_type( &::cvFirstType )
            , bp::return_value_policy< bp::reference_existing_object >()
            , "\nWrapped function:"
    "\n    cvFirstType" );
    
    }

    { //::cvFloor
    
        typedef int ( *floor_function_type )( double );
        
        bp::def( 
            "floor"
            , floor_function_type( &::cvFloor )
            , ( bp::arg("value") )
            , "\nWrapped function:"
    "\n    cvFloor" );
    
    }

    { //::cvFlushSeqWriter
    
        typedef void ( *flushSeqWriter_function_type )( ::CvSeqWriter * );
        
        bp::def( 
            "flushSeqWriter"
            , flushSeqWriter_function_type( &::cvFlushSeqWriter )
            , ( bp::arg("writer") )
            , "\nWrapped function:"
    "\n    cvFlushSeqWriter" );
    
    }

    { //::cvGetErrMode
    
        typedef int ( *getErrMode_function_type )(  );
        
        bp::def( 
            "getErrMode"
            , getErrMode_function_type( &::cvGetErrMode )
            , "\nWrapped function:"
    "\n    cvGetErrMode" );
    
    }

    { //::cvGetErrStatus
    
        typedef int ( *getErrStatus_function_type )(  );
        
        bp::def( 
            "getErrStatus"
            , getErrStatus_function_type( &::cvGetErrStatus )
            , "\nWrapped function:"
    "\n    cvGetErrStatus" );
    
    }

    { //::cvGetNumThreads
    
        typedef int ( *getNumThreads_function_type )(  );
        
        bp::def( 
            "getNumThreads"
            , getNumThreads_function_type( &::cvGetNumThreads )
            , "\nWrapped function:"
    "\n    cvGetNumThreads" );
    
    }

    { //::cvGetSeqReaderPos
    
        typedef int ( *getSeqReaderPos_function_type )( ::CvSeqReader * );
        
        bp::def( 
            "getSeqReaderPos"
            , getSeqReaderPos_function_type( &::cvGetSeqReaderPos )
            , ( bp::arg("reader") )
            , "\nWrapped function:"
    "\n    cvGetSeqReaderPos" );
    
    }

    { //::cvGetSetElem
    
        typedef ::CvSetElem * ( *getSetElem_function_type )( ::CvSet const *,int );
        
        bp::def( 
            "getSetElem"
            , getSetElem_function_type( &::cvGetSetElem )
            , ( bp::arg("set_header"), bp::arg("index") )
            , bp::with_custodian_and_ward_postcall< 0, 1, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvGetSetElem" );
    
    }

    { //::cvGetThreadNum
    
        typedef int ( *getThreadNum_function_type )(  );
        
        bp::def( 
            "getThreadNum"
            , getThreadNum_function_type( &::cvGetThreadNum )
            , "\nWrapped function:"
    "\n    cvGetThreadNum" );
    
    }

    { //::cvGetTickCount
    
        typedef ::int64 ( *getTickCount_function_type )(  );
        
        bp::def( 
            "getTickCount"
            , getTickCount_function_type( &::cvGetTickCount )
            , "\nWrapped function:"
    "\n    cvGetTickCount" );
    
    }

    { //::cvGetTickFrequency
    
        typedef double ( *getTickFrequency_function_type )(  );
        
        bp::def( 
            "getTickFrequency"
            , getTickFrequency_function_type( &::cvGetTickFrequency )
            , "\nWrapped function:"
    "\n    cvGetTickFrequency" );
    
    }

    { //::cvGetWindowName
    
        typedef char const * ( *getWindowName_function_type )( void * );
        
        bp::def( 
            "getWindowName"
            , getWindowName_function_type( &::cvGetWindowName )
            , ( bp::arg("window_handle") )
            , "\nGets the window's name by its handle."
    "\nWrapped function:"
    "\n    cvGetWindowName"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/c/user_interface.html#convertimage#getwindowname" );
    
    }

    { //::cvInitSubdivDelaunay2D
    
        typedef void ( *initSubdivDelaunay2D_function_type )( ::CvSubdiv2D *,::CvRect );
        
        bp::def( 
            "initSubdivDelaunay2D"
            , initSubdivDelaunay2D_function_type( &::cvInitSubdivDelaunay2D )
            , ( bp::arg("subdiv"), bp::arg("rect") )
            , "\nWrapped function:"
    "\n    cvInitSubdivDelaunay2D" );
    
    }

    { //::cvIsInf
    
        typedef int ( *isInf_function_type )( double );
        
        bp::def( 
            "isInf"
            , isInf_function_type( &::cvIsInf )
            , ( bp::arg("value") )
            , "\nWrapped function:"
    "\n    cvIsInf" );
    
    }

    { //::cvIsNaN
    
        typedef int ( *isNaN_function_type )( double );
        
        bp::def( 
            "isNaN"
            , isNaN_function_type( &::cvIsNaN )
            , ( bp::arg("value") )
            , "\nWrapped function:"
    "\n    cvIsNaN" );
    
    }

    { //::cvMatchContourTrees
    
        typedef double ( *matchContourTrees_function_type )( ::CvContourTree const *,::CvContourTree const *,int,double );
        
        bp::def( 
            "matchContourTrees"
            , matchContourTrees_function_type( &::cvMatchContourTrees )
            , ( bp::arg("tree1"), bp::arg("tree2"), bp::arg("method"), bp::arg("threshold") )
            , "\nWrapped function:"
    "\n    cvMatchContourTrees" );
    
    }

    { //::cvMaxRect
    
        typedef ::CvRect ( *maxRect_function_type )( ::CvRect const *,::CvRect const * );
        
        bp::def( 
            "maxRect"
            , maxRect_function_type( &::cvMaxRect )
            , ( bp::arg("rect1"), bp::arg("rect2") )
            , "\nWrapped function:"
    "\n    cvMaxRect" );
    
    }

    { //::cvMemStorageAllocString
    
        typedef ::CvString ( *memStorageAllocString_function_type )( ::CvMemStorage *,char const *,int );
        
        bp::def( 
            "memStorageAllocString"
            , memStorageAllocString_function_type( &::cvMemStorageAllocString )
            , ( bp::arg("storage"), bp::arg("ptr"), bp::arg("len")=(int)(-0x000000001) )
            , bp::with_custodian_and_ward_postcall< 0, 1 >()
            , "\nWrapped function:"
    "\n    cvMemStorageAllocString" );
    
    }

    { //::cvMoveWindow
    
        typedef void ( *moveWindow_function_type )( char const *,int,int );
        
        bp::def( 
            "moveWindow"
            , moveWindow_function_type( &::cvMoveWindow )
            , ( bp::arg("name"), bp::arg("x"), bp::arg("y") )
            , "\nSets the position of the window."
    "\nWrapped function:"
    "\n    cvMoveWindow"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/c/user_interface.html#convertimage#movewindow" );
    
    }

    { //::cvNextNArraySlice
    
        typedef int ( *nextNArraySlice_function_type )( ::CvNArrayIterator * );
        
        bp::def( 
            "nextNArraySlice"
            , nextNArraySlice_function_type( &::cvNextNArraySlice )
            , ( bp::arg("array_iterator") )
            , "\nWrapped function:"
    "\n    cvNextNArraySlice" );
    
    }

    { //::cvPOSIT
    
        typedef void ( *POSIT_function_type )( ::CvPOSITObject *,::CvPoint2D32f *,double,::CvTermCriteria,::CvMatr32f,::CvVect32f );
        
        bp::def( 
            "POSIT"
            , POSIT_function_type( &::cvPOSIT )
            , ( bp::arg("posit_object"), bp::arg("image_points"), bp::arg("focal_length"), bp::arg("criteria"), bp::arg("rotation_matrix"), bp::arg("translation_vector") )
            , "\nWrapped function:"
    "\n    cvPOSIT" );
    
    }

    { //::cvRANSACUpdateNumIters
    
        typedef int ( *RANSACUpdateNumIters_function_type )( double,double,int,int );
        
        bp::def( 
            "RANSACUpdateNumIters"
            , RANSACUpdateNumIters_function_type( &::cvRANSACUpdateNumIters )
            , ( bp::arg("p"), bp::arg("err_prob"), bp::arg("model_points"), bp::arg("max_iters") )
            , "\nWrapped function:"
    "\n    cvRANSACUpdateNumIters" );
    
    }

    { //::cvReadChainPoint
    
        typedef ::CvPoint ( *readChainPoint_function_type )( ::CvChainPtReader * );
        
        bp::def( 
            "readChainPoint"
            , readChainPoint_function_type( &::cvReadChainPoint )
            , ( bp::arg("reader") )
            , "\nWrapped function:"
    "\n    cvReadChainPoint" );
    
    }

    { //::cvRegisterModule
    
        typedef int ( *registerModule_function_type )( ::CvModuleInfo const * );
        
        bp::def( 
            "registerModule"
            , registerModule_function_type( &::cvRegisterModule )
            , ( bp::arg("module_info") )
            , "\nWrapped function:"
    "\n    cvRegisterModule" );
    
    }

    { //::cvRegisterType
    
        typedef void ( *registerType_function_type )( ::CvTypeInfo const * );
        
        bp::def( 
            "registerType"
            , registerType_function_type( &::cvRegisterType )
            , ( bp::arg("info") )
            , "\nWrapped function:"
    "\n    cvRegisterType" );
    
    }

    { //::cvReleaseFeatureTree
    
        typedef void ( *_cvReleaseFeatureTree_function_type )( ::CvFeatureTree * );
        
        bp::def( 
            "_cvReleaseFeatureTree"
            , _cvReleaseFeatureTree_function_type( &::cvReleaseFeatureTree )
            , ( bp::arg("tr") )
            , "\nWrapped function:"
    "\n    cvReleaseFeatureTree" );
    
    }

    { //::cvReleaseLSH
    
        typedef void ( *_cvReleaseLSH_function_type )( ::CvLSH * * );
        
        bp::def( 
            "_cvReleaseLSH"
            , _cvReleaseLSH_function_type( &::cvReleaseLSH )
            , ( bp::arg("lsh") )
            , "\nWrapped function:"
    "\n    cvReleaseLSH" );
    
    }

}
