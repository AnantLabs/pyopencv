// This file has been generated by Py++.

#include "boost/python.hpp"
#include "opencv_headers.hpp"
#include "pyopencvext_free_functions_6.pypp.hpp"

namespace bp = boost::python;

void register_free_functions_6(){

    { //::cvResizeWindow
    
        typedef void ( *resizeWindow_function_type )( char const *,int,int );
        
        bp::def( 
            "resizeWindow"
            , resizeWindow_function_type( &::cvResizeWindow )
            , ( bp::arg("name"), bp::arg("width"), bp::arg("height") )
            , "\nSets the window size."
    "\nWrapped function:"
    "\n    cvResizeWindow"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/c/user_interface.html#convertimage#resizewindow" );
    
    }

    { //::cvRestoreMemStoragePos
    
        typedef void ( *restoreMemStoragePos_function_type )( ::CvMemStorage *,::CvMemStoragePos * );
        
        bp::def( 
            "restoreMemStoragePos"
            , restoreMemStoragePos_function_type( &::cvRestoreMemStoragePos )
            , ( bp::arg("storage"), bp::arg("pos") )
            , "\nWrapped function:"
    "\n    cvRestoreMemStoragePos" );
    
    }

    { //::cvRound
    
        typedef int ( *round_function_type )( double );
        
        bp::def( 
            "round"
            , round_function_type( &::cvRound )
            , ( bp::arg("value") )
            , "\nWrapped function:"
    "\n    cvRound" );
    
    }

    { //::cvSaveMemStoragePos
    
        typedef void ( *saveMemStoragePos_function_type )( ::CvMemStorage const *,::CvMemStoragePos * );
        
        bp::def( 
            "saveMemStoragePos"
            , saveMemStoragePos_function_type( &::cvSaveMemStoragePos )
            , ( bp::arg("storage"), bp::arg("pos") )
            , "\nWrapped function:"
    "\n    cvSaveMemStoragePos" );
    
    }

    { //::cvSeqInvert
    
        typedef void ( *seqInvert_function_type )( ::CvSeq * );
        
        bp::def( 
            "seqInvert"
            , seqInvert_function_type( &::cvSeqInvert )
            , ( bp::arg("seq") )
            , "\nWrapped function:"
    "\n    cvSeqInvert" );
    
    }

    { //::cvSeqRemove
    
        typedef void ( *seqRemove_function_type )( ::CvSeq *,int );
        
        bp::def( 
            "seqRemove"
            , seqRemove_function_type( &::cvSeqRemove )
            , ( bp::arg("seq"), bp::arg("index") )
            , "\nWrapped function:"
    "\n    cvSeqRemove" );
    
    }

    { //::cvSeqRemoveSlice
    
        typedef void ( *seqRemoveSlice_function_type )( ::CvSeq *,::CvSlice );
        
        bp::def( 
            "seqRemoveSlice"
            , seqRemoveSlice_function_type( &::cvSeqRemoveSlice )
            , ( bp::arg("seq"), bp::arg("slice") )
            , "\nWrapped function:"
    "\n    cvSeqRemoveSlice" );
    
    }

    { //::cvSeqSlice
    
        typedef ::CvSeq * ( *seqSlice_function_type )( ::CvSeq const *,::CvSlice,::CvMemStorage *,int );
        
        bp::def( 
            "seqSlice"
            , seqSlice_function_type( &::cvSeqSlice )
            , ( bp::arg("seq"), bp::arg("slice"), bp::arg("storage")=bp::object(), bp::arg("copy_data")=(int)(0) )
            , bp::with_custodian_and_ward_postcall< 0, 3, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvSeqSlice" );
    
    }

    { //::cvSetErrMode
    
        typedef int ( *setErrMode_function_type )( int );
        
        bp::def( 
            "setErrMode"
            , setErrMode_function_type( &::cvSetErrMode )
            , ( bp::arg("mode") )
            , "\nWrapped function:"
    "\n    cvSetErrMode" );
    
    }

    { //::cvSetErrStatus
    
        typedef void ( *setErrStatus_function_type )( int );
        
        bp::def( 
            "setErrStatus"
            , setErrStatus_function_type( &::cvSetErrStatus )
            , ( bp::arg("status") )
            , "\nWrapped function:"
    "\n    cvSetErrStatus" );
    
    }

    { //::cvSetNumThreads
    
        typedef void ( *setNumThreads_function_type )( int );
        
        bp::def( 
            "setNumThreads"
            , setNumThreads_function_type( &::cvSetNumThreads )
            , ( bp::arg("threads")=(int)(0) )
            , "\nWrapped function:"
    "\n    cvSetNumThreads" );
    
    }

    { //::cvSetRemove
    
        typedef void ( *setRemove_function_type )( ::CvSet *,int );
        
        bp::def( 
            "setRemove"
            , setRemove_function_type( &::cvSetRemove )
            , ( bp::arg("set_header"), bp::arg("index") )
            , "\nWrapped function:"
    "\n    cvSetRemove" );
    
    }

    { //::cvSetSeqBlockSize
    
        typedef void ( *setSeqBlockSize_function_type )( ::CvSeq *,int );
        
        bp::def( 
            "setSeqBlockSize"
            , setSeqBlockSize_function_type( &::cvSetSeqBlockSize )
            , ( bp::arg("seq"), bp::arg("delta_elems") )
            , "\nWrapped function:"
    "\n    cvSetSeqBlockSize" );
    
    }

    { //::cvSetSeqReaderPos
    
        typedef void ( *setSeqReaderPos_function_type )( ::CvSeqReader *,int,int );
        
        bp::def( 
            "setSeqReaderPos"
            , setSeqReaderPos_function_type( &::cvSetSeqReaderPos )
            , ( bp::arg("reader"), bp::arg("index"), bp::arg("is_relative")=(int)(0) )
            , "\nWrapped function:"
    "\n    cvSetSeqReaderPos" );
    
    }

    { //::cvSliceLength
    
        typedef int ( *sliceLength_function_type )( ::CvSlice,::CvSeq const * );
        
        bp::def( 
            "sliceLength"
            , sliceLength_function_type( &::cvSliceLength )
            , ( bp::arg("slice"), bp::arg("seq") )
            , "\nWrapped function:"
    "\n    cvSliceLength" );
    
    }

    { //::cvStarKeypoint
    
        typedef ::CvStarKeypoint ( *starKeypoint_function_type )( ::CvPoint,int,float );
        
        bp::def( 
            "starKeypoint"
            , starKeypoint_function_type( &::cvStarKeypoint )
            , ( bp::arg("pt"), bp::arg("size"), bp::arg("response") )
            , "\nWrapped function:"
    "\n    cvStarKeypoint" );
    
    }

    { //::cvStartAppendToSeq
    
        typedef void ( *startAppendToSeq_function_type )( ::CvSeq *,::CvSeqWriter * );
        
        bp::def( 
            "startAppendToSeq"
            , startAppendToSeq_function_type( &::cvStartAppendToSeq )
            , ( bp::arg("seq"), bp::arg("writer") )
            , "\nWrapped function:"
    "\n    cvStartAppendToSeq" );
    
    }

    { //::cvStartReadChainPoints
    
        typedef void ( *startReadChainPoints_function_type )( ::CvChain *,::CvChainPtReader * );
        
        bp::def( 
            "startReadChainPoints"
            , startReadChainPoints_function_type( &::cvStartReadChainPoints )
            , ( bp::arg("chain"), bp::arg("reader") )
            , "\nWrapped function:"
    "\n    cvStartReadChainPoints" );
    
    }

    { //::cvStartReadSeq
    
        typedef void ( *startReadSeq_function_type )( ::CvSeq const *,::CvSeqReader *,int );
        
        bp::def( 
            "startReadSeq"
            , startReadSeq_function_type( &::cvStartReadSeq )
            , ( bp::arg("seq"), bp::arg("reader"), bp::arg("reverse")=(int)(0) )
            , "\nWrapped function:"
    "\n    cvStartReadSeq" );
    
    }

    { //::cvStartWindowThread
    
        typedef int ( *startWindowThread_function_type )(  );
        
        bp::def( 
            "startWindowThread"
            , startWindowThread_function_type( &::cvStartWindowThread )
            , "\nWrapped function:"
    "\n    cvStartWindowThread" );
    
    }

    { //::cvStartWriteSeq
    
        typedef void ( *startWriteSeq_function_type )( int,int,int,::CvMemStorage *,::CvSeqWriter * );
        
        bp::def( 
            "startWriteSeq"
            , startWriteSeq_function_type( &::cvStartWriteSeq )
            , ( bp::arg("seq_flags"), bp::arg("header_size"), bp::arg("elem_size"), bp::arg("storage"), bp::arg("writer") )
            , "\nWrapped function:"
    "\n    cvStartWriteSeq" );
    
    }

    { //::cvSubdiv2DEdgeDst
    
        typedef ::CvSubdiv2DPoint * ( *subdiv2DEdgeDst_function_type )( ::CvSubdiv2DEdge );
        
        bp::def( 
            "subdiv2DEdgeDst"
            , subdiv2DEdgeDst_function_type( &::cvSubdiv2DEdgeDst )
            , ( bp::arg("edge") )
            , bp::return_value_policy< bp::reference_existing_object >()
            , "\nWrapped function:"
    "\n    cvSubdiv2DEdgeDst" );
    
    }

    { //::cvSubdiv2DEdgeOrg
    
        typedef ::CvSubdiv2DPoint * ( *subdiv2DEdgeOrg_function_type )( ::CvSubdiv2DEdge );
        
        bp::def( 
            "subdiv2DEdgeOrg"
            , subdiv2DEdgeOrg_function_type( &::cvSubdiv2DEdgeOrg )
            , ( bp::arg("edge") )
            , bp::return_value_policy< bp::reference_existing_object >()
            , "\nWrapped function:"
    "\n    cvSubdiv2DEdgeOrg" );
    
    }

    { //::cvSubdiv2DGetEdge
    
        typedef ::CvSubdiv2DEdge ( *subdiv2DGetEdge_function_type )( ::CvSubdiv2DEdge,::CvNextEdgeType );
        
        bp::def( 
            "subdiv2DGetEdge"
            , subdiv2DGetEdge_function_type( &::cvSubdiv2DGetEdge )
            , ( bp::arg("edge"), bp::arg("type") )
            , "\nWrapped function:"
    "\n    cvSubdiv2DGetEdge" );
    
    }

    { //::cvSubdiv2DNextEdge
    
        typedef ::CvSubdiv2DEdge ( *subdiv2DNextEdge_function_type )( ::CvSubdiv2DEdge );
        
        bp::def( 
            "subdiv2DNextEdge"
            , subdiv2DNextEdge_function_type( &::cvSubdiv2DNextEdge )
            , ( bp::arg("edge") )
            , "\nWrapped function:"
    "\n    cvSubdiv2DNextEdge" );
    
    }

    { //::cvSubdiv2DRotateEdge
    
        typedef ::CvSubdiv2DEdge ( *subdiv2DRotateEdge_function_type )( ::CvSubdiv2DEdge,int );
        
        bp::def( 
            "subdiv2DRotateEdge"
            , subdiv2DRotateEdge_function_type( &::cvSubdiv2DRotateEdge )
            , ( bp::arg("edge"), bp::arg("rotate") )
            , "\nWrapped function:"
    "\n    cvSubdiv2DRotateEdge" );
    
    }

    { //::cvSubdiv2DSymEdge
    
        typedef ::CvSubdiv2DEdge ( *subdiv2DSymEdge_function_type )( ::CvSubdiv2DEdge );
        
        bp::def( 
            "subdiv2DSymEdge"
            , subdiv2DSymEdge_function_type( &::cvSubdiv2DSymEdge )
            , ( bp::arg("edge") )
            , "\nWrapped function:"
    "\n    cvSubdiv2DSymEdge" );
    
    }

    { //::cvSubstituteContour
    
        typedef void ( *substituteContour_function_type )( ::CvContourScanner,::CvSeq * );
        
        bp::def( 
            "substituteContour"
            , substituteContour_function_type( &::cvSubstituteContour )
            , ( bp::arg("scanner"), bp::arg("new_contour") )
            , "\nWrapped function:"
    "\n    cvSubstituteContour" );
    
    }

    { //::cvUnregisterType
    
        typedef void ( *unregisterType_function_type )( char const * );
        
        bp::def( 
            "unregisterType"
            , unregisterType_function_type( &::cvUnregisterType )
            , ( bp::arg("type_name") )
            , "\nWrapped function:"
    "\n    cvUnregisterType" );
    
    }

    { //::cvUseOptimized
    
        typedef int ( *useOptimized_function_type )( int );
        
        bp::def( 
            "useOptimized"
            , useOptimized_function_type( &::cvUseOptimized )
            , ( bp::arg("on_off") )
            , "\nWrapped function:"
    "\n    cvUseOptimized" );
    
    }

}
