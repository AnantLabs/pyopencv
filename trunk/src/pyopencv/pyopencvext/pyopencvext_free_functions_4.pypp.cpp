// This file has been generated by Py++.

#include "boost/python.hpp"
#include "with_ownershiplevel_postcall.hpp"
#include "opencv_headers.hpp"
#include "pyopencvext_free_functions_4.pypp.hpp"

namespace bp = boost::python;

void register_free_functions_4(){

    { //::cvCalcSubdivVoronoi2D
    
        typedef void ( *calcSubdivVoronoi2D_function_type )( ::CvSubdiv2D * );
        
        bp::def( 
            "calcSubdivVoronoi2D"
            , calcSubdivVoronoi2D_function_type( &::cvCalcSubdivVoronoi2D )
            , ( bp::arg("subdiv") )
            , "\nWrapped function:"
    "\n    cvCalcSubdivVoronoi2D" );
    
    }

    { //::cvCeil
    
        typedef int ( *ceil_function_type )( double );
        
        bp::def( 
            "ceil"
            , ceil_function_type( &::cvCeil )
            , ( bp::arg("value") )
            , "\nWrapped function:"
    "\n    cvCeil" );
    
    }

    { //::cvClearMemStorage
    
        typedef void ( *clearMemStorage_function_type )( ::CvMemStorage * );
        
        bp::def( 
            "clearMemStorage"
            , clearMemStorage_function_type( &::cvClearMemStorage )
            , ( bp::arg("storage") )
            , "\nWrapped function:"
    "\n    cvClearMemStorage" );
    
    }

    { //::cvClearSeq
    
        typedef void ( *clearSeq_function_type )( ::CvSeq * );
        
        bp::def( 
            "clearSeq"
            , clearSeq_function_type( &::cvClearSeq )
            , ( bp::arg("seq") )
            , "\nWrapped function:"
    "\n    cvClearSeq" );
    
    }

    { //::cvClearSet
    
        typedef void ( *clearSet_function_type )( ::CvSet * );
        
        bp::def( 
            "clearSet"
            , clearSet_function_type( &::cvClearSet )
            , ( bp::arg("set_header") )
            , "\nWrapped function:"
    "\n    cvClearSet" );
    
    }

    { //::cvClearSubdivVoronoi2D
    
        typedef void ( *clearSubdivVoronoi2D_function_type )( ::CvSubdiv2D * );
        
        bp::def( 
            "clearSubdivVoronoi2D"
            , clearSubdivVoronoi2D_function_type( &::cvClearSubdivVoronoi2D )
            , ( bp::arg("subdiv") )
            , "\nWrapped function:"
    "\n    cvClearSubdivVoronoi2D" );
    
    }

    { //::cvCloneSeq
    
        typedef ::CvSeq * ( *cloneSeq_function_type )( ::CvSeq const *,::CvMemStorage * );
        
        bp::def( 
            "cloneSeq"
            , cloneSeq_function_type( &::cvCloneSeq )
            , ( bp::arg("seq"), bp::arg("storage")=bp::object() )
            , bp::with_custodian_and_ward_postcall< 0, 2, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvCloneSeq" );
    
    }

    { //::cvConDensUpdateByTime
    
        typedef void ( *conDensUpdateByTime_function_type )( ::CvConDensation * );
        
        bp::def( 
            "conDensUpdateByTime"
            , conDensUpdateByTime_function_type( &::cvConDensUpdateByTime )
            , ( bp::arg("condens") )
            , "\nWrapped function:"
    "\n    cvConDensUpdateByTime" );
    
    }

    { //::cvContourFromContourTree
    
        typedef ::CvSeq * ( *contourFromContourTree_function_type )( ::CvContourTree const *,::CvMemStorage *,::CvTermCriteria );
        
        bp::def( 
            "contourFromContourTree"
            , contourFromContourTree_function_type( &::cvContourFromContourTree )
            , ( bp::arg("tree"), bp::arg("storage"), bp::arg("criteria") )
            , bp::with_custodian_and_ward_postcall< 0, 2, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvContourFromContourTree" );
    
    }

    { //::cvCreateChildMemStorage
    
        typedef ::CvMemStorage * ( *createChildMemStorage_function_type )( ::CvMemStorage * );
        
        bp::def( 
            "createChildMemStorage"
            , createChildMemStorage_function_type( &::cvCreateChildMemStorage )
            , ( bp::arg("parent") )
            , bp::with_custodian_and_ward_postcall< 0, 1, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvCreateChildMemStorage" );
    
    }

    { //::cvCreateConDensation
    
        typedef ::CvConDensation * ( *createConDensation_function_type )( int,int,int );
        
        bp::def( 
            "createConDensation"
            , createConDensation_function_type( &::cvCreateConDensation )
            , ( bp::arg("dynam_params"), bp::arg("measure_params"), bp::arg("sample_count") )
            , bp::with_ownershiplevel_postcall< 1, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvCreateConDensation" );
    
    }

    { //::cvCreateContourTree
    
        typedef ::CvContourTree * ( *createContourTree_function_type )( ::CvSeq const *,::CvMemStorage *,double );
        
        bp::def( 
            "createContourTree"
            , createContourTree_function_type( &::cvCreateContourTree )
            , ( bp::arg("contour"), bp::arg("storage"), bp::arg("threshold") )
            , bp::with_custodian_and_ward_postcall< 0, 2, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvCreateContourTree" );
    
    }

    { //::cvCreateLSH
    
        typedef ::CvLSH * ( *createLSH_function_type )( ::CvLSHOperations *,int,int,int,int,double,::int64 );
        
        bp::def( 
            "createLSH"
            , createLSH_function_type( &::cvCreateLSH )
            , ( bp::arg("ops"), bp::arg("d"), bp::arg("L")=(int)(10), bp::arg("k")=(int)(10), bp::arg("type")=(int)(6), bp::arg("r")=4, bp::arg("seed")=(::int64)(-0x000000001) )
            , bp::with_ownershiplevel_postcall< 1, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvCreateLSH" );
    
    }

    { //::cvCreateMemStorage
    
        typedef ::CvMemStorage * ( *createMemStorage_function_type )( int );
        
        bp::def( 
            "createMemStorage"
            , createMemStorage_function_type( &::cvCreateMemStorage )
            , ( bp::arg("block_size")=(int)(0) )
            , bp::with_ownershiplevel_postcall< 1, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvCreateMemStorage" );
    
    }

    { //::cvCreateMemoryLSH
    
        typedef ::CvLSH * ( *createMemoryLSH_function_type )( int,int,int,int,int,double,::int64 );
        
        bp::def( 
            "createMemoryLSH"
            , createMemoryLSH_function_type( &::cvCreateMemoryLSH )
            , ( bp::arg("d"), bp::arg("n"), bp::arg("L")=(int)(10), bp::arg("k")=(int)(10), bp::arg("type")=(int)(6), bp::arg("r")=4, bp::arg("seed")=(::int64)(-0x000000001) )
            , bp::with_ownershiplevel_postcall< 1, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvCreateMemoryLSH" );
    
    }

    { //::cvCreatePOSITObject
    
        typedef ::CvPOSITObject * ( *createPOSITObject_function_type )( ::CvPoint3D32f *,int );
        
        bp::def( 
            "createPOSITObject"
            , createPOSITObject_function_type( &::cvCreatePOSITObject )
            , ( bp::arg("points"), bp::arg("point_count") )
            , bp::with_ownershiplevel_postcall< 1, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvCreatePOSITObject" );
    
    }

    { //::cvCreateSeq
    
        typedef ::CvSeq * ( *createSeq_function_type )( int,int,int,::CvMemStorage * );
        
        bp::def( 
            "createSeq"
            , createSeq_function_type( &::cvCreateSeq )
            , ( bp::arg("seq_flags"), bp::arg("header_size"), bp::arg("elem_size"), bp::arg("storage") )
            , bp::with_custodian_and_ward_postcall< 0, 4, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvCreateSeq" );
    
    }

    { //::cvCreateSeqBlock
    
        typedef void ( *createSeqBlock_function_type )( ::CvSeqWriter * );
        
        bp::def( 
            "createSeqBlock"
            , createSeqBlock_function_type( &::cvCreateSeqBlock )
            , ( bp::arg("writer") )
            , "\nWrapped function:"
    "\n    cvCreateSeqBlock" );
    
    }

    { //::cvCreateSet
    
        typedef ::CvSet * ( *createSet_function_type )( int,int,int,::CvMemStorage * );
        
        bp::def( 
            "createSet"
            , createSet_function_type( &::cvCreateSet )
            , ( bp::arg("set_flags"), bp::arg("header_size"), bp::arg("elem_size"), bp::arg("storage") )
            , bp::with_custodian_and_ward_postcall< 0, 4, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvCreateSet" );
    
    }

    { //::cvCreateStereoGCState
    
        typedef ::CvStereoGCState * ( *createStereoGCState_function_type )( int,int );
        
        bp::def( 
            "createStereoGCState"
            , createStereoGCState_function_type( &::cvCreateStereoGCState )
            , ( bp::arg("numberOfDisparities"), bp::arg("maxIters") )
            , bp::with_ownershiplevel_postcall< 1, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvCreateStereoGCState" );
    
    }

    { //::cvCreateSubdiv2D
    
        typedef ::CvSubdiv2D * ( *createSubdiv2D_function_type )( int,int,int,int,::CvMemStorage * );
        
        bp::def( 
            "createSubdiv2D"
            , createSubdiv2D_function_type( &::cvCreateSubdiv2D )
            , ( bp::arg("subdiv_type"), bp::arg("header_size"), bp::arg("vtx_size"), bp::arg("quadedge_size"), bp::arg("storage") )
            , bp::with_custodian_and_ward_postcall< 0, 5, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvCreateSubdiv2D" );
    
    }

    { //::cvCreateSubdivDelaunay2D
    
        typedef ::CvSubdiv2D * ( *createSubdivDelaunay2D_function_type )( ::CvRect,::CvMemStorage * );
        
        bp::def( 
            "createSubdivDelaunay2D"
            , createSubdivDelaunay2D_function_type( &::cvCreateSubdivDelaunay2D )
            , ( bp::arg("rect"), bp::arg("storage") )
            , bp::with_custodian_and_ward_postcall< 0, 2, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvCreateSubdivDelaunay2D" );
    
    }

    { //::cvDestroyAllWindows
    
        typedef void ( *_cvDestroyAllWindows_function_type )(  );
        
        bp::def( 
            "_cvDestroyAllWindows"
            , _cvDestroyAllWindows_function_type( &::cvDestroyAllWindows )
            , "\nDestroys all of the HighGUI windows."
    "\nWrapped function:"
    "\n    cvDestroyAllWindows"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/c/user_interface.html#convertimage#destroyallwindows" );
    
    }

    { //::cvDestroyWindow
    
        typedef void ( *_cvDestroyWindow_function_type )( char const * );
        
        bp::def( 
            "_cvDestroyWindow"
            , _cvDestroyWindow_function_type( &::cvDestroyWindow )
            , ( bp::arg("name") )
            , "\nDestroys a window."
    "\nWrapped function:"
    "\n    cvDestroyWindow"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/c/user_interface.html#convertimage#destroywindow" );
    
    }

    { //::cvDetectedBlob
    
        typedef ::CvDetectedBlob ( *detectedBlob_function_type )( float,float,float,float,int,float );
        
        bp::def( 
            "detectedBlob"
            , detectedBlob_function_type( &::cvDetectedBlob )
            , ( bp::arg("x"), bp::arg("y"), bp::arg("w"), bp::arg("h"), bp::arg("ID")=(int)(0), bp::arg("response")=0.0f )
            , "\nWrapped function:"
    "\n    cvDetectedBlob" );
    
    }

    { //::cvEndFindContours
    
        typedef ::CvSeq * ( *_cvEndFindContours_function_type )( ::CvContourScanner * );
        
        bp::def( 
            "_cvEndFindContours"
            , _cvEndFindContours_function_type( &::cvEndFindContours )
            , ( bp::arg("scanner") )
            , bp::with_custodian_and_ward_postcall< 0, 1, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvEndFindContours" );
    
    }

    { //::cvEndWriteSeq
    
        typedef ::CvSeq * ( *endWriteSeq_function_type )( ::CvSeqWriter * );
        
        bp::def( 
            "endWriteSeq"
            , endWriteSeq_function_type( &::cvEndWriteSeq )
            , ( bp::arg("writer") )
            , bp::with_custodian_and_ward_postcall< 0, 1, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvEndWriteSeq" );
    
    }

    { //::cvError
    
        typedef void ( *error_function_type )( int,char const *,char const *,char const *,int );
        
        bp::def( 
            "error"
            , error_function_type( &::cvError )
            , ( bp::arg("status"), bp::arg("func_name"), bp::arg("err_msg"), bp::arg("file_name"), bp::arg("line") )
            , "\nWrapped function:"
    "\n    cvError" );
    
    }

    { //::cvErrorFromIppStatus
    
        typedef int ( *errorFromIppStatus_function_type )( int );
        
        bp::def( 
            "errorFromIppStatus"
            , errorFromIppStatus_function_type( &::cvErrorFromIppStatus )
            , ( bp::arg("ipp_status") )
            , "\nWrapped function:"
    "\n    cvErrorFromIppStatus" );
    
    }

    { //::cvErrorStr
    
        typedef char const * ( *errorStr_function_type )( int );
        
        bp::def( 
            "errorStr"
            , errorStr_function_type( &::cvErrorStr )
            , ( bp::arg("status") )
            , "\nWrapped function:"
    "\n    cvErrorStr" );
    
    }

}
