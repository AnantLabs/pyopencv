// This file has been generated by Py++.

#include "boost/python.hpp"
#include "opencv_headers.hpp"
#include "pyopencvext_free_functions_3.pypp.hpp"

namespace bp = boost::python;

void register_free_functions_3(){

    { //::cv::clipLine
    
        typedef bool ( *clipLine_function_type )( ::cv::Size,::cv::Point &,::cv::Point & );
        
        bp::def( 
            "clipLine"
            , clipLine_function_type( &::cv::clipLine )
            , ( bp::arg("imgSize"), bp::arg("pt1"), bp::arg("pt2") )
            , "\nClips the line against the image rectangle."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/drawing_functions.html#cv-clipline" );
    
    }

    { //::cv::compare
    
        typedef void ( *compare_function_type )( ::cv::MatND const &,double,::cv::MatND &,int );
        
        bp::def( 
            "compare"
            , compare_function_type( &::cv::compare )
            , ( bp::arg("a"), bp::arg("s"), bp::arg("c"), bp::arg("cmpop") )
            , "\nPerforms per-element comparison of two arrays or an array and scalar "
    "\nvalue."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#compare" );
    
    }

    { //::cv::compare
    
        typedef void ( *compare_function_type )( ::cv::MatND const &,::cv::MatND const &,::cv::MatND &,int );
        
        bp::def( 
            "compare"
            , compare_function_type( &::cv::compare )
            , ( bp::arg("a"), bp::arg("b"), bp::arg("c"), bp::arg("cmpop") )
            , "\nPerforms per-element comparison of two arrays or an array and scalar "
    "\nvalue."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#compare" );
    
    }

    { //::cv::compare
    
        typedef void ( *compare_function_type )( ::cv::Mat const &,double,::cv::Mat &,int );
        
        bp::def( 
            "compare"
            , compare_function_type( &::cv::compare )
            , ( bp::arg("a"), bp::arg("s"), bp::arg("c"), bp::arg("cmpop") )
            , "\nPerforms per-element comparison of two arrays or an array and scalar "
    "\nvalue."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#compare" );
    
    }

    { //::cv::compare
    
        typedef void ( *compare_function_type )( ::cv::Mat const &,::cv::Mat const &,::cv::Mat &,int );
        
        bp::def( 
            "compare"
            , compare_function_type( &::cv::compare )
            , ( bp::arg("a"), bp::arg("b"), bp::arg("c"), bp::arg("cmpop") )
            , "\nPerforms per-element comparison of two arrays or an array and scalar "
    "\nvalue."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#compare" );
    
    }

    { //::cv::compareHist
    
        typedef double ( *compareHist_function_type )( ::cv::SparseMat const &,::cv::SparseMat const &,int );
        
        bp::def( 
            "compareHist"
            , compareHist_function_type( &::cv::compareHist )
            , ( bp::arg("H1"), bp::arg("H2"), bp::arg("method") ) );
    
    }

    { //::cv::compareHist
    
        typedef double ( *compareHist_function_type )( ::cv::MatND const &,::cv::MatND const &,int );
        
        bp::def( 
            "compareHist"
            , compareHist_function_type( &::cv::compareHist )
            , ( bp::arg("H1"), bp::arg("H2"), bp::arg("method") ) );
    
    }

    { //::cv::completeSymm
    
        typedef void ( *completeSymm_function_type )( ::cv::Mat &,bool );
        
        bp::def( 
            "completeSymm"
            , completeSymm_function_type( &::cv::completeSymm )
            , ( bp::arg("a"), bp::arg("lowerToUpper")=(bool)(false) )
            , "\nCopies the lower or the upper half of a square matrix to another half."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#completesymm" );
    
    }

    { //::cv::composeRT
    
        typedef void ( *composeRT_function_type )( ::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat & );
        
        bp::def( 
            "composeRT"
            , composeRT_function_type( &::cv::composeRT )
            , ( bp::arg("rvec1"), bp::arg("tvec1"), bp::arg("rvec2"), bp::arg("tvec2"), bp::arg("rvec3"), bp::arg("tvec3"), bp::arg("dr3dr1"), bp::arg("dr3dt1"), bp::arg("dr3dr2"), bp::arg("dr3dt2"), bp::arg("dt3dr1"), bp::arg("dt3dt1"), bp::arg("dt3dr2"), bp::arg("dt3dt2") ) );
    
    }

    { //::cv::composeRT
    
        typedef void ( *composeRT_function_type )( ::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Mat &,::cv::Mat & );
        
        bp::def( 
            "composeRT"
            , composeRT_function_type( &::cv::composeRT )
            , ( bp::arg("rvec1"), bp::arg("tvec1"), bp::arg("rvec2"), bp::arg("tvec2"), bp::arg("rvec3"), bp::arg("tvec3") ) );
    
    }

    { //::cv::contourArea
    
        typedef double ( *contourArea_function_type )( ::cv::Mat const &,bool );
        
        bp::def( 
            "contourArea"
            , contourArea_function_type( &::cv::contourArea )
            , ( bp::arg("contour"), bp::arg("oriented")=(bool)(false) ) );
    
    }

    { //::cv::convertMaps
    
        typedef void ( *convertMaps_function_type )( ::cv::Mat const &,::cv::Mat const &,::cv::Mat &,::cv::Mat &,int,bool );
        
        bp::def( 
            "convertMaps"
            , convertMaps_function_type( &::cv::convertMaps )
            , ( bp::arg("map1"), bp::arg("map2"), bp::arg("dstmap1"), bp::arg("dstmap2"), bp::arg("dstmap1type"), bp::arg("nninterpolation")=(bool)(false) ) );
    
    }

    { //::cv::convertScaleAbs
    
        typedef void ( *convertScaleAbs_function_type )( ::cv::Mat const &,::cv::Mat &,double,double );
        
        bp::def( 
            "convertScaleAbs"
            , convertScaleAbs_function_type( &::cv::convertScaleAbs )
            , ( bp::arg("a"), bp::arg("c"), bp::arg("alpha")=1, bp::arg("beta")=0 )
            , "\nScales, computes absolute values and converts the result to 8-bit."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#convertscaleabs" );
    
    }

    { //::cv::copyMakeBorder
    
        typedef void ( *copyMakeBorder_function_type )( ::cv::Mat const &,::cv::Mat &,int,int,int,int,int,::cv::Scalar const & );
        
        bp::def( 
            "copyMakeBorder"
            , copyMakeBorder_function_type( &::cv::copyMakeBorder )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("top"), bp::arg("bottom"), bp::arg("left"), bp::arg("right"), bp::arg("borderType"), bp::arg("value")=cv::Scalar_<double>() ) );
    
    }

    { //::cv::cornerEigenValsAndVecs
    
        typedef void ( *cornerEigenValsAndVecs_function_type )( ::cv::Mat const &,::cv::Mat &,int,int,int );
        
        bp::def( 
            "cornerEigenValsAndVecs"
            , cornerEigenValsAndVecs_function_type( &::cv::cornerEigenValsAndVecs )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("blockSize"), bp::arg("ksize"), bp::arg("borderType")=int(::cv::BORDER_REFLECT_101) ) );
    
    }

    { //::cv::cornerHarris
    
        typedef void ( *cornerHarris_function_type )( ::cv::Mat const &,::cv::Mat &,int,int,double,int );
        
        bp::def( 
            "cornerHarris"
            , cornerHarris_function_type( &::cv::cornerHarris )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("blockSize"), bp::arg("ksize"), bp::arg("k"), bp::arg("borderType")=int(::cv::BORDER_REFLECT_101) ) );
    
    }

    { //::cv::cornerMinEigenVal
    
        typedef void ( *cornerMinEigenVal_function_type )( ::cv::Mat const &,::cv::Mat &,int,int,int );
        
        bp::def( 
            "cornerMinEigenVal"
            , cornerMinEigenVal_function_type( &::cv::cornerMinEigenVal )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("blockSize"), bp::arg("ksize")=(int)(3), bp::arg("borderType")=int(::cv::BORDER_REFLECT_101) ) );
    
    }

    { //::cv::countNonZero
    
        typedef int ( *countNonZero_function_type )( ::cv::MatND const & );
        
        bp::def( 
            "countNonZero"
            , countNonZero_function_type( &::cv::countNonZero )
            , ( bp::arg("m") )
            , "\nCounts non-zero array elements."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#countnonzero" );
    
    }

    { //::cv::countNonZero
    
        typedef int ( *countNonZero_function_type )( ::cv::Mat const & );
        
        bp::def( 
            "countNonZero"
            , countNonZero_function_type( &::cv::countNonZero )
            , ( bp::arg("m") )
            , "\nCounts non-zero array elements."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#countnonzero" );
    
    }

    { //::cv::createBoxFilter
    
        typedef ::cv::Ptr< cv::FilterEngine > ( *createBoxFilter_function_type )( int,int,::cv::Size,::cv::Point,bool,int );
        
        bp::def( 
            "createBoxFilter"
            , createBoxFilter_function_type( &::cv::createBoxFilter )
            , ( bp::arg("srcType"), bp::arg("dstType"), bp::arg("ksize"), bp::arg("anchor")=cv::Point_<int>(-0x000000001, -0x000000001), bp::arg("normalize")=(bool)(true), bp::arg("borderType")=int(::cv::BORDER_REFLECT_101) ) );
    
    }

    { //::cv::createDerivFilter
    
        typedef ::cv::Ptr< cv::FilterEngine > ( *createDerivFilter_function_type )( int,int,int,int,int,int );
        
        bp::def( 
            "createDerivFilter"
            , createDerivFilter_function_type( &::cv::createDerivFilter )
            , ( bp::arg("srcType"), bp::arg("dstType"), bp::arg("dx"), bp::arg("dy"), bp::arg("ksize"), bp::arg("borderType")=int(::cv::BORDER_REFLECT_101) ) );
    
    }

    { //::cv::createGaussianFilter
    
        typedef ::cv::Ptr< cv::FilterEngine > ( *createGaussianFilter_function_type )( int,::cv::Size,double,double,int );
        
        bp::def( 
            "createGaussianFilter"
            , createGaussianFilter_function_type( &::cv::createGaussianFilter )
            , ( bp::arg("type"), bp::arg("ksize"), bp::arg("sigma1"), bp::arg("sigma2")=0, bp::arg("borderType")=int(::cv::BORDER_REFLECT_101) ) );
    
    }

    { //::cv::createLinearFilter
    
        typedef ::cv::Ptr< cv::FilterEngine > ( *createLinearFilter_function_type )( int,int,::cv::Mat const &,::cv::Point,double,int,int,::cv::Scalar const & );
        
        bp::def( 
            "createLinearFilter"
            , createLinearFilter_function_type( &::cv::createLinearFilter )
            , ( bp::arg("srcType"), bp::arg("dstType"), bp::arg("kernel"), bp::arg("_anchor")=cv::Point_<int>(-0x000000001, -0x000000001), bp::arg("delta")=0, bp::arg("_rowBorderType")=int(::cv::BORDER_REFLECT_101), bp::arg("_columnBorderType")=(int)(-0x000000001), bp::arg("_borderValue")=cv::Scalar_<double>() ) );
    
    }

    { //::cv::createMorphologyFilter
    
        typedef ::cv::Ptr< cv::FilterEngine > ( *createMorphologyFilter_function_type )( int,int,::cv::Mat const &,::cv::Point,int,int,::cv::Scalar const & );
        
        bp::def( 
            "createMorphologyFilter"
            , createMorphologyFilter_function_type( &::cv::createMorphologyFilter )
            , ( bp::arg("op"), bp::arg("type"), bp::arg("kernel"), bp::arg("anchor")=cv::Point_<int>(-0x000000001, -0x000000001), bp::arg("_rowBorderType")=int(::cv::BORDER_CONSTANT), bp::arg("_columnBorderType")=(int)(-0x000000001), bp::arg("_borderValue")=cv::morphologyDefaultBorderValue( ) ) );
    
    }

    { //::cv::createSeparableLinearFilter
    
        typedef ::cv::Ptr< cv::FilterEngine > ( *createSeparableLinearFilter_function_type )( int,int,::cv::Mat const &,::cv::Mat const &,::cv::Point,double,int,int,::cv::Scalar const & );
        
        bp::def( 
            "createSeparableLinearFilter"
            , createSeparableLinearFilter_function_type( &::cv::createSeparableLinearFilter )
            , ( bp::arg("srcType"), bp::arg("dstType"), bp::arg("rowKernel"), bp::arg("columnKernel"), bp::arg("_anchor")=cv::Point_<int>(-0x000000001, -0x000000001), bp::arg("delta")=0, bp::arg("_rowBorderType")=int(::cv::BORDER_REFLECT_101), bp::arg("_columnBorderType")=(int)(-0x000000001), bp::arg("_borderValue")=cv::Scalar_<double>() ) );
    
    }

    { //::cv::cubeRoot
    
        typedef float ( *cubeRoot_function_type )( float );
        
        bp::def( 
            "cubeRoot"
            , cubeRoot_function_type( &::cv::cubeRoot )
            , ( bp::arg("val") )
            , "\nComputes cube root of the argument."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-cuberoot" );
    
    }

    { //::cvApproxChains
    
        typedef ::CvSeq * ( *approxChains_function_type )( ::CvSeq *,::CvMemStorage *,int,double,int,int );
        
        bp::def( 
            "approxChains"
            , approxChains_function_type( &::cvApproxChains )
            , ( bp::arg("src_seq"), bp::arg("storage"), bp::arg("method")=(int)(2), bp::arg("parameter")=0, bp::arg("minimal_perimeter")=(int)(0), bp::arg("recursive")=(int)(0) )
            , bp::with_custodian_and_ward_postcall< 0, 2, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvApproxChains" );
    
    }

    { //::cvAttrValue
    
        typedef char const * ( *attrValue_function_type )( ::CvAttrList const *,char const * );
        
        bp::def( 
            "attrValue"
            , attrValue_function_type( &::cvAttrValue )
            , ( bp::arg("attr"), bp::arg("attr_name") )
            , "\nWrapped function:"
    "\n    cvAttrValue" );
    
    }

    { //::cvBlob
    
        typedef ::CvBlob ( *blob_function_type )( float,float,float,float );
        
        bp::def( 
            "blob"
            , blob_function_type( &::cvBlob )
            , ( bp::arg("x"), bp::arg("y"), bp::arg("w"), bp::arg("h") )
            , "\nWrapped function:"
    "\n    cvBlob" );
    
    }

    { //::cvBoxPoints
    
        typedef void ( *boxPoints_function_type )( ::CvBox2D,::CvPoint2D32f * );
        
        bp::def( 
            "boxPoints"
            , boxPoints_function_type( &::cvBoxPoints )
            , ( bp::arg("box"), bp::arg("pt") )
            , "\nWrapped function:"
    "\n    cvBoxPoints" );
    
    }

}
