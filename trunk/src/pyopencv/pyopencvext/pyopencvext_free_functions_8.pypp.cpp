// This file has been generated by Py++.

#include "boost/python.hpp"
#include "opencv_headers.hpp"
#include "pyopencvext_free_functions_8.pypp.hpp"

namespace bp = boost::python;

void register_free_functions_8(){

    { //::cv::flip
    
        typedef void ( *flip_function_type )( ::cv::Mat const &,::cv::Mat &,int );
        
        bp::def( 
            "flip"
            , flip_function_type( &::cv::flip )
            , ( bp::arg("a"), bp::arg("b"), bp::arg("flipCode") )
            , "\nFlips a 2D array around vertical, horizontal or both axes."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-flip" );
    
    }

    { //::cv::fromUtf16
    
        typedef ::std::string ( *fromUtf16_function_type )( ::cv::WString const & );
        
        bp::def( 
            "fromUtf16"
            , fromUtf16_function_type( &::cv::fromUtf16 )
            , ( bp::arg("str") ) );
    
    }

    { //::cv::gemm
    
        typedef void ( *gemm_function_type )( ::cv::Mat const &,::cv::Mat const &,double,::cv::Mat const &,double,::cv::Mat &,int );
        
        bp::def( 
            "gemm"
            , gemm_function_type( &::cv::gemm )
            , ( bp::arg("a"), bp::arg("b"), bp::arg("alpha"), bp::arg("c"), bp::arg("gamma"), bp::arg("d"), bp::arg("flags")=(int)(0) )
            , "\nPerforms generalized matrix multiplication."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-gemm" );
    
    }

    { //::cv::getCPUTickCount
    
        typedef ::int64 ( *getCPUTickCount_function_type )(  );
        
        bp::def( 
            "getCPUTickCount"
            , getCPUTickCount_function_type( &::cv::getCPUTickCount ) );
    
    }

    { //::cv::getColumnSumFilter
    
        typedef ::cv::Ptr< cv::BaseColumnFilter > ( *getColumnSumFilter_function_type )( int,int,int,int,double );
        
        bp::def( 
            "getColumnSumFilter"
            , getColumnSumFilter_function_type( &::cv::getColumnSumFilter )
            , ( bp::arg("sumType"), bp::arg("dstType"), bp::arg("ksize"), bp::arg("anchor")=(int)(-0x000000001), bp::arg("scale")=1 ) );
    
    }

    { //::cv::getDefaultNewCameraMatrix
    
        typedef ::cv::Mat ( *getDefaultNewCameraMatrix_function_type )( ::cv::Mat const &,::cv::Size,bool );
        
        bp::def( 
            "getDefaultNewCameraMatrix"
            , getDefaultNewCameraMatrix_function_type( &::cv::getDefaultNewCameraMatrix )
            , ( bp::arg("cameraMatrix"), bp::arg("imgsize")=cv::Size_<int>(), bp::arg("centerPrincipalPoint")=(bool)(false) ) );
    
    }

    { //::cv::getDerivKernels
    
        typedef void ( *getDerivKernels_function_type )( ::cv::Mat &,::cv::Mat &,int,int,int,bool,int );
        
        bp::def( 
            "getDerivKernels"
            , getDerivKernels_function_type( &::cv::getDerivKernels )
            , ( bp::arg("kx"), bp::arg("ky"), bp::arg("dx"), bp::arg("dy"), bp::arg("ksize"), bp::arg("normalize")=(bool)(false), bp::arg("ktype")=(int)(5) ) );
    
    }

    { //::cv::getElemSize
    
        typedef ::size_t ( *getElemSize_function_type )( int );
        
        bp::def( 
            "getElemSize"
            , getElemSize_function_type( &::cv::getElemSize )
            , ( bp::arg("type") ) );
    
    }

    { //::cv::getGaussianKernel
    
        typedef ::cv::Mat ( *getGaussianKernel_function_type )( int,double,int );
        
        bp::def( 
            "getGaussianKernel"
            , getGaussianKernel_function_type( &::cv::getGaussianKernel )
            , ( bp::arg("ksize"), bp::arg("sigma"), bp::arg("ktype")=(int)(6) ) );
    
    }

    { //::cv::getKernelType
    
        typedef int ( *getKernelType_function_type )( ::cv::Mat const &,::cv::Point );
        
        bp::def( 
            "getKernelType"
            , getKernelType_function_type( &::cv::getKernelType )
            , ( bp::arg("kernel"), bp::arg("anchor") ) );
    
    }

    { //::cv::getLinearColumnFilter
    
        typedef ::cv::Ptr< cv::BaseColumnFilter > ( *getLinearColumnFilter_function_type )( int,int,::cv::Mat const &,int,int,double,int );
        
        bp::def( 
            "getLinearColumnFilter"
            , getLinearColumnFilter_function_type( &::cv::getLinearColumnFilter )
            , ( bp::arg("bufType"), bp::arg("dstType"), bp::arg("kernel"), bp::arg("anchor"), bp::arg("symmetryType"), bp::arg("delta")=0, bp::arg("bits")=(int)(0) ) );
    
    }

    { //::cv::getLinearFilter
    
        typedef ::cv::Ptr< cv::BaseFilter > ( *getLinearFilter_function_type )( int,int,::cv::Mat const &,::cv::Point,double,int );
        
        bp::def( 
            "getLinearFilter"
            , getLinearFilter_function_type( &::cv::getLinearFilter )
            , ( bp::arg("srcType"), bp::arg("dstType"), bp::arg("kernel"), bp::arg("anchor")=cv::Point_<int>(-0x000000001, -0x000000001), bp::arg("delta")=0, bp::arg("bits")=(int)(0) ) );
    
    }

    { //::cv::getLinearRowFilter
    
        typedef ::cv::Ptr< cv::BaseRowFilter > ( *getLinearRowFilter_function_type )( int,int,::cv::Mat const &,int,int );
        
        bp::def( 
            "getLinearRowFilter"
            , getLinearRowFilter_function_type( &::cv::getLinearRowFilter )
            , ( bp::arg("srcType"), bp::arg("bufType"), bp::arg("kernel"), bp::arg("anchor"), bp::arg("symmetryType") ) );
    
    }

    { //::cv::getMorphologyColumnFilter
    
        typedef ::cv::Ptr< cv::BaseColumnFilter > ( *getMorphologyColumnFilter_function_type )( int,int,int,int );
        
        bp::def( 
            "getMorphologyColumnFilter"
            , getMorphologyColumnFilter_function_type( &::cv::getMorphologyColumnFilter )
            , ( bp::arg("op"), bp::arg("type"), bp::arg("ksize"), bp::arg("anchor")=(int)(-0x000000001) ) );
    
    }

    { //::cv::getMorphologyFilter
    
        typedef ::cv::Ptr< cv::BaseFilter > ( *getMorphologyFilter_function_type )( int,int,::cv::Mat const &,::cv::Point );
        
        bp::def( 
            "getMorphologyFilter"
            , getMorphologyFilter_function_type( &::cv::getMorphologyFilter )
            , ( bp::arg("op"), bp::arg("type"), bp::arg("kernel"), bp::arg("anchor")=cv::Point_<int>(-0x000000001, -0x000000001) ) );
    
    }

    { //::cv::getMorphologyRowFilter
    
        typedef ::cv::Ptr< cv::BaseRowFilter > ( *getMorphologyRowFilter_function_type )( int,int,int,int );
        
        bp::def( 
            "getMorphologyRowFilter"
            , getMorphologyRowFilter_function_type( &::cv::getMorphologyRowFilter )
            , ( bp::arg("op"), bp::arg("type"), bp::arg("ksize"), bp::arg("anchor")=(int)(-0x000000001) ) );
    
    }

    { //::cv::getNumThreads
    
        typedef int ( *getNumThreads_function_type )(  );
        
        bp::def( 
            "getNumThreads"
            , getNumThreads_function_type( &::cv::getNumThreads ) );
    
    }

    { //::cv::getOptimalDFTSize
    
        typedef int ( *getOptimalDFTSize_function_type )( int );
        
        bp::def( 
            "getOptimalDFTSize"
            , getOptimalDFTSize_function_type( &::cv::getOptimalDFTSize )
            , ( bp::arg("vecsize") )
            , "\nReturns optimal DFT size for a given vector size."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-getoptimaldftsize" );
    
    }

    { //::cv::getRectSubPix
    
        typedef void ( *getRectSubPix_function_type )( ::cv::Mat const &,::cv::Size,::cv::Point2f,::cv::Mat &,int );
        
        bp::def( 
            "getRectSubPix"
            , getRectSubPix_function_type( &::cv::getRectSubPix )
            , ( bp::arg("image"), bp::arg("patchSize"), bp::arg("center"), bp::arg("patch"), bp::arg("patchType")=(int)(-0x000000001) ) );
    
    }

    { //::cv::getRotationMatrix2D
    
        typedef ::cv::Mat ( *getRotationMatrix2D_function_type )( ::cv::Point2f,double,double );
        
        bp::def( 
            "getRotationMatrix2D"
            , getRotationMatrix2D_function_type( &::cv::getRotationMatrix2D )
            , ( bp::arg("center"), bp::arg("angle"), bp::arg("scale") ) );
    
    }

    { //::cv::getRowSumFilter
    
        typedef ::cv::Ptr< cv::BaseRowFilter > ( *getRowSumFilter_function_type )( int,int,int,int );
        
        bp::def( 
            "getRowSumFilter"
            , getRowSumFilter_function_type( &::cv::getRowSumFilter )
            , ( bp::arg("srcType"), bp::arg("sumType"), bp::arg("ksize"), bp::arg("anchor")=(int)(-0x000000001) ) );
    
    }

    { //::cv::getStructuringElement
    
        typedef ::cv::Mat ( *getStructuringElement_function_type )( int,::cv::Size,::cv::Point );
        
        bp::def( 
            "getStructuringElement"
            , getStructuringElement_function_type( &::cv::getStructuringElement )
            , ( bp::arg("shape"), bp::arg("ksize"), bp::arg("anchor")=cv::Point_<int>(-0x000000001, -0x000000001) ) );
    
    }

    { //::cv::getThreadNum
    
        typedef int ( *getThreadNum_function_type )(  );
        
        bp::def( 
            "getThreadNum"
            , getThreadNum_function_type( &::cv::getThreadNum ) );
    
    }

    { //::cv::getTickCount
    
        typedef ::int64 ( *getTickCount_function_type )(  );
        
        bp::def( 
            "getTickCount"
            , getTickCount_function_type( &::cv::getTickCount ) );
    
    }

    { //::cv::getTickFrequency
    
        typedef double ( *getTickFrequency_function_type )(  );
        
        bp::def( 
            "getTickFrequency"
            , getTickFrequency_function_type( &::cv::getTickFrequency ) );
    
    }

    { //::cv::getTrackbarPos
    
        typedef int ( *getTrackbarPos_function_type )( ::std::string const &,::std::string const & );
        
        bp::def( 
            "getTrackbarPos"
            , getTrackbarPos_function_type( &::cv::getTrackbarPos )
            , ( bp::arg("trackbarname"), bp::arg("winname") )
            , "\nReturns the trackbar position."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/user_interface.html#cv-gettrackbarpos" );
    
    }

    { //::cv::getValidDisparityROI
    
        typedef ::cv::Rect ( *getValidDisparityROI_function_type )( ::cv::Rect,::cv::Rect,int,int,int );
        
        bp::def( 
            "getValidDisparityROI"
            , getValidDisparityROI_function_type( &::cv::getValidDisparityROI )
            , ( bp::arg("roi1"), bp::arg("roi2"), bp::arg("minDisparity"), bp::arg("numberOfDisparities"), bp::arg("SADWindowSize") ) );
    
    }

    { //::cv::getWindowProperty
    
        typedef double ( *getWindowProperty_function_type )( ::std::string const &,int );
        
        bp::def( 
            "getWindowProperty"
            , getWindowProperty_function_type( &::cv::getWindowProperty )
            , ( bp::arg("winname"), bp::arg("prop_id") ) );
    
    }

    { //::cv::grabCut
    
        typedef void ( *grabCut_function_type )( ::cv::Mat const &,::cv::Mat &,::cv::Rect,::cv::Mat &,::cv::Mat &,int,int );
        
        bp::def( 
            "grabCut"
            , grabCut_function_type( &::cv::grabCut )
            , ( bp::arg("img"), bp::arg("mask"), bp::arg("rect"), bp::arg("bgdModel"), bp::arg("fgdModel"), bp::arg("iterCount"), bp::arg("mode")=int(::cv::GC_EVAL) ) );
    
    }

    { //::cv::flann::hierarchicalClustering
    
        typedef int ( *hierarchicalClustering_function_type )( ::cv::Mat const &,::cv::Mat &,::cv::flann::KMeansIndexParams const & );
        
        bp::def( 
            "hierarchicalClustering"
            , hierarchicalClustering_function_type( &::cv::flann::hierarchicalClustering )
            , ( bp::arg("features"), bp::arg("centers"), bp::arg("params") ) );
    
    }

}
